<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>TinySTL 实现项目（三）：具有SGI特色的两级分配器alloc模板类</title>
    <url>/2020/01/07/STL3-SGI2StageAllocator/</url>
    <content><![CDATA[<h2 id="1-SGI-STL-2-91-中空间分配器alloc的设计思想"><a href="#1-SGI-STL-2-91-中空间分配器alloc的设计思想" class="headerlink" title="1 SGI STL 2.91 中空间分配器alloc的设计思想"></a>1 SGI STL 2.91 中空间分配器alloc的设计思想</h2><p>在<a href="https://choubin.site/2020/01/02/STL2-AlloctorAndCtorDtor/" target="_blank" rel="noopener">上篇文章</a>中，我们实现了使用<code>::operator new</code>和<code>::operator delete</code>来分配、释放内存的空间分配器<code>allocator</code>模板类。但在SGI STL 2.91版的源码实现中，其使用的空间分配器并非如此简单，而是以更底层的<code>malloc()</code>、<code>free()</code>来分配、释放内存，其设计哲学在《STL源码剖析》中总结如下：</p>
<div class="note info"><ul><li>向 system heap 要求空间</li><li>考虑多线程状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多小型区块可能造成的<strong>内存碎片（fragment）</strong>问题</li></ul></div>

<p>而其避免<strong>内存碎片问题</strong>的方法就是设计了两级分配器</p>
<ul>
<li><p>第一级分配器：当一次要求的内存<strong>超过</strong>128bytes时使用，其直接使用<code>malloc()</code>、<code>free()</code></p>
</li>
<li><p>第二级分配器：当一次要求的内存<strong>小于</strong>128bytes时使用， 采用了内存池<code>memory pool</code>整理方式，维护了16个链表，这些链表分别负责从8bytes、16bytes、24bytes直到128bytes的16种小型内存块的分配。</p>
</li>
</ul>
<p>其中第一级分配器还考虑了<strong>OOM(out of memory)</strong>时的处理，实现了类似C++中<code>new-handler</code>的机制，使得在内存不足抛出<code>std::bad_alloc</code>异常前，可以调用一个用户自行定义的函数来尝试解决内存不足问题，如果用户没有定义该函数，则直接抛出<code>std::bad_alloc</code>异常。</p>
<p>而在实现中，甚至都没有完全符合STL标准，比如<code>alloc::construct</code>就不存在，这里简单说一下其具体实现。</p>
<h3 id="1-1-SGI-的第一级分配器"><a href="#1-1-SGI-的第一级分配器" class="headerlink" title="1.1 SGI 的第一级分配器"></a>1.1 SGI 的第一级分配器</h3><p>第一级分配器：一个名为<code>__malloc_alloc_template&lt;int inst&gt;</code>的模板类，模板参数实际上并没用上；分别基于<code>malloc()</code>、<code>free()</code>、<code>realloc()</code>来实现<code>allocate()</code>、<code>deallocate()</code>、<code>reallocate()</code>这三个<code>public</code>成员函数；另外拥有一个函数指针类型的静态成员<code>malloc_alloc_oom_handler</code>和设定该静态成员的<code>public</code>成员函数<code>set_malloc_handler</code>，这是用于实现上述<code>new-handler</code>机制的；最后还有两个<code>private</code>的函数<code>oom_malloc</code>、<code>oom_realloc</code>来处理OOM情况，这两个函数会先调用之前的那个函数指针静态成员所指向的函数，然后再尝试分配内存，如果用户没有实现设定该静态成员指向的函数，会直接报错<code>cerr &lt;&lt; “out of memory”</code>然后<code>exit(1)</code>中止程序。部分实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_malloc(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* n */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = f;</span><br><span class="line">    <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-SGI-的第二级分配器"><a href="#1-2-SGI-的第二级分配器" class="headerlink" title="1.2 SGI 的第二级分配器"></a>1.2 SGI 的第二级分配器</h3><p>第二级分配器：具体实现有点小复杂，由于本项目使用的第二级分配器基本同SGI的一致，所以具体函数实现留待下文讲解，这里只简单总结一下其思路。同上文所述，其将小于128bytes的内存按照8bytes为间隔，划分为16种大小的内存区块，然后用16条链表来维护这些区块。</p>
<p>比如第一条链表管理8bytes的内存块，假设其有10个节点，这10个节点每个都有8bytes的空间可以拨给用户使用，用户用<code>allocate()</code>请求8bytes大小的空间时，就返回给用户1个节点的空间，此时剩9个节点，如果用户用<code>deallocate()</code>释放了8bytes的空间，那么这个节点又会被回收到这条链表上，又变成了10个节点。其他的链表就是如此依次维护16bytes、24bytes、32bytes等等大小的内存块。</p>
<p>那如果用户请求的bytes数目大小不是8的倍数呢？比如30，分配器就会将其自动上调为32，然后找负责32bytes的链表分配空间。需要说明的是，这里的链表节点使用了<code>union</code>类型，而不是常用的<code>struct</code>，这是因为<code>union</code>类型用在这里更节约空间。</p>
<div class="note info"><p><code>union</code>类型比较特殊，其内部成员可以共享内存，每个<code>union</code>对象分配的内存以其最大的成员而定，这里的最大指的是<code>sizeof()</code>后最大。 </p><p>当多个基本数据类型或复合数据结构要占用同一片内存时，我们要使用联合体；当多种类型，多个对象，多个事物只取其一时（我们姑且通俗地称其为“n 选1”），我们也可以使用联合体来发挥其长处。 </p><p>这里用<code>union</code>实现的链表，每个节点包含一个指向自身类型的指针<code>next</code>和一个<code>char*</code>类型指针，那么其第一个成员<code>next</code>可以用来连接链表，而第二个成员<code>char*</code>又可以表示为一个指向实际内存区块的指针，可以用来分配给用户使用。</p></div>

<p>最终第一级分配器和第二级分配器的实现也并未完全符合STL的标准，比如<code>allocate()</code>的参数就和STL要求的不一样，<code>reallocate()</code>也不是STL要求的，另外<code>allocate::construct()</code>等函数也没有实现。所以SGI还将其包装了一个接口，使分配器的<code>allocate()</code>和<code>deallocate()</code>符合STL标准，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，SGI STL的源码中，第二级分配器还考虑了多线程情况，而我们的项目是以学习为目的，自然对复杂程度要有所取舍，故而在我们的实现中只考虑单线程的普通情况。</p>
<p>接下来即是根据SGI STL源码来实现的一个不使用多线程的<code>alloc</code>模板类。在代码上仅做了极小的修改，看完了本项目的实现，也就明白了SGI的实现。</p>
<div class="note warning"><p>为什么本节标题要强调2.91的SGI实现版本呢？因为在部分后续版本的实现中，SGI就去掉了两级分配器和memory poll的实现思想。去掉原因目前我还不知道。。。</p></div>

<h2 id="2-部分考虑和相应改动"><a href="#2-部分考虑和相应改动" class="headerlink" title="2 部分考虑和相应改动"></a>2 部分考虑和相应改动</h2><p>本项目的这部分的实现思路将基本参照 SGI，仅做小部分的改动。</p>
<p>考虑1：在SGI 的实现中，第一级分配器是一个类模板，但是却没有用到模板参数，第二级分配器也是一个类模板，第一个模板参数考虑多线程，第二个模板参数依然没用上。而在我们的实现中，不考虑多线程情况，就没有必要使用多余的模板参数了，甚至没必要使用模板。</p>
<p>改动1：<strong>直接将两级分配器设计为两个普通类</strong>。</p>
<p>考虑2：如上文所述，SGI 对两级分配器的包装是一个带两个参数的模板类<code>simple_alloc</code>，使用时还需要根据宏定义在第二模板参数上确定仅使用第一级分配器还是同时使用两级分配器，然后再将分配器作为模板参数放入，由于命名问题还需要为具化后的<code>simple_alloc</code>定义别名。</p>
<p>改动2：本项目中将其包装的模板改动为<strong>一个参数的模板类</strong>，在该模板的成员函数中<strong>直接调用第二级分配器</strong>，并且为该模板<strong>补充<code>alloc::construct</code>等 STL 要求的标准接口</strong>。另外由于本项目已实现名为<code>allocator</code>的分配器，故而将本部分的分配器包装接口命名为<code>alloc</code>。</p>
<h2 id="3-TinySTL-第一级分配器的实现"><a href="#3-TinySTL-第一级分配器的实现" class="headerlink" title="3 TinySTL 第一级分配器的实现"></a>3 TinySTL 第一级分配器的实现</h2><h3 id="3-1-接口总览"><a href="#3-1-接口总览" class="headerlink" title="3.1 接口总览"></a>3.1 接口总览</h3><p>因为第一级分配器直接使用<code>malloc()</code>来分配内存，这里将其取名为<code>malloc_alloc</code>。在 SGI 的实现中，其是一个类模板，但却并没有使用到其模板参数，所以这里直接将其设计为普通的类。先确定要实现的相应函数和成员，代码如下：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 malloc 和 free 实现的一级分配器</span></span><br><span class="line"><span class="comment">// 可以由客端设置 OOM 时的 new_handler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">malloc_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 一个函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> FunPtr = <span class="keyword">void</span> (*)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span>&#123; <span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FunPtr <span class="title">set_malloc_handler</span><span class="params">(FunPtr f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 用于处理OOM时的辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 函数指针类型的静态成员。也可以写成 FunPtr malloc_alloc_oom_handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>allocate()</code>的返回类型是<code>void</code>指针类型，这里依然是参照 SGI 的设计，<strong>让第一级和第二级分配器所分配的空间都用<code>void</code>指针类型，最后在外层包装的模板类接口上统一转换</strong>，既简单也不会影响效率。</p>
<h3 id="3-2-allocate和deallocate的实现"><a href="#3-2-allocate和deallocate的实现" class="headerlink" title="3.2 allocate和deallocate的实现"></a>3.2 allocate和deallocate的实现</h3><p>先直接来看<code>allocate()</code>的代码实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        result = malloc_alloc::oom_malloc(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其仅接受一个<code>size_t</code>类型的参数<code>n</code>，先调用<code>malloc</code>来分配<strong>大小为<code>n</code>个字节（byte）的内存块</strong>。<strong>这和上篇文章中实现的<code>allocator&lt;T&gt;::allocate(size_t n)</code>不一样，其分配的是大小为<code>n * sizeof(T)</code>个字节的内存块。</strong>如果分配空间失败，则调用内部辅助函数<code>oom_malloc()</code>来继续尝试分配空间。</p>
<div class="note info"><p><code>void* malloc(size_t n_bytes)</code>分配长度为n_bytes字节的内存块。分配成功则返回类型为<code>void</code>指向被分配内存的指针，否则返回空指针<code>NULL</code>。释放<code>malloc</code>分配的内存应使用<code>free()</code>。</p></div>

<p>蓝色背景内容所述，在3.1节的代码中可以看到<code>deallocte()</code>接受一个指针，直接使用<code>free()</code>来释放内存。</p>
<h3 id="3-3-reallocate的实现"><a href="#3-3-reallocate的实现" class="headerlink" title="3.3 reallocate的实现"></a>3.3 reallocate的实现</h3><p>其实最终对外包装的模板类中并没有使用到<code>reallocate()</code>，本着学习的态度，就顺便照着 SGI 的敲了一遍。代码实现如下：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::reallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz) &#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="built_in">realloc</span>(ptr, new_sz);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        result = malloc_alloc::oom_realloc(ptr, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到跟<code>allocate()</code>相比，仅仅是换成了使用<code>realloc</code>实现</p>
<div class="note info"><p> <code>void* realloc (void* ptr, size_t size)</code>，ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小。realloc() 对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小，还可以不变。当 malloc()、calloc() 分配的内存空间不够用时，就可以用 realloc() 来调整已分配的内存。</p><p>如果 ptr 为 NULL，它的效果和 malloc() 相同；如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。 </p></div>

<div class="note warning"><p><code>realloc</code>接受的指针必须是动态内存空间分配成功的指针。比如不能使用<code>int* p</code>、<code>int arr[2]</code>这样的指针，会直接报错。可以说只有<code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code>分配成功成功的指针才能用<code>realloc</code>。</p><p>使用<code>new_ptr=realloc(prt,n)</code>分配内存成功后，ptr绝不能再被使用，只能使用<code>new_ptr</code>。</p><p>扩大内存会复制原来内存到新地址，缩小内存会先被复制再被截取新长度。</p></div>

<h3 id="3-4-new-handler机制的实现"><a href="#3-4-new-handler机制的实现" class="headerlink" title="3.4 new_handler机制的实现"></a>3.4 new_handler机制的实现</h3><p><code>new_handler</code>机制就是，当使用<code>::operator new</code>分配内存不满足需求时，可以在抛出异常之前，调用一个用户实现指定的函数来进行错误处理，这个函数就是所谓的<code>new_handle</code>。而指定这个函数的方法就是使用<code>set_new_handler()</code>，这个函数接受一个函数指针类型，返回的也是函数指针类型。</p>
<p>由于在这里，我们使用<code>malloc</code>而不是<code>::operator new</code>来实现<code>allocate()</code>，所以我们不能直接使用C++现有的<code>new_handler</code>机制，需要我们手动来实现。</p>
<p>实现方法也很简单，如3.1节中的代码所示，我们先在类中声明一个函数指针类型的静态成员，用来指向用户设定的函数。然后在类中声明一个成员函数，用来设定该静态成员。如代码所示。</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">malloc_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 一个函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> FunPtr = <span class="keyword">void</span> (*)();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FunPtr <span class="title">set_malloc_handler</span><span class="params">(FunPtr f)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 函数指针类型的静态成员。也可以写成 FunPtr malloc_alloc_oom_handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设定静态成员的函数即是<code>set_malloc_handler</code>，实现如下</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> malloc_alloc::FunPtr malloc_alloc::set_malloc_handler(FunPtr fptr) &#123;</span><br><span class="line">    FunPtr old = malloc_alloc_oom_handler;</span><br><span class="line">    malloc_alloc_oom_handler = fptr;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受一个函数指针类型的参数，返回值也是一个函数指针类型。功能就是将代表<code>handler</code>的静态成员设为用户传进来的函数，最后返回原来的<code>handler</code>函数。</p>
<p>显然上述这个代表<code>handler</code>的函数指针静态成员应该初始化为0或者<code>nullptr</code></p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*malloc_alloc::malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-OOM时的处理"><a href="#3-5-OOM时的处理" class="headerlink" title="3.5 OOM时的处理"></a>3.5 OOM时的处理</h3><p>3.4节中我们已经实现了<code>new_handler</code>机制，OOM(out of memory)时就会使用到该机制，调用用户设定的函数来处理，期待可以解决内存不足的问题、或者直接输出提示信息中断程序等。</p>
<p>在<code>allocate</code>和<code>reallocate</code>的实现可以中我们看到了，在请求分配内存失败时，也就是OOM时，将会调用两个辅助函数<code>oom_malloc</code>和<code>oom_realloc</code>。这两个函数的实现大同小异，这里先看<code>oom_malloc</code>如何实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::oom_malloc(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">	<span class="comment">// 若用户并未设定 handler 函数，则输出报错信息</span></span><br><span class="line">    <span class="keyword">if</span> (malloc_alloc_oom_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则不断尝试调用 handler 函数，然后用malloc再次请求分配内存，直到分配成功</span></span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        malloc_alloc_oom_handler();</span><br><span class="line">        result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数比较简单，看注释应该就够了。下面看<code>oom_realloc</code>的实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::oom_realloc(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> new_sz) &#123;</span><br><span class="line">	<span class="comment">// 若用户未设定 handler 函数，则输出报错信息</span></span><br><span class="line">    <span class="keyword">if</span> (malloc_alloc_oom_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则不断尝试调用 handler 函数，然后用realloc请求重新分配内存，直到分配成功</span></span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        malloc_alloc_oom_handler();</span><br><span class="line">        result = <span class="built_in">realloc</span>(ptr, new_sz);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-TinySTL-第二级分配器的实现"><a href="#4-TinySTL-第二级分配器的实现" class="headerlink" title="4 TinySTL 第二级分配器的实现"></a>4 TinySTL 第二级分配器的实现</h2><p>由于在实际使用中是默认调用第二级分配器，然后第二级分配器会根据所需要的内存块大小，来决定是否调用第一级分配器，所以此处将第二级分配器命名为<code>default_alloc</code>。</p>
<p>如1.2节所述，这里使用了内存池(memory pool)机制，用16条链表来维护16种大小的内存块，这些内存块大小是从最小8 bytes，以 8 bytes 为间隔，到最大128 bytes ；当请求的内存小于128 bytes 时，就从相应的链表里，将内存分配出去，若大于128 bytes 就调用第一级分配器。</p>
<p>使用内存池机制的目的主要有两个：</p>
<ul>
<li>减少<code>malloc</code>的调用次数，因为每次调用<code>malloc</code>的时候，其实都需要时间开销去寻找可使用的内存块</li>
<li>减少实际内存开销，因为<code>malloc</code>来分配内存的开销会比实际所需要内存更大，因为需要额外的空间来管理这一块内存；如下图所示，实际需要<code>size</code>大小的内存和最终开销的内存</li>
</ul>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/malloc%E5%86%85%E5%AD%98.png" alt="内存管理"></p>
<p>而这些通过链表不同大小的内存块从何而来呢？难道需要每次<code>malloc</code>这些大小不一的内存块了吗？如果这样的话，内存池的就没有意义了。</p>
<p>我们可以一次<code>malloc</code>一大块内存，然后每次需要特定大小的内存时，从这一大块内存划拨到相应的链表，然后通过链表去分配。比如我一次<code>malloc</code>了512 bytes，然后这个时候用户请求分配 8 bytes，那我就一次划拨160 个bytes 到管理8 bytes大小内存块的链表上，此时链表有160 / 8 = 20 个节点；然后从这个20 个节点里分一个节点给用户使用。</p>
<p>虽然第一次分配的时候看起来比较麻烦，但之后用户再要求分配 8 bytes时，我就可以直接从链表剩下的19个节点里分给他，没有必要再使用<code>malloc</code>；而用户释放 8 bytes 大小时，我就可以将这 8bytes 回收到管理的链表上。这样我只<code>malloc</code>了一次，却可以满足20次用户要求分配 8 bytes的需求。</p>
<span class="label danger">所以我们可以这么理解，实际上第二级分配器管理的内存也有两部分，一部分是链表维护的各种大小不一的小内存，另一部分则</span>

<span class="label danger">是由`malloc`得来的大内存块，负责为链表“输血”。</span>

<h3 id="4-1-接口总览"><a href="#4-1-接口总览" class="headerlink" title="4.1 接口总览"></a>4.1 接口总览</h3><p>下面是内存实现的总览：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">default_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; MAX_BYTES = <span class="number">128</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; NFREELISTS = MAX_BYTES / ALIGN &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj* next;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* start_free;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* end_free;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line">    <span class="keyword">static</span> obj* <span class="keyword">volatile</span> free_list[NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">round_up</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((bytes + ALIGN - <span class="number">1</span>) &amp; ~(ALIGN - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">freelist_index</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((bytes + ALIGN - <span class="number">1</span>) / ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span>&amp; nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_size, <span class="keyword">size_t</span> new_size)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先是三个枚举类型，分别表示内存块大小的间隔、最大内存块的大小、以及所需要的维护的链表数量。声明成枚举类型主要是为了方便以后对这些值进行修改。</p>
<p>接着一个是<code>union</code>类型，用来作为链表的节点，使用<code>union</code>的原因上文已有解释，主要是利用其成员共享内存的特点来节约内存的开销。而其第二个成员为<code>char</code>类型的原因是，<strong>个人理解</strong>是因为<code>char</code>的长度为1B，也就是8bytes，与我们最小的内存块单位相等。</p>
<p>然后是四个静态成员。<code>start_free</code>和<code>end_free</code>就是用来管理<code>malloc</code>得到的一大块等待划拨给链表的内存块，分别表示内存块的头和尾。<code>heap_size</code>是一个和用户请求分配内存大小相关的值，用户请求的内存越多，该值就会越大，然后在用户每次用完了大内存块，而需要重新<code>malloc</code>的时候，会附加上<code>heap_size</code>的一个加权值；这样的结果就是，用户目前使用第二级分配器分配的内存块越多，下次<code>malloc</code>的时候就会分配得更多，其目的还是尽量减少<code>malloc</code>的次数。最后一个成员<code>free_list</code>就是存放16条链表的数组。</p>
<p>注意静态成员需要初始化：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* default_alloc::start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* default_alloc::end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> default_alloc::heap_size = <span class="number">0</span>;</span><br><span class="line">default_alloc::obj* <span class="keyword">volatile</span> default_alloc::free_list[NFREELISTS] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还需要介绍两个辅助函数<code>round_up</code>和<code>freelist_index</code>。前一个是用来将传入的参数补为8的倍数，比如请求分配30 bytes 的大小时，就将30补成32。后一个参数用来确定管理内存块的链表在数组<code>free_list</code>中的索引，如传入8，就返回索引0。</p>
<p>其余函数的作用和实现见下文。</p>
<h3 id="4-1-allocate-的实现"><a href="#4-1-allocate-的实现" class="headerlink" title="4.1 allocate 的实现"></a>4.1 allocate 的实现</h3><p><code>allocate</code>的作用我们已经说过多次，这里不同的只是，根据请求空间的大小，找到相应的链表，然后返回链表的一个节点供用户使用。如果发现相应的链表空了，就调用<code>refill</code>来填充链表。直接看实现</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* default_alloc::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 如果请求的大小超过 128 bytes就调用第一级分配器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">128</span>)</span><br><span class="line">        <span class="keyword">return</span> malloc_alloc::allocate(n);</span><br><span class="line">    <span class="comment">// 否则找到相应链表，注意这是一个指向链表头指针的指针</span></span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list = free_list + freelist_index(n);</span><br><span class="line">    obj* result = *my_free_list;</span><br><span class="line">    <span class="comment">// 如果链表为空，就调用 refill 填充链表，refill会直接返回一个相应大小的空间供用户使用</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> refill(n);</span><br><span class="line">    <span class="comment">// 不为空则调整链表，使表头变更到下一个节点</span></span><br><span class="line">    *my_free_list = (*my_free_list)-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现比较简单，应该看上面注释就足够了，最后不进行静态转换也是可以通过编译的。</p>
<h3 id="4-2-deallocate-的实现"><a href="#4-2-deallocate-的实现" class="headerlink" title="4.2 deallocate 的实现"></a>4.2 deallocate 的实现</h3><p>这里的<code>deallocate</code>和第一级分配器中直接<code>free</code>有所不同，也考虑两种情况：如果需要释放的内存大于128 bytes 则调用第一级分配器，否则就将其回收到相应的链表。这样的设计在最优情况下，自然可以物尽其用，链表达到“收支平衡”，不需要多次调用<code>malloc</code>。下面是实现</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> default_alloc::deallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 释放空间大于128bytes调用第一级分配器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">128</span>) &#123;</span><br><span class="line">        malloc_alloc::deallocate(ptr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则将其回收到相应链表</span></span><br><span class="line">    obj* p = <span class="keyword">static_cast</span>&lt;obj*&gt;(ptr);</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list = free_list + freelist_index(n);</span><br><span class="line">    p-&gt;next = *my_free_list;</span><br><span class="line">    *my_free_list = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现比较简单，无非是回收到链表时，将其插到链表表头。</p>
<h3 id="4-3-reallocate-的实现"><a href="#4-3-reallocate-的实现" class="headerlink" title="4.3 reallocate 的实现"></a>4.3 reallocate 的实现</h3><p>第一级分配器中的<code>reallocate</code>是直接通过<code>realloc</code>实现，关于<code>realloc</code>的介绍可以看3.3节中带颜色的字体。下面直接看实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* default_alloc::reallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_size, <span class="keyword">size_t</span> new_size) &#123;</span><br><span class="line">    <span class="comment">// 如果新旧 size 都大于 128 bytes则使用realloc</span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt; MAX_BYTES &amp;&amp; new_size &gt; MAX_BYTES)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">realloc</span>(ptr, new_size);</span><br><span class="line">    <span class="comment">// 否则看是不是在同一个小内存区间，是的话没必要操作</span></span><br><span class="line">    <span class="keyword">if</span> (round_up(old_size) == round_up(new_size))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    <span class="comment">// 都不是的话，需要模拟一下ralloc的操作</span></span><br><span class="line">    <span class="comment">// 开辟新内存，复制原来的部分，最后释放原内存</span></span><br><span class="line">    <span class="keyword">void</span>* result = allocate(new_size);</span><br><span class="line">    <span class="keyword">size_t</span> copy_sz = new_size &gt; old_size ? new_size : old_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(result, ptr, copy_sz);</span><br><span class="line">    deallocate(ptr, old_size);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存管理，肯定要秉承谁分配的谁释放的原则。</p>
<p>显然大于128 bytes的话，说明该内存并不是第二级分配器分配的，让他找第一级分配器去。</p>
<p>如果确定是由第二级分配器分配的，就看看新要求的空间大小<code>new_size</code>跟原来的大小<code>old_size</code>在不在一个内存区间上，比如<code>old_size</code>是20 bytes，<code>new_size</code>是24 bytes，都在(16,24]区间里；因为分配的时候，如果要求 20 bytes，实际还是会给24 bytes，所以其实此时内存大小是满足需求的，直接用原来的就行，没必要操作。</p>
<p>排除以上情况以外，就需要新开辟一块大小为<code>new_size</code>，然后将原来的部分复制过来，复制部分肯定是不会超过原来的大小，也不会超过新长度，反正就是谁小取谁；最后还要记得释放原来的内存，调用<code>deallocate</code>即可。</p>
<h3 id="4-4-refill-的实现"><a href="#4-4-refill-的实现" class="headerlink" title="4.4 refill 的实现"></a>4.4 refill 的实现</h3><p>在<code>allocate</code>函数中，当对应所需内存大小的链表为空时，需要调用<code>refill</code>来为用户提供内存，除此以外，<code>refill</code>还会为填充对应链表，在下次请求相同大小内存时，就可以直接从链表中取了。下面是其实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* default_alloc::refill(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 设定请求相应小内存块节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// chunk_alloc会从大内存块中划拨相应大小的内存供其使用</span></span><br><span class="line">    <span class="comment">// 这里nobjs是传引用，会修改nobjs的值告知实际返回多少个节点</span></span><br><span class="line">    <span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    <span class="comment">// 如果只返回了1个节点大小的空间，则直接提供给用户使用</span></span><br><span class="line">    <span class="keyword">if</span> (nobjs == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(chunk);</span><br><span class="line">    <span class="comment">// 多于1个节点则将剩下节点填充到相应链表</span></span><br><span class="line">    <span class="keyword">void</span>* result = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(chunk);</span><br><span class="line">    obj *next_obj, *current_obj;</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list = free_list + freelist_index(n);</span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; ++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            current_obj-&gt;next = next_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际实现并不复杂，可以看到，当对应的链表为空的时候，默认会请求20个节点的大小，比如这个链表管理的是64 bytes的大小，那么就会向大内存块请求 20 * 64 bytes的空间，然后将其中的19个放到链表中，留1一个直接返回给用户使用（<code>allocate</code>中对<code>refill</code>的调用）。</p>
<p>值得说明的是，<code>chunk_alloc</code>函数会根据现有的大内存块的大小，来决定实际返回的个数，并通过传引用<code>objs</code>参数对其修改，达到告知的目的。接上面的例子，比如现在大内存块中只有64 bytes的大小了，那么<code>chunk_alloc</code>就会只返回64 bytes，解解燃眉之急，然后修改objs的值为1，当然要是有128 bytes，那就返回2个；但是如果大内存块里连64 bytes的大小都没了，就会<code>malloc</code>一次，取得足够大的空间，返回20个。具体实现见下一节。</p>
<h3 id="4-5-chunk-alloc-的实现"><a href="#4-5-chunk-alloc-的实现" class="headerlink" title="4.5 chunk_alloc 的实现"></a>4.5 chunk_alloc 的实现</h3><p>如4.4节所述，<code>chunk_alloc</code>函数作用就是在链表的内存需要补充时，从大内存块中划拨一部分内存给<code>refill</code>使用，若是大内存块不够用了，就<code>malloc</code>一大块内存，保证满足当前的需求之外，还能留着用。先直接看实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span>* default_alloc::chunk_alloc(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = <span class="built_in">size</span> * nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line">    <span class="comment">// 若原本的大内存块剩下的空间能够满足需求，直接划拨</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若剩下的内存能够提供至少1个节点大小，则尽可能划拨</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">        nobjs = bytes_left / <span class="built_in">size</span>;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += nobjs * <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 否则使用malloc请求（当前需求*2+历史需求/16）的大小</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + round_up(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 检查目前剩下的空间够不够划拨给其他更小内存块的链表</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list =</span><br><span class="line">                free_list + freelist_index(bytes_left);</span><br><span class="line">            ((obj*)start_free)-&gt;next = *my_free_list;</span><br><span class="line">            *my_free_list = (obj*)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="comment">// malloc失败的话，从更大内存块的链表寻求空间，并将剩下空间放到大内存块中</span></span><br><span class="line">        <span class="keyword">if</span> (start_free == <span class="number">0</span>) &#123;</span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">            obj* ptr = *my_free_list;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="built_in">size</span>; i &lt;= MAX_BYTES; i += ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + freelist_index(i);</span><br><span class="line">                ptr = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (ptr != <span class="number">0</span>) &#123;</span><br><span class="line">                    *my_free_list = ptr-&gt;next;</span><br><span class="line">                    start_free = (<span class="keyword">char</span>*)ptr;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    <span class="keyword">return</span> chunk_alloc(<span class="built_in">size</span>, nobjs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更大链表也没有空间了，试试第一级分配器的new_handler机制</span></span><br><span class="line">            end_free = <span class="number">0</span>;</span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="comment">// malloc成功,递归调用自己向refill划拨空间</span></span><br><span class="line">        <span class="keyword">return</span> chunk_alloc(<span class="built_in">size</span>, nobjs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现逻辑并不复杂：当大内存块的空间够分配1个以上节点的时候，会尽可能地满足需求，划拨空间；当内存完全不够的时候就<code>malloc</code>一大块。</p>
<p>值得一说的是，当<code>malloc</code>失败的时候设计非常细致，可以做到对已有内存充分利用，没有丝毫浪费。首先使用<code>malloc</code>前就先检查，剩下的空间够不够分配给其他更小的链表，物尽其用；然后如果<code>malloc</code>成功了，皆大欢喜，再次递归地调用自己，向链表(实际为<code>refill</code>函数)划拨空间；如果<code>malloc</code>失败了，先检查其他管理更大内存块的链表中有没有空间可以使用，可以的话，先拿一个节点来用，并且这个节点剩下还得放回大内存块，如果这些链表都空了，那就调用第一级分配器，毕竟第一级分配器还实现了<code>new_handler</code>机制，也许能派上用场。</p>
<h2 id="5-TinySTL-类模板alloc的包装"><a href="#5-TinySTL-类模板alloc的包装" class="headerlink" title="5 TinySTL 类模板alloc的包装"></a>5 TinySTL 类模板alloc的包装</h2><p>在第3节和第4节实现的两级分配器，只是两个普通类，并且接口不符合STL要求。所以需要用一个类模板对其包装，过程也很简单，顺便也为其实现了<code>construct</code>、<code>destroy</code>、<code>address</code>、<code>max_size</code>、<code>rebind</code>接口，其实现与<a href="https://choubin.site/2020/01/02/STL2-AlloctorAndCtorDtor/" target="_blank" rel="noopener">上篇文章</a>中<code>allocator</code>的实现基本一致。下面是其部分实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// SGI STL 特色分配器，需要一个模板参数，具有 STL 标准接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类型别名定义</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer     = <span class="keyword">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference   = <span class="keyword">const</span> T&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type         = <span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类接口，使用静态函数实现可以使频繁调用下减小开销</span></span><br><span class="line">    <span class="comment">// 负责分配内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">(size_type n)</span></span>;</span><br><span class="line">    <span class="comment">// 负责释放内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T*, size_type n)</span></span>;</span><br><span class="line">    <span class="comment">// 负责构造对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, T&amp;&amp; value)</span></span>;</span><br><span class="line">    <span class="comment">// 负责析构对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* first, T* last)</span></span>;</span><br><span class="line">    <span class="comment">// 获取某对象的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">address</span><span class="params">(T&amp; val)</span></span>;</span><br><span class="line">    <span class="comment">// 获取可配置T类型对象的最大数目</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">max_size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 使T类型的alloctor可以为U类型的对象分配内存</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">        <span class="keyword">using</span> other = alloc&lt;U&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* alloc&lt;T&gt;::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : <span class="keyword">static_cast</span>&lt;T*&gt;(default_alloc::allocate(n * <span class="keyword">sizeof</span>(T)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* alloc&lt;T&gt;::allocate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(default_alloc::allocate(<span class="keyword">sizeof</span>(T)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> alloc&lt;T&gt;::deallocate(T* ptr, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">        default_alloc::deallocate((<span class="keyword">void</span>*)ptr, n * <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> alloc&lt;T&gt;::deallocate(T* ptr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        default_alloc::deallocate((<span class="keyword">void</span>*)ptr, <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于其他接口的函数实现与<a href="https://choubin.site/2020/01/02/STL2-AlloctorAndCtorDtor/" target="_blank" rel="noopener">上篇文章</a>中的完全一致，所以就不放上来了，<strong>完整代码</strong>可以参见<a href="https://github.com/Lammmmmmm/TinySTL/blob/master/alloc.h" target="_blank" rel="noopener">我的github项目里的alloc.h</a>。</p>
<h2 id="6-简单的性能分析和测试"><a href="#6-简单的性能分析和测试" class="headerlink" title="6 简单的性能分析和测试"></a>6 简单的性能分析和测试</h2><p>包括上篇文章中的<code>allocator</code>，目前在 TinySTL 项目中我们已经实现了两种分配器，但尚未实现容器，所以我们可以先使用 STL 库中现有的容器对两种分配器做个小测试，对其性能做个对比。</p>
<p>由于<code>vector</code>容器每次使用分配器请求空间的时候，会请求现在长度的两倍，比如<code>vector&lt;int&gt;</code>，一个<code>int</code>在一般的机器上面长度是4B，即32bytes，当<code>vector&lt;int&gt;</code>原来长度等于5时，再次扩容长度就会变成10，一次就请求了<code>5*32=160bytes</code>，这之后再插入数据已经不会再调用第二级分配器了。</p>
<p>因此，如果向<code>vector&lt;int&gt;</code>中插入1000000个数，无非就是<code>operator new</code>和<code>malloc</code>的差距，然而实际上<code>operator new</code>就是用<code>malloc</code>实现的，所以性能差别不大。</p>
<p>所以，我们可以使用<code>list&lt;int&gt;</code>来对两种分配器进行测试，因为<code>list</code>内部就是个双向链表，每插一个<code>int</code>类型就会调用分配器请求一个32bytes的大小。测试代码如下</p>
<figure class="highlight c++"><figcaption><span>test_alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; NUMBERS = <span class="number">10000000</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test of list</span></span><br><span class="line">    <span class="comment">// test of push_back</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1; <span class="comment">// std 默认分配器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>, mystl::allocator&lt;<span class="keyword">int</span>&gt;&gt; list2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>, mystl::alloc&lt;<span class="keyword">int</span>&gt;&gt; list3;</span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="comment">// srand(time(NULL));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUMBERS; ++i)</span><br><span class="line">        list1.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time to insert "</span> &lt;&lt; NUMBERS</span><br><span class="line">         &lt;&lt; <span class="string">" numbers in list with STL alloctor: "</span></span><br><span class="line">         &lt;&lt; <span class="built_in">end</span> - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUMBERS; ++i)</span><br><span class="line">        list2.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time to insert "</span> &lt;&lt; NUMBERS</span><br><span class="line">         &lt;&lt; <span class="string">" numbers in list with mystl alloctor: "</span></span><br><span class="line">         &lt;&lt; <span class="built_in">end</span> - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUMBERS; ++i)</span><br><span class="line">        list3.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time to insert "</span> &lt;&lt; NUMBERS</span><br><span class="line">         &lt;&lt; <span class="string">" numbers in list with mystl SGI alloc: "</span></span><br><span class="line">         &lt;&lt; <span class="built_in">end</span> - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来打算插入随机数的，想了想觉得没必要，还浪费调用<code>rand()</code>的时间，万一每次<code>rand()</code>的计算时间还不一样就不够客观了。所以直接插入1。在我的环境下跑了3次的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with STL alloctor: 1093750</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl alloctor: 1078125</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl SGI alloc: 921875</span><br><span class="line"></span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with STL alloctor: 1140625</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl alloctor: 1109375</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl SGI alloc: 921875</span><br><span class="line"></span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with STL alloctor: 1187500</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl alloctor: 1359375</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl SGI alloc: 1140625</span><br></pre></td></tr></table></figure>

<p>可以看到，在以上的测试用例中，本篇文章中实现的<code>alloc</code>分配器性能不仅比上篇文章中的<code>allocator</code>强，甚至比STL默认的分配器表现得还要好。这其实也很正常，毕竟人家STL默认的分配器需要考虑各种情况下的性能，其覆盖的测试用例和测试场景海了去了，平均性能必然是没法比的，毕竟我们参照的是20年前的代码了。。。</p>
<p>关于分配器的实现，已经告一段落，接下来将开始准备重头戏容器的实现。</p>
]]></content>
  </entry>
  <entry>
    <title>TinySTL实现项目（二）：空间分配器allocator与全局construct、destroy</title>
    <url>/2020/01/02/STL2-AlloctorAndCtorDtor/</url>
    <content><![CDATA[<p>本篇文章是TinySTL实现的系列文章的第二篇，介绍了<code>allocator</code>模板类的作用和实现，以及其使用到的全局<code>construct</code>、<code>destroy</code>函数的实现。相关代码依然可以在<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">我的github</a>。</p>
<h2 id="1-allocator-的作用"><a href="#1-allocator-的作用" class="headerlink" title="1 allocator 的作用"></a>1 allocator 的作用</h2><p>关于为什么要有<code>allocator</code>类知乎上有专门的讨论，这里简单总结一下<code>allocator</code>的作用。</p>
<p>在C++中常用的内存配置和释放操作一般会使用<code>new</code>和<code>delete</code>，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> ... &#125;;</span><br><span class="line">Foo* ptr = <span class="keyword">new</span> Foo;	<span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> ptr;		    <span class="comment">// 调用对象的析构函数将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure>

<p>如同注释所说，<code>new</code>其实包含了两步操作：</p>
<ul>
<li>调用<code>::operator new</code>配置内存</li>
<li>调用类构造函数<code>Foo:Foo()</code>来构造对象</li>
</ul>
<p><code>delete</code>也包含了两步操作：</p>
<ul>
<li>调用类析构函数<code>Foo:~Foo()</code>将对象析构</li>
<li>调用<code>::operator delete</code>来释放对象所占的内存</li>
</ul>
<p>这里简单解释一下什么是<code>::perator new</code>和<code>::operator delete</code>：</p>
<div class="note info"><p>上文的<code>new</code>也被称为<code>new operator</code>，如上所述包含了分配内存、构造对象两步操作，不能被重载；</p><p>而<code>::operator new</code>接受一个类型为<code>size_t</code>的参数作为要求的空间大小，<strong>只分配所要求的空间</strong>，而不调用相关对象的构造函数。可以被重载。</p><p><code>::operator delete</code>类似，一般接受一个指针类型的参数，<strong>只释放指针所占的内存</strong>，可以被重载。</p></div>

<p>在STL里面<code>allocator</code>的作用就是将以上<code>new</code>和<code>delete</code>的两步操作区分开来，用<code>allocator::allocate()</code>来分配内存，用<code>::construct()</code>来构造对象，用<code>allocator::deallocate()</code>释放内存，用<code>::destroy()</code>来析构对象。主要用在为各种容器如<code>vector</code>、<code>list</code>分配空间完成构造。</p>
<p>这样的好处就是，有时已经有现成的内存空间可以用了，这时我想构造对象的时候就直接用<code>construct()</code>，而无需花费时间去寻找新的一块内存，然后再分配内存，最后才能构造对象。</p>
<div class="note danger"><p>C++中内存管理十分重要，要建立好概念，分配内存对应释放内存，构造对应析构。例如<code>malloc()</code>对应<code>free()</code>，<code>construct</code>对应<code>destroy</code>，<code>new</code>对应<code>delete</code>。</p></div>

<h2 id="2-简单的allocator类实现"><a href="#2-简单的allocator类实现" class="headerlink" title="2 简单的allocator类实现"></a>2 简单的allocator类实现</h2><p>在STL标准中，要求了<code>allocator</code>具有以下接口</p>
<figure class="highlight c++"><figcaption><span>allocator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类型别名定义</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer     = <span class="keyword">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference   = <span class="keyword">const</span> T&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type         = <span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类接口，使用静态函数实现可以使频繁调用下减小开销</span></span><br><span class="line">    <span class="comment">// 负责分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> T*	<span class="title">allocate</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T*	<span class="title">allocate</span><span class="params">(size_type n)</span></span>;</span><br><span class="line">	<span class="comment">// 负责释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T*, size_type n)</span></span>;</span><br><span class="line">	<span class="comment">// 负责构造对象</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, T&amp;&amp; value)</span></span>;</span><br><span class="line">	<span class="comment">// 负责析构对象</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* first, T* last)</span></span>;</span><br><span class="line">	<span class="comment">// 获取某对象的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T*       <span class="title">address</span><span class="params">(T&amp; val)</span></span>;</span><br><span class="line">    <span class="comment">// 获取可配置T类型对象的最大数目</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t   <span class="title">max_size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 使T类型的alloctor可以为U类型的对象分配内存</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">        <span class="keyword">using</span> other = allocator&lt;U&gt;;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，<code>allocator</code>类主要分为类型别名定义的接口和“干活”接口。</p>
<p>其中类型别名定义部分在STL模板类的实现里非常常见，包括后续的各种迭代器和容器如<code>vector</code>、<code>list</code>等内部都有各种别名定义，且接口基本统一。其作用类似<a href="https://choubin.site/2020/01/01/STL1-TraitsAndType-traitsTemplate/" target="_blank" rel="noopener">本系列上篇</a>所说<code>traits</code>技巧，可以通过这些统一的内嵌别名定义，从模板类或其对象里直接取得所需类型，方便函数的实现和使用。后续在迭代器和容器设计的部分将会看到。</p>
<p>而“干活”的接口主要就是负责分配内存、释放内存、构造/析构对象，显然如第一节所说，我们可以使用<code>::operator new</code>、<code>::operator delete</code>、对象的构造/析构函数来实现这些功能。</p>
<p>注意这些干活的接口都是以类中的<strong>静态成员函数</strong>实现的，为什么要用静态函数？<strong>依然是为了效率</strong>。 </p>
<div class="note info"><p>普通的成员函数一般都隐含一个<code>this</code>指针，静态成员函数由于不与任何对象相联系，故而不具有<code>this</code>指针。</p><p>正是由于没有<code>this</code>指针的额外开销，因此静态成员函数与类的普通成员函数相比<strong>速度会有少许提升</strong>。同时调用静态成员函数时既可以通过类的对象、指向类对象的指针来调用，也<strong>可以直接使用类名来调用</strong>，这样就节省了创建对象的开销。</p><p>也正是因为以上原因，静态成员之间可以相互访问，但不能访问非静态成员函数和非静态数据成员</p></div>

<p>部分实现如下</p>
<figure class="highlight c++"><figcaption><span>allocator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用::operator new实现，分配内存并返回空指针</span></span><br><span class="line"><span class="comment">// 使用static_cast将返回的void指针转换为目标类型的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* allocator&lt;T&gt;::allocate(size_type n) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(n * <span class="keyword">sizeof</span>(T)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用::operator delete释放指针指向内存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::deallocate(T* ptr) &#123;</span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责构造对象，对全局函数construct()的调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::construct(T* ptr) &#123;</span><br><span class="line">	mystl::construct(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::construct(T* ptr, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">	mystl::construct(ptr, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::construct(T* ptr, T&amp;&amp; value) &#123;</span><br><span class="line">	mystl::construct(ptr, mystl::<span class="built_in">move</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责析构对象，对全局函数destroy()的调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::destroy(T* ptr) &#123;</span><br><span class="line">	mystl::destroy(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::destroy(T* first, T* last) &#123;</span><br><span class="line">	mystl::destroy(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>allocate()</code>的实现上，用了<code>static_cast</code>静态转换，这是因为<code>::operator new</code>返回的是<code>void*</code>类型，需要做一个强制类型转换来确保类型安全。</p>
<div class="note info"><ul><li><p>编译器隐式执行的任何类型转换都可以由<code>static_cast</code>来完成，比如<code>int</code>与<code>float</code>、<code>double</code>与<code>char</code>、<code>enum</code>与<code>int</code>之间的转换等</p></li><li><p>使用<code>static_cast</code>可以找回存放在<code>void*</code>指针中的值</p></li><li><p><code>static_cast</code>可以把任何类型的表达式转换成<code>void</code>类型</p></li><li><p><code>static_cast</code>把任何类型的表达式转换成<code>void</code>类型</p></li><li><p>与<code>const_cast</code>相比，<code>static_cast</code>不能改变变量的<code>const</code>属性，也包括<code>volitale</code>或<code>__unaligned</code>属性</p></li></ul></div>

<p>以上实现都在 TinySTL 项目的头文件 <code>allocator.h</code>中。</p>
<p>那么<code>allocator&lt;T&gt;::construct()</code>和<code>allocator&lt;T&gt;::destroy()</code>分别调用的全局<code>construct()</code>和<code>destroy()</code>函数又是什么呢？见下一小节介绍。</p>
<h2 id="3-全局construct-和destroy"><a href="#3-全局construct-和destroy" class="headerlink" title="3 全局construct()和destroy()"></a>3 全局<code>construct()</code>和<code>destroy()</code></h2><p>顾名思义，全局<code>construct()</code>的作用就是构造对象。在上一节中，我们知道分配内存的操作已经由<code>allocator&lt;T&gt;::allocate()</code>完成了，而这个<code>construct()</code>，就是将一个初值设定到已经分配好的的空间上去。因此其需要两个参数，一个是指针来表示内存的位置，另一个是我们希望设定的初值。其中一个实现版本如下：</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了两个模板参数，并使用类型转换</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T1* ptr, <span class="keyword">const</span> T2&amp; value)</span> </span>&#123; <span class="keyword">new</span>(ptr) T1(value); &#125; <span class="comment">// placement new</span></span><br></pre></td></tr></table></figure>

<p>这里用两个模板参数的好处是可以使得函数在使用上更具“通用性”，同时使用了强制类型转换，使得不会产生隐式转换的警告。</p>
<div class="note danger"><p>这里的<code>new</code>不同于第一节中提到的<code>new operator</code>和<code>operator new</code>，而是所谓的<code>placement new</code>。其实<code>placement new</code>只是<code>operator new</code>的一个重载版本。它并不分配内存，返回值是指向已分配好内存的指针。其作用就是在已分配的内存中创建一个对象，这是<code>new</code>做不到的。</p><p><code>placement new</code>的作用是构造对象，故而对应了析构。其对象在使用结束后要记得析构。</p></div>

<p>上文已经强调了构造对应了析构，显然<code>destroy()</code>的作用就是将对象析构了，那么其实现就可以非常简单，只需调用对象的析构函数即可。</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个参数的全局 destroy 函数，直接调用对象的析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span> </span>&#123; ptr -&gt;~T(); &#125;</span><br></pre></td></tr></table></figure>

<p>另外<code>destroy()</code>还有两个参数的重载版本，其接受两个迭代器，表示将一个范围内的对象析构。</p>
<p>而在本系列的<a href="https://choubin.site/2020/01/01/STL1-TraitsAndType-traitsTemplate/" target="_blank" rel="noopener">上篇文章</a>中已经介绍了POD类型，并提到了<code>trivial destructor</code>的概念。在对大范围的对象析构的时候，如果我们事先得知该对象的类型具有<code>trivial destructor</code>，即所谓的“平凡”或者说无意义的析构函数，那么我们就没有必要浪费开销来挨个调用这些无关痛痒的析构函数。</p>
<p>为什么说无关痛痒？因为并不涉及外部内存，对象本身的内存可以继续复用，所以<strong>不调用也不会影响之后的内存释放而造成内存泄露</strong>。只有在对象类型具有<code>non-trivial destructor</code>的时候，才有必要一次次调用其析构函数。</p>
<p>总之，如果得知对象类型具有<code>trivial destructor</code>，那么我们的<code>destroy()</code>函数可以什么也不做，无需付出复杂度为O(n)的多余开销，大大地提升了程序效率。所以我们需要针对这点对<code>destroy()</code>进行优化。代码如下</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// destroy()内部调用的函数，根据对象类型是否有trivial destructor进行重载</span></span><br><span class="line"><span class="comment">// aux 为 auxiliary 缩写，表示其是辅助的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy_aux</span><span class="params">(ForwardIterator first, ForwardIterator last, _true_type)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy_aux</span><span class="params">(ForwardIterator first, ForwardIterator last, _false_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; first != last; ++first)</span><br><span class="line">        destroy(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数的全局 destroy 函数，根据其是否具有 trivial 析构函数进行重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// value_type()函数可以取得迭代器指向对象的类型，注意此时还未实现</span></span><br><span class="line">    <span class="keyword">using</span> is_trivial_dtor =<span class="keyword">typename</span> type_traits&lt;value_type(first)&gt;::has_trivial_destructor;</span><br><span class="line">    destroy_aux(first, last, is_trivial_dtor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>destroy()</code>函数在接受到两个迭代器以后，先用<code>value_type()</code>函数取得迭代器所指向对象的类型，然后将类型放入<code>type_traits</code>模板中，调用其内嵌的类型别名定义，创建一个类型为<code>_true_type</code>或者<code>_false_true</code>的对象作为第三个参数，来调用辅助函数<code>destroy_aux</code>，以此判断迭代器指向的对象是否拥有<code>trivial destructor</code>。</p>
<p>可以看到以上函数内部并不复杂，实际上是只需要一两条语句就可以完成的“小操作”，将这些小操作写成函数的好处有很多，比如方便阅读、修改、重用、统一行为。但调用函数会比使用等价的表达式慢很多：大多数时候，调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。</p>
<p>为了避免调用函数带来的开销，我们可以使用<code>inline</code>关键字将函数变为内联函数，内联函数会在程序的调用点上“内联地”展开；并且函数被内联后，编译器可以通过上下文相关的优化的技术对结果代码执行更深入的优化。最终达到提升效率的目的。</p>
<p>下面对<code>inline</code>关键字做一个简单记录。</p>
<div class="note info"><ul><li><p>关键字<code>inline</code>必须<strong>与函数定义体放在一起</strong>才能内联。</p></li><li><p>内联函数<strong>最好放入头文件</strong>，否则需要在每个调用的源文件中重复地定义。</p></li><li><p>内联函数省去了函数调用的开销，包括参数压栈、跳转、退栈和返回等操作。</p></li><li><p>内联函数以代码膨胀（拷贝）为代价，在过大函数上滥用会导致总代码量增大，消耗更多内存，Google C++规范中建议<strong>函数少于10行</strong>时才定义为内联函数。</p></li><li><p>若函数内部代码的执行时间远比函数调用开销大，则<code>inline</code>的效率收益很低，如出现<strong>循环或其他复杂的控制结构</strong>，此时不宜使用。</p></li><li><p>类的构造/析构函数可能包含隐藏行为，如调用基类或成员对象的构造/析构函数，不应轻易内联。</p></li><li><p>实际的实现中，<code>inline</code>是对编译器的请求，优秀的编译器可以根据函数定义取消不值得的内联，也有可能自动内联一些简单函数。</p></li><li><p>根据上条，<strong><code>inline</code>不应出现在函数声明中</strong>（不是不能）。</p></li></ul></div>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>我们这里已经写好了<code>allocator</code>类，那么如何使用它呢？</p>
<p>这里可以做一个简单的小测试，来测试我们写的<code>allocator</code>能否用于现有的<code>std::vector</code>，验证其有效性。</p>
<p>如果目前并未实现<code>iterator_traits</code>模板类和<code>value_type</code>，测试之前还需要对<code>construct.h</code>文件中的<code>destroy()</code>做一点小修改。</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于暂未实现 mystl::iterator_traits，故而使用 std 中已有接口</span></span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::value_type;</span><br><span class="line">    <span class="keyword">using</span> is_trivial_dtor = <span class="keyword">typename</span> type_traits&lt;value_type&gt;::has_trivial_destructor;</span><br><span class="line">    destroy_aux(first, last, is_trivial_dtor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后新建一个<code>test.cpp</code>输入以下代码：</p>
<figure class="highlight c++"><figcaption><span>test.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"allocator.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_traits.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,mystl::allocator&lt;<span class="keyword">int</span>&gt;&gt; vec(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;each: vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; each &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>g++ (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0</code>环境下执行后，可以看到输出为是5个5，这说明我们写的<code>allocator</code>是可以兼容当前编译环境中实现的的<code>std::vector</code>。但在vs2017中编译未通过，应该是与其内部的内存管理尚有冲突，不过这也没关系，可以在后续使用我们自己实现的<code>vector</code>进行测试。</p>
<h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5 结束语"></a>5 结束语</h2><p>本方案实现的<code>allocator</code>类是比较简单的，从实现上也可以看出其仅仅是对<code>operator new</code>、<code>operator delete</code>、<code>placement new</code>的封装。并不是具有SGI STL特色，使用更底层的<code>malloc</code>、<code>free</code>以及内存池机制的两级空间分配器，后续将会对此进行实现，并使用同一种容器来比较两者效率。本节代码已上传，<a href="https://github.com/Lammmmmmm/TinySTL/blob/master/allocator.h" target="_blank" rel="noopener">allocator.h</a>，<a href="https://github.com/Lammmmmmm/TinySTL/blob/master/construct.h" target="_blank" rel="noopener">construct.h</a>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL实现项目（一）：traits 技巧与 type_traits 模板</title>
    <url>/2020/01/01/STL1-TraitsAndType-traitsTemplate/</url>
    <content><![CDATA[<p>本篇文章是 TinySTL 实现的系列文章的第一篇。撰写初衷是为了对学习《STL 源码剖析》一书所做的总结回顾，并记录一些思考，顺便也作为我参照SGI STL源码实现的一个 TinySTL 项目的介绍文档，相关代码会陆续上传到<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">我的github</a>。</p>
<h2 id="1-traits-编程技法"><a href="#1-traits-编程技法" class="headerlink" title="1 traits 编程技法"></a>1 traits 编程技法</h2><p>traits 编程技法是C++泛型编程中常用技巧，这里先简单地概括一下其作用和目的。</p>
<ul>
<li>作用：通过函数模板来对具体对象或变量进行推导以<strong>获取其类型</strong>或<strong>某种特性</strong>。</li>
<li>目的1：针对获得的类型和某种特性来对<strong>实现函数进行优化以达到更高的性能</strong>。</li>
<li>目的2：通过提取出的类型<strong>作为模板函数的返回类型</strong>，方便函数实现。</li>
</ul>
<p>关于目的1，这里可以举一个迭代器的例子。例如 STL 中的迭代器型别有五种类型</p>
<div class="note info"><ul><li>Input iterator，能读不能写，只支持自增运算。也就是只能用<code>iter++</code>或<code>++iter</code>来一步步前进而不能后退。</li><li>Output iterator ，能写不能读，只支持自增运算</li><li>Forward iterator ，能读能写，只支持自增运算</li><li>Bidirectional iterator ，能读能写，支持自增和自减运算。可以<code>iter++</code>、<code>++iter</code>，也可以<code>iter--</code>、<code>--iter</code>，但依然每次只能前进后退一步。</li><li>Random access iterator ，能读能写，能自增自减还能进行运算，如可以用<code>iter+=5</code>，<code>iter-=5</code>来前进或后退5步。</li></ul></div>

<p>比如我有个迭代器<code>iter</code>，现在有个操作要求<code>iter</code>前进<code>n</code>步来读写数据。</p>
<p>因为事先不知道迭代器的类型，我只能保守地猜测其只能自增自减，这样<span class="label danger">复杂度就是O(n)</span>，但如果我运用<code>traits</code>技巧使用模板<code>iterator_traits&lt;iter&gt;::category</code>（后续会介绍，现在只需要知道其可以获得迭代器类型即可）来获得迭代器类型知道了其是<code>Randon access iterator</code>，那么直接<code>iter += n</code>即可，<span class="label danger">此时复杂度就是O(1)</span>。</p>
<p>对于目的2，这里也简单说一下。因为在C++11之前并没有<code>decltype</code>关键字，所以在编写模板函数的时候，函数返回类型是不能通过模板参数推导的，这时就可以使用<code>traits</code>技巧来获得类型作为模板函数的返回类型。</p>
<p>比如现在有个模板函数需要接受一个函数迭代器，然后返回其指向的值，那么模板参数是迭代器，函数的返回类型却是其指向值的类型。显然没办法通过模板参数推导来得到迭代器的指向值类型，这时就可以对迭代器使用<code>traits</code>技巧来提取其指向值类型作为函数的返回类型。</p>
<p>如果对迭代器类型不太熟悉还不太懂那也没关系，后续文章还会详细介绍，先接着往下看。</p>
<h2 id="2-POD类型"><a href="#2-POD类型" class="headerlink" title="2 POD类型"></a>2 POD类型</h2><p>要说<code>type_traits</code>模板就必须先说<code>POD</code>类型。</p>
<p>POD 是 Plain Old Data 的缩写，是 C++ 定义的一类数据结构概念，比如 <code>int</code>、<code>float</code> 等都是 POD 类型的。Plain 代表它是一个普通类型，Old 代表它是旧的，与 C 语言兼容，那么就可以使用 <code>memcpy()</code> 这种最原始的函数进行操作。两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有 POD 特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变。</p>
<p><strong>也就是说，能用 C 的 memcpy() 等函数进行操作的类型就是 POD 类型的数据</strong>。 </p>
<p>在C++的各标准中对POD类型的有详细定义，从使用中可以概括为<strong>标量类型</strong>和<strong>POD类</strong>。</p>
<ul>
<li>标量类型：整型(<code>char</code>、<code>int</code>等等)，浮点型(<code>double</code>、<code>float</code>等等)，枚举类型，指针类型，指向成员指针类型，<code>std::nullptr_t</code>类型。</li>
<li>POD类：包括满足 trivial 条件和 standard-layout 条件的<code>struct</code>、<code>class</code>、<code>union</code>。<ul>
<li><strong>只有默认</strong>的构造/析构函数、拷贝/移动函数、拷贝/移动运算符。</li>
<li>不能有<strong>虚函数</strong>和<strong>虚基类</strong>。</li>
<li><strong>普通成员有相同的访问级别</strong>，如类成员都为<code>public</code>或都为<code>private</code>或都为<code>protected</code>。</li>
<li>第一个成员为自身的数据成员，而不能是由父类定义的数据。</li>
<li>只要有父类，<strong>普通成员只能在其中一个类中</strong>，不可分散。</li>
</ul>
</li>
</ul>
<p>可以使用<code>std::is_pod&lt;classname&gt;::value</code>的值来判断一个类是否为POD类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//满足POD类型条件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// A2继承了A1但父类子类同时有成员且A2的第一个成员为A1类型，故而不是pod类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span><span class="keyword">public</span> A1&#123;</span><br><span class="line">    A1 num1;</span><br><span class="line">    <span class="keyword">double</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A1 a1;</span><br><span class="line">    A2 a2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_pod&lt;A1&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_pod&lt;A2&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么知道了一个对象或变量是不是POD类型有什么用呢？答案是以此<strong>提高程序运行效率</strong>。</p>
<p>假如事先知道了某函数的操作对象是POD类型，那么我们就可以针对其特性，使用底层的<code>memcpy()</code>、<code>memove()</code>等C函数对其操作，而不需要调用类似<code>constructor</code>，<code>destructor</code>等函数。这在大规模而操作频繁的程序中有显著的效率提升。</p>
<h2 id="3-type-traits-模板"><a href="#3-type-traits-模板" class="headerlink" title="3 type_traits 模板"></a>3 type_traits 模板</h2><p><code>type_traits</code>在SGT STL 2.91版本中命名为<code>__type_traits</code>，因为当时并未加入STL标准，属于SGI的“私房菜”，故而命名前有两个下划线，这里为了方便描述就去掉了开头的下划线。</p>
<p>从前文已经得知<code>traits</code>编程技巧的作用是为了<strong>取得对象或变量的某种特性</strong>，而目的则是为了根据<strong>特性作出相应优化而提升效率</strong>。而这里的<code>type_traits</code>模板所能取得特性就是是否具有所谓“平凡”（<code>trivial</code>）的默认构造函数、拷贝构造函数、赋值运算符、析构函数，以及是否是POD类型。如果具有上述的性质，那么在进行相应的构造、拷贝、赋值、析构的时候就可以使用<code>malloc()</code>、<code>memcpy()</code>这些C函数直接对内存进行操作，以获得更高的效率。</p>
<p>那么如何表示其是否具有上述性质呢？用<code>true</code>和<code>false</code>这样的布尔值？当然可以，但这样的话，在使用的时候，就不方便根据不同特性来对实际函数进行重载了，因为都是<code>bool</code>类型嘛。</p>
<p>根据SGI STL的方案，我们可以使用两个不含有任何成员的类来区分：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">true_type</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">false_type</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>不含有任何成员，就意味着开销最低。</p>
<p>然后使用实现基本的<code>type_traits</code>模板：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = _false_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = _false_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个模板里我们先将所有性质都设为<code>false_type</code>，也就是说给所有使用该模板的类型一个最保守的值，接着使用<strong>模板特化</strong>的方法，为已知为<code>true_type</code>的类型提供特化版本。例如：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对各种算术整型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span>&lt;bool&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = _true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = _true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = _true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = _true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>指针类型当然也具有上述性质，但是对于指针就没必要一个个特化了，只需要使用<strong>偏特化</strong>就可以覆盖各种类型的指针了：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对指针的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span>&lt;type*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = true_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-一点小扩展–is-const的实现"><a href="#4-一点小扩展–is-const的实现" class="headerlink" title="4 一点小扩展–is_const的实现"></a>4 一点小扩展–<code>is_const</code>的实现</h2><p>C++11的标准中加入了<code>decltype</code>关键字，使得许多原本需要使用<code>traits</code>技巧来取得对象类型的地方可以直接使用<code>decltype()</code>，避免了各种弯弯绕绕。比如在第一节迭代器的例子里。</p>
<p>但<code>traits</code>技巧依然在许多地方很有用，事实上即使是最新的各版本STL实现，依然有着广泛使用。比如我们可以使用类似技巧来实现<code>is_const</code>，其作用是判断一个类型是否是<code>const</code>的。实现如下</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个辅助实现 true_type 和 false_type 的类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T v&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intergral_constant</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> type       = intergral_constant&lt;T, v&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = intergral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = intergral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受普通类型时继承 false_type ,此时其静态成员 value 为 false</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_const</span>:</span> <span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化使得接受 const 类型时继承 true_type，此时其静态成员 value 为 true</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_const</span>&lt;const T&gt;:</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-附录"><a href="#5-附录" class="headerlink" title="5 附录"></a>5 附录</h2><p>本部分代码已上传到 github，<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">代码链接在这里</a>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>STL</tag>
        <tag>C++</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 个人博客基于 NexT 主题的基本配置和定制优化</title>
    <url>/2019/12/30/CustomBlogTheme/</url>
    <content><![CDATA[<p>本网站的主题修改主要参照<a href="http://yearito.cn/" target="_blank" rel="noopener">这位大佬的博客</a>，但其边缘波动的部分配置是无效的，下文有详细介绍。</p>
<h2 id="1-站点基本优化"><a href="#1-站点基本优化" class="headerlink" title="1 站点基本优化"></a>1 站点基本优化</h2><h3 id="1-1-基本信息配置"><a href="#1-1-基本信息配置" class="headerlink" title="1.1 基本信息配置"></a>1.1 基本信息配置</h3><p>NexT主题默认风格为<code>Muse</code>，可以在<strong>主题目录的配置文件</strong><code>_config.yml</code>，注意这不是根目录下网站的配置文件</p>
<figure class="highlight yaml"><figcaption><span>theme/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p>而根目录下的<code>_config.yml</code>文件负责站点的相关配置包括了网站标题、网站描述、网站语言等</p>
<figure class="highlight yaml"><figcaption><span>./_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Chou</span> <span class="string">Bin's</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'慢就是快，快就是慢'</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Chou</span> <span class="string">Bin</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-生成标签、分类、归档页面"><a href="#1-2-生成标签、分类、归档页面" class="headerlink" title="1.2 生成标签、分类、归档页面"></a>1.2 生成标签、分类、归档页面</h3><p>主题首页的默认页面中是没有标签、分类、归档页面的，需要手动生成一下。先在博客根目录下打开<code>git-bash</code>或终端，然后键入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags &amp;&amp; hexo new page categories &amp;&amp; hexo new page archives</span><br></pre></td></tr></table></figure>

<p>然后打开新增的<code>source/tags/index.md</code>，修改如下</p>
<figure class="highlight diff"><figcaption><span>source\tags\index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: 标签</span><br><span class="line">  date: 2018-10-19 22:57:00</span><br><span class="line"><span class="addition">+ type: tags</span></span><br></pre></td></tr></table></figure>

<p>同理再修改另外两个新增文件夹下的<code>index.md</code>。</p>
<p>最后修改主题配置文件的<code>menu</code>字段</p>
<figure class="highlight diff"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line"><span class="addition">+ tags: /tags/ || tags</span></span><br><span class="line"><span class="addition">+ categories: /categories/ || th</span></span><br><span class="line"><span class="addition">+ archives: /archives/ || archive</span></span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%A2%9E%E5%8A%A0%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E5%BD%92%E6%A1%A3.png" alt="增加标签"></p>
<h3 id="1-3-首页显示文章摘要"><a href="#1-3-首页显示文章摘要" class="headerlink" title="1.3 首页显示文章摘要"></a>1.3 首页显示文章摘要</h3><p>默认的主题配置里，首页会显示每一篇文章的全文，如果想只显示文章摘要，对主题配置文件做如下更改</p>
<figure class="highlight yaml"><figcaption><span>theme/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 开启自动摘要提取</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>此时文中的前150个字符将作为摘要。</p>
<p>用户可以在文章中通过<code>&lt;!-- more --&gt;</code>标记来精确划分摘要信息，标记之前的段落将作为摘要显示在首页。</p>
<p>如果在文章的 Front-Matter 中有非空的 <code>description</code> 字段，则该字段的内容会被作为摘要显示在首页。</p>
<h3 id="1-4-修改站点页脚"><a href="#1-4-修改站点页脚" class="headerlink" title="1.4 修改站点页脚"></a>1.4 修改站点页脚</h3><p>在主题配置文件中修改网站页脚信息</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span>  <span class="comment"># 底部信息区</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>  <span class="comment"># 建站时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span>   <span class="comment"># 图标名称</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>   <span class="comment"># 开启动画</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#ff0000"</span>   <span class="comment"># 图标颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 隐藏由 Hexo 强力驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏 Hexo 版本号</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 隐藏所用的主题名称</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏主题版本号</span></span><br></pre></td></tr></table></figure>

<p>更改后效果如本站底部，但字数统计和访问统计等在后续配置中。</p>
<h3 id="1-5-修改网站-Favicon"><a href="#1-5-修改网站-Favicon" class="headerlink" title="1.5 修改网站 Favicon"></a>1.5 修改网站 Favicon</h3><p> Favicon 即浏览器标签左侧的图标。下载自己喜欢的图标置于 <code>themes\next\source\images\</code> 目录下，命名方式参考主题配置文件中的 <code>favicon</code> 字段。 这里介绍一个<a href="https://tool.lu/favicon/" target="_blank" rel="noopener">在线制作 <code>favicon</code>的网站</a>，可以上传喜欢的图片制作成<code>favicon</code>。</p>
<figure class="highlight yaml"><figcaption><span>theme\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span>  <span class="comment"># 大图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span>  <span class="comment"># 苹果图标</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span>  <span class="comment"># safari浏览器标签页图标</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-添加友情链接"><a href="#1-6-添加友情链接" class="headerlink" title="1.6 添加友情链接"></a>1.6 添加友情链接</h3><p>在主题配置文件中修改相应的字段，可以加入一些朋友的网站。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">友情链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">yearito:</span> <span class="string">http://choubin.site</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-添加社交链接"><a href="#1-7-添加社交链接" class="headerlink" title="1.7 添加社交链接"></a>1.7 添加社交链接</h3><p>默认可选选项中，国内能用的基本只有github，邮箱，微博，当然其他只要有账号就可以放上去。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="attr">Weibo:</span> <span class="string">https://weibo.com/yourname</span> <span class="string">||</span> <span class="string">weibo</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">twitter</span></span><br><span class="line">  <span class="attr">FB Page:</span> <span class="string">https://www.facebook.com/yourname</span> <span class="string">||</span> <span class="string">facebook</span></span><br><span class="line">  <span class="attr">VK Group:</span> <span class="string">https://vk.com/yourname</span> <span class="string">||</span> <span class="string">vk</span></span><br><span class="line">  <span class="attr">StackOverflow:</span> <span class="string">https://stackoverflow.com/yourname</span> <span class="string">||</span> <span class="string">stack-overflow</span></span><br><span class="line">  <span class="attr">YouTube:</span> <span class="string">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/yourname</span> <span class="string">||</span> <span class="string">instagram</span></span><br><span class="line">  <span class="attr">Skype:</span> <span class="string">skype:yourname?call|chat</span> <span class="string">||</span> <span class="string">skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示社交软件图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span>  <span class="comment"># 显示图标的同时显示文字</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-添加版权协议"><a href="#1-8-添加版权协议" class="headerlink" title="1.8 添加版权协议"></a>1.8 添加版权协议</h3><p>先在主题配置文件中开启相关字段</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span> <span class="string">by-nc-sa</span></span><br></pre></td></tr></table></figure>

<h2 id="2-网站逻辑优化"><a href="#2-网站逻辑优化" class="headerlink" title="2 网站逻辑优化"></a>2 网站逻辑优化</h2><h3 id="2-1-点击头像回到首页"><a href="#2-1-点击头像回到首页" class="headerlink" title="2.1 点击头像回到首页"></a>2.1 点击头像回到首页</h3><p>修改侧边栏模板代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.avatar.url %&#125;</span><br><span class="line"><span class="addition">+   &lt;a href="/"&gt;</span></span><br><span class="line">      &lt;img class="site-author-image" itemprop="image"</span><br><span class="line">        src="&#123;&#123; url_for( theme.avatar.url | default(theme.images + '/avatar.gif') ) &#125;&#125;"</span><br><span class="line">        alt="&#123;&#123; author &#125;&#125;" /&gt;</span><br><span class="line"><span class="addition">+   &lt;/a&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-文章页优化"><a href="#2-2-文章页优化" class="headerlink" title="2.2 文章页优化"></a>2.2 文章页优化</h3><p><strong>取消文章目录中的数字编号</strong>，因为一般我写markdown文档的时候都是自己为章节编号，所以需要取消主题中的文章目录的数字编号，否则就会有两个数字很别扭。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>  <span class="comment"># 关闭目录中的数字编号</span></span><br></pre></td></tr></table></figure>

<p>默认情况下文章的多级目录会被折叠，需要点击才能触发下级菜单的展开，并且同时只能展开一个目录分支，这会造成看文章点击目录很不方便，所以本站点<strong>设置了展开全部目录层级</strong>，这里需要<strong>新建</strong>一个自定义样式文件<code>themes\next\source\css\_custom\custom.styl</code>，然后添加以下代码。</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//TOC目录默认全部展开</span></span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里是第一次新建自定义样式文件，还需要做如下修改，在 themes\next\layout\_layout.swig  文件中引入刚才新建的文件</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>另外如果文章不长，就没必要展示目录了，否则侧边文章目录栏空荡荡的也有点别扭。这里需要修改侧边栏的布局模板相关逻辑代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% set display_toc = is_post and theme.toc.enable %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% set display_toc = is_post and theme.toc.enable and not page.hide_toc %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-修改文章-meta-信息"><a href="#2-3-修改文章-meta-信息" class="headerlink" title="2.3 修改文章 meta 信息"></a>2.3 修改文章 meta 信息</h3><p>默认主题下， 标题下方会显示文章的创建时间、文章的修改时间、文章分类信息等元数据，用户可以在主题配置文件中自定义设置需要显示的 meta 元信息： </p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>  <span class="comment"># 显示文字说明</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>  <span class="comment"># 显示文章创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>  <span class="comment"># 隐藏文章修改时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span>  <span class="comment"># 只有当修改时间和创建时间不是同一天的时候才显示</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">false</span>  <span class="comment"># 隐藏分类信息</span></span><br></pre></td></tr></table></figure>

<h2 id="3-主题定制优化"><a href="#3-主题定制优化" class="headerlink" title="3 主题定制优化"></a>3 主题定制优化</h2><h3 id="3-1-修改博客字体"><a href="#3-1-修改博客字体" class="headerlink" title="3.1 修改博客字体"></a>3.1 修改博客字体</h3><p> 在 <a href="https://www.google.com/fonts" target="_blank" rel="noopener">Google Fonts</a> 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体： </p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-为标签添加图标"><a href="#3-2-为标签添加图标" class="headerlink" title="3.2 为标签添加图标"></a>3.2 为标签添加图标</h3><p> 默认情况下标签前缀是 <code>#</code> 字符，用户可以通过修改主题源码将标签的字符前缀改为图标前缀 </p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &lt;footer class="post-footer"&gt;</span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">      &lt;div class="post-tags"&gt;</span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line"><span class="deletion">-          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="addition">+          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p> Next 中使用 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">FontAwesome</a> 作为图标库，用户可以在 FontAwesome 上找到心仪的图标来替换标签的字符前缀。 </p>
<h3 id="3-3-添加结束标记"><a href="#3-3-添加结束标记" class="headerlink" title="3.3 添加结束标记"></a>3.3 添加结束标记</h3><p>在文末添加结束标记，效果如下：</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0.png" alt="结束标记"></p>
<p> 新建布局模板文件 post-end-tag.swig，添加如下代码： </p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post-end-tag.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &lt;div style="text-align:center;color:#bfbfbf;font-size:16px;"&gt;</span><br><span class="line">      &lt;span&gt;-------- 本文结束 &lt;/span&gt;</span><br><span class="line">      &lt;i class="fa fa-&#123;&#123; config.post_end_tag.icon &#125;&#125;"&gt;&lt;/i&gt;</span><br><span class="line">      &lt;span&gt; 感谢阅读 --------&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在文章布局模板中添加如下代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ &#123;% if config.post_end_tag.enabled and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;div&gt;</span></span><br><span class="line"><span class="addition">+     &#123;% include 'post-end-tag.swig' %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+ &#123;% endif %&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include 'wechat-subscriber.swig' %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在站点配置文件末尾添加如下代码</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 是否开启文末的本文结束标记</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">paw</span> <span class="comment"># 结束标记之间的图标</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-页面加载进度条"><a href="#3-4-页面加载进度条" class="headerlink" title="3.4 页面加载进度条"></a>3.4 页面加载进度条</h3><p>当网络不好的时候可能会在打开站点或跳转文章时出现短暂的白屏，此时如果能有加载进度提示将会提高用户操作体验。</p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace themes/next/<span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中设置 <code>pace: true</code>。</p>
<p>默认提供了多种主题的进度条加载样式，有顶部提示的，有中间提示的，还有全页面遮挡提示的，默认进度条就非常合适。</p>
<h3 id="3-5-侧边栏放左边"><a href="#3-5-侧边栏放左边" class="headerlink" title="3.5 侧边栏放左边"></a>3.5 侧边栏放左边</h3><p> Next 主题的各种主题风格中只有 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧，而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置。 </p>
<p>在上文新建的自定义样式文件中添加如下代码</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-toggle</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改动效脚本代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\source\js\src\motion.js</span></figcaption><table><tr><td class="code"><pre><span class="line">$(document)</span><br><span class="line">  .on('sidebar.isShowing', function() &#123;</span><br><span class="line">    NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(</span><br><span class="line"><span class="deletion">-     &#123;paddingRight: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line"><span class="addition">+     &#123;paddingLeft: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line">      SIDEBAR_DISPLAY_DURATION</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .on('sidebar.isHiding', function() &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  hideSidebar: function() &#123;</span><br><span class="line"><span class="deletion">-   NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingRight: 0&#125;);</span></span><br><span class="line"><span class="addition">+   NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;);</span></span><br><span class="line">    this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none');</span><br><span class="line">    this.sidebarEl.velocity('stop').velocity(&#123;width: 0&#125;, &#123;display: 'none'&#125;);</span><br><span class="line"></span><br><span class="line">    sidebarToggleLines.init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到 991px 之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可： </p>
<figure class="highlight diff"><figcaption><span>themes\next\source\css\_common\scaffolding\base.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  position: relative; // Required by scrollspy</span><br><span class="line">  font-family: $font-family-base;</span><br><span class="line">  font-size: $font-size-base;</span><br><span class="line">  line-height: $line-height-base;</span><br><span class="line">  color: $text-color;</span><br><span class="line">  background: $body-bg-color;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- +mobile() &#123; padding-left: 0 !important; &#125;</span></span><br><span class="line"><span class="deletion">- +tablet() &#123; padding-left: 0 !important; &#125;  </span></span><br><span class="line"><span class="addition">+ +mobile() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line"><span class="addition">+ +tablet() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line">  +desktop-large() &#123; font-size: $font-size-large; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-添加个性特效"><a href="#4-添加个性特效" class="headerlink" title="4 添加个性特效"></a>4 添加个性特效</h2><h3 id="4-1-边缘摆动效果"><a href="#4-1-边缘摆动效果" class="headerlink" title="4.1 边缘摆动效果"></a>4.1 边缘摆动效果</h3><p>个人一直认为，博客是给人阅读的，而添加一些花里胡哨的动态背景，实在有违博客初衷。可是过于朴素又失去了趣味性，故而加入了一个边缘摆动效果，个人觉得还有点小俏皮，效果如下。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/wobblewindow.gif" alt="边缘摆动效果"></p>
<p>但<a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="noopener">上文提到的博客</a>中的教程有点小问题，添加的代码路径出错了，导致无法成功显示特效。个人亲测有用，修正如下。</p>
<p>首先<a href="https://script-1256884783.file.myqcloud.com/wobblewindow.js" target="_blank" rel="noopener">下载脚本</a>，置于  themes\next\source\js\ 目录下 ，然后将以下代码<strong>添加到  themes\next\layout\_layout.swig</strong>，原教程中是添加到 themes\next\layout_custom\custom.swig ，亲测无效。</p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# wobble窗口摆动特效 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.wobble %&#125;</span><br><span class="line">  &lt;script src=<span class="string">"/js/wobblewindow.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">//只在桌面版网页启用特效</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">window</span>.innerWidth &gt; <span class="number">768</span>  )&#123;</span><br><span class="line">      $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#123;% <span class="keyword">if</span> theme.wobble.header %&#125;</span><br><span class="line">          $(<span class="string">'#header'</span>).wobbleWindow(&#123;</span><br><span class="line">            radius: &#123;&#123; theme.wobble.radius &#125;&#125;,</span><br><span class="line">            movementTop: <span class="literal">false</span>,</span><br><span class="line">            movementLeft: <span class="literal">false</span>,</span><br><span class="line">            movementRight: <span class="literal">false</span>,</span><br><span class="line">            debug: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">        &#123;% <span class="keyword">if</span> theme.wobble.sidebar %&#125;</span><br><span class="line">          $(<span class="string">'#sidebar'</span>).wobbleWindow(&#123;</span><br><span class="line">            radius: &#123;&#123; theme.wobble.radius &#125;&#125;,</span><br><span class="line">            movementLeft: <span class="literal">false</span>,</span><br><span class="line">            movementTop: <span class="literal">false</span>,</span><br><span class="line">            movementBottom: <span class="literal">false</span>,</span><br><span class="line">            position: <span class="string">'fixed'</span>,</span><br><span class="line">            debug: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">        &#123;% <span class="keyword">if</span> theme.wobble.footer %&#125;</span><br><span class="line">          $(<span class="string">'#footer'</span>).wobbleWindow(&#123;</span><br><span class="line">            radius: &#123;&#123; theme.wobble.radius &#125;&#125;,</span><br><span class="line">            movementBottom: <span class="literal">false</span>,</span><br><span class="line">            movementLeft: <span class="literal">false</span>,</span><br><span class="line">            movementRight: <span class="literal">false</span>,</span><br><span class="line">            offsetX: &#123;&#123; theme.wobble.offset &#125;&#125;,</span><br><span class="line">            position: <span class="string">'absolute'</span>,</span><br><span class="line">            debug: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后在自定义样式文件中添加一下样式，注意是在<code>themes\next\source\css\_custom\custom.styl</code>文件中添加，这里的代码也与原教程中稍有不同。</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口波动效果相关样式</span></span><br><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">'wobble'</span>)  &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .wobbleTransparentBK&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .wobbleTransparentLine&#123;</span><br><span class="line">    <span class="attribute">border-color</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Next.Muse中为Header和Footer添加背景色</span></span><br><span class="line">  <span class="selector-class">.header</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: rgb(<span class="number">245</span>, <span class="number">245</span>, <span class="number">245</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//防止sidebar和footer同时开启动效时堆叠异常</span></span><br><span class="line">  <span class="selector-class">.sidebar</span>, <span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span> !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//防止挡住页末文章的阅读全文按钮</span></span><br><span class="line">  <span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是因为 Next.Muse 主题方案中 Header 和 Footer 是没有背景色的，所以需要添加背景色后才能看出边缘摆动效果。另外，实现边缘摆动效果所需的 <code>z-index</code> 属性可能会导致元素堆叠异常，需要添加以上样式来矫正。 </p>
<p>最后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># window woblle</span></span><br><span class="line"><span class="attr">wobble:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 是否开启边缘波动效果</span></span><br><span class="line">  <span class="attr">radius:</span> <span class="number">65</span>  <span class="comment"># 波动半径</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>  <span class="comment"># 不开启侧边栏边缘摆动，设为true的话则目录的侧边栏也会摆动</span></span><br><span class="line">  <span class="attr">header:</span> <span class="literal">true</span>  <span class="comment"># 开启头部边缘摆动</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="literal">true</span>  <span class="comment"># 开启脚部边缘摆动</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-使用小猫咪回到顶部"><a href="#4-2-使用小猫咪回到顶部" class="headerlink" title="4.2 使用小猫咪回到顶部"></a>4.2 使用小猫咪回到顶部</h3><p>就像本站一样，使用右侧的小猫咪来回到顶部，还蛮可爱的，建议添加。</p>
<p>原理就是将 <code>back-to-top</code>按钮添加图片背景，然后添加<code>CSS3</code>动效。这里用的图片素材就是一个小猫上吊的图片，<a href="http://yearito.cn/images/scroll.png" target="_blank" rel="noopener">点这里下载</a>，然后放置到 source\images\ 目录下 。</p>
<p>然后在自定义样式文件中添加如下代码</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义回到顶部样式</span></span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;  <span class="comment">//图片素材宽度</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">900px</span>;  <span class="comment">//图片素材高度</span></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">900px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: unset;</span><br><span class="line">  transition: all .5s ease-in-out;</span><br><span class="line">  <span class="attribute">background</span>: url(<span class="string">"/images/scroll.png"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐藏箭头图标</span></span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? calc( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-鼠标点击特效"><a href="#4-3-鼠标点击特效" class="headerlink" title="4.3 鼠标点击特效"></a>4.3 鼠标点击特效</h3><p>鼠标点击特效常用的有礼花特效、爆照特效、浮出特效、浮出文字，礼花特效如下图所示，个人比较中意礼花特效，可以点击下方按钮下载相应脚本 并置于 themes\next\source\js\cursor\ 目录下 </p>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/fireworks.js" target="_blank" rel="noopener">礼花特效</a> <a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/explosion.min.js" target="_blank" rel="noopener">爆炸特效</a> <a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/love.min.js" target="_blank" rel="noopener">浮出爱心</a> <a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/text.js" target="_blank" rel="noopener">浮出文字</a>

<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/cursor-fireworks.gif" alt="礼花特效"></p>
<p>然后在主题自定义布局文件照片那个添加如下代码</p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.cursor_effect == <span class="string">"fireworks"</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/fireworks.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">"explosion"</span> %&#125;</span><br><span class="line">  &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"fireworks"</span> style=<span class="string">"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"</span> &gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"//cdn.bootcss.com/animejs/2.2.0/anime.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/explosion.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">"love"</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/love.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">"text"</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/text.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>若该文件不存在则新建后见步骤2.2。</strong></p>
<p>然后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love | text</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">fireworks</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-打字特效"><a href="#4-4-打字特效" class="headerlink" title="4.4 打字特效"></a>4.4 打字特效</h3><p>这里的特效是为评论输入文字时添加的特效，关于如何添加评论功能见步骤6.4。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/typing-effect.gif" alt="打字特效"></p>
<p><a href="https://script-1256884783.file.myqcloud.com/activate-power-mode.min.js" target="_blank" rel="noopener">点击这里</a> 下载相应脚本，并置于 themes\next\source\js\ 目录下。</p>
<p>然后在主题自定义布局文件中添加以下代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 打字特效 #&#125;</span><br><span class="line">&#123;% if theme.typing_effect %&#125;</span><br><span class="line">  &lt;script src="/js/activate-power-mode.min.js"&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    POWERMODE.colorful = &#123;&#123; theme.typing_effect.colorful &#125;&#125;;</span><br><span class="line">    POWERMODE.shake = &#123;&#123; theme.typing_effect.shake &#125;&#125;;</span><br><span class="line">    document.body.addEventListener('input', POWERMODE);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在则需要新建，然后见步骤2.2。最后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># typing effect</span></span><br><span class="line"><span class="attr">typing_effect:</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span>  <span class="comment"># 礼花特效</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">false</span>  <span class="comment"># 震动特效</span></span><br></pre></td></tr></table></figure>

<h2 id="5-站点数据统计"><a href="#5-站点数据统计" class="headerlink" title="5 站点数据统计"></a>5 站点数据统计</h2><h3 id="5-1-站点访问量统计"><a href="#5-1-站点访问量统计" class="headerlink" title="5.1 站点访问量统计"></a>5.1 站点访问量统计</h3><p>使用<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>来实现， 由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据 PV 和 UV 都会异常的大，属于正常现象。 </p>
<p> 在页脚布局模板文件首行添加如下代码： </p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout_partial\footer.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  <span class="keyword">async</span></span><br><span class="line">  src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件中做如下修改</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span> <span class="comment"># 访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span> <span class="comment"># 访问量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>

<p>可选：自定义统计文案，如本站所示，需要做如下修改</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout_third-party\analytics\busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="deletion">-   &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+   &lt;span class="site-uv"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;&#123; __('footer.total_visitors', '&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;') &#125;&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="deletion">-   &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+   &lt;span class="site-pv"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;&#123; __('footer.total_views', '&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;') &#125;&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式</p>
<figure class="highlight stylus"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改不蒜子数据颜色</span></span><br><span class="line"><span class="selector-class">.busuanzi-value</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改表述文案</p>
<figure class="highlight yaml"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="string">"历经 %s 次回眸才与你相遇"</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="string">"我的第 %s 位朋友，"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-站点运行时间统计"><a href="#5-2-站点运行时间统计" class="headerlink" title="5.2 站点运行时间统计"></a>5.2 站点运行时间统计</h3><p>效果如下：</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E7%AB%99%E7%82%B9%E7%BB%9F%E8%AE%A1%E6%97%B6%E9%97%B4.jpg" alt="站点统计时间"></p>
<p>在自定义布局文件中添加以下代码：</p>
<figure class="highlight javascript"><figcaption><span>thems\next\layout_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 页脚站点运行时间统计 #&#125; &#123;% if theme.footer.ages.enable %&#125;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ages = moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,<span class="string">"YYYYMMDD"</span>));</span><br><span class="line">    ages = ages.replace(<span class="regexp">/years?/</span>, <span class="string">"年"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/months?/</span>, <span class="string">"月"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/days?/</span>, <span class="string">"天"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/hours?/</span>, <span class="string">"小时"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/minutes?/</span>, <span class="string">"分"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/seconds?/</span>, <span class="string">"秒"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/\d+/g</span>, <span class="string">'&lt;span style="color:&#123;&#123; theme.footer.ages.color &#125;&#125;"&gt;$&amp;&lt;/span&gt;'</span>);</span><br><span class="line">    div.innerHTML = <span class="string">`&#123;&#123; __('footer.age')&#125;&#125; <span class="subst">$&#123;ages&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="comment">//插入到copyright之后</span></span><br><span class="line">  <span class="keyword">var</span> copyright = <span class="built_in">document</span>.querySelector(<span class="string">".copyright"</span>);</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">".footer-inner"</span>).insertBefore(div, copyright.nextSibling);</span><br><span class="line">  timer();</span><br><span class="line">  setInterval(<span class="string">"timer()"</span>,<span class="number">1000</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，则手动新建，见步骤2.2。</p>
<p>然后修改主题配置文件</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="attr">footer:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="string">+</span>   <span class="attr">ages:</span></span><br><span class="line"><span class="string">+</span>     <span class="comment"># site running time</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">+</span>     <span class="comment"># birthday of your site</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">birthday:</span> <span class="number">20181001</span></span><br><span class="line"><span class="string">+</span>     <span class="comment"># color of number</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">color:</span> <span class="string">"#1890ff"</span></span><br></pre></td></tr></table></figure>

<p>然后补全对应文案</p>
<figure class="highlight yaml"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="attr">footer:</span></span><br><span class="line">    <span class="attr">powered:</span> <span class="string">"由 %s 强力驱动"</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">主题</span></span><br><span class="line"><span class="string">+</span>   <span class="attr">age:</span> <span class="string">我已在此等候你</span></span><br><span class="line">    <span class="attr">total_views:</span> <span class="string">"历经 %s 次回眸才与你相遇"</span></span><br><span class="line">    <span class="attr">total_visitors:</span> <span class="string">"我的第 %s 位朋友，"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-文章访问量统计"><a href="#5-3-文章访问量统计" class="headerlink" title="5.3 文章访问量统计"></a>5.3 文章访问量统计</h3><p>这里需要借助<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>来提供后端数据服务。</p>
<p> 在 LeanCloud 上注册账号并创建应用，应用名称可以为<code>ForBlog</code>，然后在该应用中，新建一个名为 Counter 的 Class，ACL 权限设置为 <strong>无限制</strong>： </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/LeanCloud-Counter-class.png" alt="LeanCloud"></p>
<div class="note [info]"><p>在 LeanCloud 中的 Class 可以理解为数据库中的数据表。Counter 用于存储记录文章访问量，记录是以 url 作为唯一依据的，所以根据默认的 permalink 组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。 </p></div>

<p> 在控制台的 <strong>设置</strong> -&gt; <strong>应用 Key</strong> 中获取 App ID 和 App Key 填入到主题配置文件中： </p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">***&lt;app_id***</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="string">***&lt;app_key&gt;***</span></span><br><span class="line">  <span class="attr">security:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">betterPerformance:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>站点上线后可以在 <strong>设置</strong> -&gt; <strong>安全中心</strong> 中添加博客域名到 Web 安全域名中，设置后仅可在该域名下通过 JavaScript SDK 调用服务器资源，借以保护 LeanCloud 应用的数据安全。</p>
<p>如果想要自定义 PV 表述文案，可以修改文章布局模板中的相关代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;# LeanCould PageView #&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line"><span class="deletion">-     &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.views') + __('symbol.colon') &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+     &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.views')&#125;&#125; &lt;/span&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt;</span><br><span class="line"><span class="addition">+   &lt;span&gt;℃&lt;/span&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>修改统计表述文案</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">views:</span> <span class="string">热度</span></span><br></pre></td></tr></table></figure>

<p><strong>如遇到报错，在主题配置中设置<code>security: false</code>。</strong></p>
<h3 id="5-4-站点及文章字数统计"><a href="#5-4-站点及文章字数统计" class="headerlink" title="5.4 站点及文章字数统计"></a>5.4 站点及文章字数统计</h3><p>目前由 <a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a> 提供的字数统计功能需要NexT主题的版本在v7.5或更高才能有效，否则会出现站点总字数比文章总字数更少的bug，留待有空的时候再解决吧。</p>
<h2 id="6-部分功能扩展"><a href="#6-部分功能扩展" class="headerlink" title="6 部分功能扩展"></a>6 部分功能扩展</h2><h3 id="6-1-搞怪网页标题"><a href="#6-1-搞怪网页标题" class="headerlink" title="6.1 搞怪网页标题"></a>6.1 搞怪网页标题</h3><p> 离开和进入页面时动态修改 Tab 标签中的标题。 效果如下</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E6%90%9E%E6%80%AA%E7%BD%91%E9%A1%B5%E8%BF%9B%E5%85%A5.jpg" alt="搞怪网页标题"></p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E6%90%9E%E6%80%AA%E7%BD%91%E9%A1%B5%E8%BF%9B%E5%85%A52.jpg" alt="搞怪网页标题2"></p>
<p>在主题自定义布局文件中添加以下代码</p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;# 搞怪网页标题 #&#125; &#123;% if theme.title_trick.enable %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> OriginTitile = <span class="built_in">document</span>.title;</span><br><span class="line">  <span class="keyword">var</span> titleTime;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"&#123;&#123; theme.title_trick.leave &#125;&#125;"</span> + OriginTitile;</span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"&#123;&#123; theme.title_trick.enter &#125;&#125;"</span> + OriginTitile;</span><br><span class="line">      titleTime = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = OriginTitile;</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果首次新建该文件的话，见步骤2.2。</p>
<p>然后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># a trick on website title</span></span><br><span class="line"><span class="attr">title_trick:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">leave:</span> <span class="string">"(つェ⊂)看不见我看不见我"</span></span><br><span class="line">  <span class="attr">enter:</span> <span class="string">"(*´∇｀*) 咦，竟然被你发现了~"</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-添加站内搜索"><a href="#6-2-添加站内搜索" class="headerlink" title="6.2 添加站内搜索"></a>6.2 添加站内搜索</h3><p>该功能由  <a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">hexo-generator-searchdb</a> 提供 ，在根目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在<strong>主题配置</strong>文件中修改相关字段：</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span> <span class="comment"># 每次输入改变都执行搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span> <span class="comment"># 每篇文章显示的搜索结果数量</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>在<strong>站点配置</strong>文件中添加以下字段：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># 指定搜索范围，可选 post | page | all</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span> <span class="comment"># 指定页面内容形式，可选 html | raw (Markdown) | excerpt | more</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式规则来增加搜索弹窗的页边距：</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加搜索弹窗的页边距</span></span><br><span class="line"><span class="selector-class">.local-search-popup</span> <span class="selector-id">#local-search-result</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">40px</span></span><br><span class="line">  <span class="attribute">height</span>: calc(<span class="number">100%</span> - <span class="number">95px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你同时在站点内启用了 wobblewindow 边缘摆动效果，则有可能会出现背景蒙版叠加在弹窗之前的问题，这种层级叠加异常的问题主要是因为 wobblewindow 中修改了弹窗父元素的 <code>position</code> 定位和 <code>z-index</code> 优先级，目前只能通过修改 localsearch 源码来修复该 Bug：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout_third-party\search\localsearch.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: path,</span><br><span class="line">    dataType: isXml ? "xml" : "json",</span><br><span class="line">    async: true,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      // get the contents from search data</span><br><span class="line">      isfetched = true;</span><br><span class="line"><span class="deletion">-     $('.popup').detach().appendTo('.header-inner');</span></span><br><span class="line"><span class="addition">+     $('.popup').detach().appendTo('body');</span></span><br><span class="line">      var datas = isXml ? $("entry", res).map(function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          title: $("title", this).text(),</span><br><span class="line">          content: $("content",this).text(),</span><br><span class="line">          url: $("url" , this).text()</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;).get() : res;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<h3 id="6-3-热门文章排行"><a href="#6-3-热门文章排行" class="headerlink" title="6.3 热门文章排行"></a>6.3 热门文章排行</h3><p>该功能是基于 LeanCloud 提供的后端服务支持，原博客教程中的脚本在我这里有点问题没有效果，参考了别的博客的代码。</p>
<p>具体实现方案如下：</p>
<p>在站点目录下执行以下命令新建页面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span>top</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中新增一项菜单入口：</p>
<figure class="highlight diff"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: / || home</span><br><span class="line"><span class="addition">+   top: /top/ || signal</span></span><br><span class="line">    tags: /tags/ || tags</span><br><span class="line">    categories: /categories/ || th</span><br><span class="line">    archives: /archives/ || archive</span><br><span class="line">    about: /about/ || user</span><br></pre></td></tr></table></figure>

<p> 在语言包中新增菜单中文： </p>
<figure class="highlight diff"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: 首页</span><br><span class="line">    archives: 归档</span><br><span class="line">    categories: 分类</span><br><span class="line">    tags: 标签</span><br><span class="line">    about: 关于</span><br><span class="line"><span class="addition">+   top: 排行榜</span></span><br></pre></td></tr></table></figure>

<p> 然后在新增的排行榜页面内添加以下内容，注意要替换掉LeanCloud的appId、appKey和你的博客地址： </p>
<figure class="highlight markdown"><figcaption><span>source\top\index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 热门文章Top 10</span><br><span class="line">comments: false</span><br><span class="line">date: 2019-12-28 23:48:26</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span>AV.initialize("需要替换appID", "需要替换appKEY");<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></span><br><span class="line"><span class="code">    var time=0</span></span><br><span class="line"><span class="code">    var title=""</span></span><br><span class="line"><span class="code">    var url=""</span></span><br><span class="line"><span class="code">    var query = new AV.Query('Counter');</span></span><br><span class="line"><span class="code">    query.notEqualTo('id',0);</span></span><br><span class="line"><span class="code">    query.descending('time');</span></span><br><span class="line"><span class="code">    query.limit(1000);</span></span><br><span class="line"><span class="code">    query.find().then(function (todo) &#123;</span></span><br><span class="line"><span class="code">        for (var i=0;i&lt;1000;i++)&#123;</span></span><br><span class="line"><span class="code">            var result=todo[i].attributes;</span></span><br><span class="line"><span class="code">            time=result.time;</span></span><br><span class="line"><span class="code">            title=result.title;</span></span><br><span class="line"><span class="code">            url=result.url;</span></span><br><span class="line"><span class="code">            var content="&lt;center&gt;"+"&lt;a href='"+"需要替换https://choubin.site"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;br /&gt;"+"&lt;font color='#ff0000'&gt;"+"热度："+time+"℃"+"&lt;/font&gt;"+"&lt;br /&gt;&lt;br /&gt;"+"&lt;/center&gt;";</span></span><br><span class="line"><span class="code">            document.getElementById("top").innerHTML+=content</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;, function (error) &#123;</span></span><br><span class="line"><span class="code">        console.log("error");</span></span><br><span class="line"><span class="code">    &#125;);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span>.post-description &#123; display: none; &#125;<span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-添加评论功能"><a href="#6-4-添加评论功能" class="headerlink" title="6.4 添加评论功能"></a>6.4 添加评论功能</h3><p>在此使用<code>valine</code>，简洁美观，支持<code>Markdown</code>语法。同样需要 LeanCloud 的 App ID 和 App Key。在主题的配置文件中修改如下。 </p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="string">***&lt;app_id***</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">***&lt;app_key&gt;***</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span>  <span class="comment"># 收到新评论是否邮件通知</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span>  <span class="comment"># 是否开启验证码</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="comment"># 默认填充文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span>  <span class="comment"># 设置默认评论列表</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail</span>  <span class="comment"># 评论区头部表单</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span>  <span class="comment"># 每页评论数</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span>  <span class="comment"># 同时开启文章阅读次数统计</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-文末版权声明"><a href="#6-5-文末版权声明" class="headerlink" title="6.5 文末版权声明"></a>6.5 文末版权声明</h3><p>效果如图</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E.jpg" alt="版权声明"></p>
<p> 在主题配置文件中开启文章底部的版权声明，版权声明默认使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议，用户可以根据自身需要修改 <code>licence</code> 字段变更协议。 </p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">&lt;a</span> <span class="string">href="https://creativecommons.org/licenses/by-nc-sa/4.0/"</span> <span class="string">rel="external</span> <span class="string">nofollow"</span> <span class="string">target="_blank"&gt;CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span><span class="string">&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<p> 默认版权声明中只有 <strong>本文作者</strong>、<strong>本文链接</strong>、<strong>版权声明</strong> 三项，如果你想添加更多内容，如 <strong>创建时间</strong>、<strong>修改时间</strong>、<strong>引用链接</strong> 等，需要修改版权声明的相关代码： </p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout\_macro\post-copyright.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!-- JS库 clipboard 拷贝内容到粘贴板--&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/clipboard.js/2.0.1/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- JS库 sweetalert 显示提示信息--&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-copyright"</span>&gt;</span><br><span class="line">  &lt;!-- 本文标题 --&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.copyright.title'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.title &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 本文作者 --&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-copyright-author"</span>&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.copyright.author'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.author | default(author) &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 创建时间 --&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.created'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.date.format("YYYY年MM月DD日 - HH时MM分") &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 修改时间 --&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.modified'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.updated.format("YYYY年MM月DD日 - HH时MM分") &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 引用链接 --&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-copyright-link"</span>&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.copyright.link'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125;&lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="&#123;&#123; post.url | default(post.permalink) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"</span></span><br><span class="line"><span class="regexp">      &gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;/</span>a</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"copy-path"</span> title=<span class="string">"点击复制引用链接"</span></span><br><span class="line">      &gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span></span></span></span><br><span class="line"><span class="xml">        style="cursor: pointer"</span></span><br><span class="line"><span class="xml">        class="fa fa-clipboard"</span></span><br><span class="line"><span class="xml">        data-clipboard-text="[&#123;&#123; post.author | default(author) &#125;&#125;'s Blog | &#123;&#123; post.title &#125;&#125;](&#123;&#123; post.permalink &#125;&#125;)"</span></span><br><span class="line"><span class="xml">        aria-label="&#123;&#123; __('post.copy_success') &#125;&#125;"</span></span><br><span class="line"><span class="xml">      &gt;<span class="tag">&lt;/<span class="name">i</span></span></span></span><br><span class="line"><span class="xml">    &gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;!-- 版权声明 --&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="post-copyright-license"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;strong</span></span><br><span class="line"><span class="regexp">      &gt;&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>strong&gt;</span><br><span class="line">    &#123;&#123; __(<span class="string">'post.copyright.license_content'</span>, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">".fa-clipboard"</span>);</span><br><span class="line">  clipboard.on(<span class="string">"success"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    message.innerHTML =</span><br><span class="line">      <span class="string">'&lt;i class="fa fa-check-circle message-icon"&gt;&lt;/i&gt;&lt;span class="message-content"&gt;'</span> +</span><br><span class="line">      target.trigger.getAttribute(<span class="string">"aria-label"</span>) +</span><br><span class="line">      <span class="string">"&lt;/span&gt;"</span>;</span><br><span class="line">    swal(&#123;</span><br><span class="line">      content: message,</span><br><span class="line">      className: <span class="string">"copy-success-message"</span>,</span><br><span class="line">      timer: <span class="number">1000</span>,</span><br><span class="line">      button: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在版权样式文件中添加如下样式： </p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css_common\components\post\post-copyright.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">12px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.15</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">16</span>x <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.swal-content</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0px</span> !important;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.message-icon</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#52c41a</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.message-content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补全版权信息文案</p>
<figure class="highlight yaml"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">created:</span> <span class="string">创建时间</span></span><br><span class="line">  <span class="attr">modified:</span> <span class="string">修改时间</span></span><br><span class="line">  <span class="attr">copy_success:</span> <span class="string">复制成功</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">本文标题</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">本文作者</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">引用链接</span></span><br><span class="line">    <span class="attr">license_title:</span> <span class="string">版权声明</span></span><br><span class="line">    <span class="attr">license_content:</span> <span class="string">"本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处！"</span></span><br></pre></td></tr></table></figure>

<p> 在实际使用过程中，并非每篇文章都需要版权声明，如果转载了别人的文章，文末再出现个人版权声明就不太合适。此时可在 Front-Matter 中设定变量 <code>copyright</code> 用于控制是否显示版权信息。修改文章布局模板中相关代码，使得只有当主题配置文件中 <code>post_copyright.enable</code> 字段和 <code>page.copyright</code> 字段同时为 <code>true</code> 时才会插入版权声明： </p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% if theme.post_copyright.enable and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125;</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;% include 'post-copyright.swig' with &#123; post: post &#125; %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p> 为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样以来每篇草稿发布为正文后都会默认显示底部版权信息： </p>
<figure class="highlight diff"><figcaption><span>scaffolds\draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ copyright: true</span></span><br></pre></td></tr></table></figure>

<p>或者在每次发布文章时，设定该变量。</p>
<h3 id="6-6-添加打赏功能"><a href="#6-6-添加打赏功能" class="headerlink" title="6.6 添加打赏功能"></a>6.6 添加打赏功能</h3><p> 启用主题配置文件中的打赏相关字段，并将个人收款码图片置于 themes\next\source\images\ 目录下，注意保持图片命名与配置文件中一致： </p>
<figure class="highlight yaml"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_comment:</span></span><br><span class="line"><span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.jpg</span></span><br></pre></td></tr></table></figure>

<p>关闭悬停收款码上的文字抖动效果，可以在自定义样式文件中添加以下代码： </p>
<figure class="highlight stylus"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭打赏收款码的文字抖动效果</span></span><br><span class="line"><span class="selector-id">#QR</span> &gt; <span class="selector-tag">div</span>:hover <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意原博客中，添加<code>reward</code>字段来控制 是否在本文章中添加打赏信息，然后修改文章布局模板中相关的判定条件将会导致网站首页变成归档，生成静态文件也会报错，故而在此没有采用。</p>
<h3 id="6-7-添加图片灯箱"><a href="#6-7-添加图片灯箱" class="headerlink" title="6.7 添加图片灯箱"></a>6.7 添加图片灯箱</h3><p> 添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 <a href="https://github.com/fancyapps/fancybox" target="_blank" rel="noopener">fancyBox</a> 提供，效果如下 </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%9B%BE%E7%89%87%E7%81%AF%E7%AE%B1.jpg" alt="图片灯箱"></p>
<p> 在根目录下执行以下命令安装相关依赖： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 themes/next/<span class="built_in">source</span>/lib/fancybox</span><br></pre></td></tr></table></figure>

<p> 在主题配置文件中设置 <code>fancybox: true</code> 即可。</p>
<h3 id="6-8-相关文章推荐"><a href="#6-8-相关文章推荐" class="headerlink" title="6.8 相关文章推荐"></a>6.8 相关文章推荐</h3><p> 该功能由 <a href="https://github.com/tea3/hexo-related-popular-posts" target="_blank" rel="noopener">hexo-related-popular-posts</a> 插件提供，会在文末出现本站相关的博客。</p>
<p> 在站点根目录中执行以下命令安装依赖： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>

<p> 在主题配置文件中开启相关文章推荐功能： </p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p> 此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。 </p>
<h3 id="6-9-文章评分功能"><a href="#6-9-文章评分功能" class="headerlink" title="6.9 文章评分功能"></a>6.9 文章评分功能</h3><p> Next 主题中已经集成了 widgetpack 的星级评分系统，用户无须再安装或引入插件脚本，只需在 widgetpack 中注册账号并修改主题配置即可，应用效果如下： </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F.jpg" alt="评分效果"></p>
<p>（刚刚还给自己打了个2分。。。。。。）</p>
<p>在 <a href="https://widgetpack.com/" target="_blank" rel="noopener">widgetpack</a> 中注册账号(这个网站经常注册没反应，应该是网络差或者墙的问题，过段时间多试几次就好了），根据引导填写应用名称和域名创建应用，创建后可在页面左上角看到应用 id。</p>
<p>在主题配置文件中开启评分功能，填写应用 id，并设置评分颜色：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">fadb14</span></span><br></pre></td></tr></table></figure>

<p> 在控制台中点击左上角展开菜单，在 <strong>Rating</strong> -&gt; <strong>Setting</strong> 中将 Vote via 选项改为 Device(cookie) 以开启匿名评分，该选项将基于设备认证访问者身份，如果不开启这个选项，那么就需要登录 facebook、twitter 等墙外的社交软件 才能评分，在国内就没啥用了。 </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%BC%80%E5%90%AF%E5%8C%BF%E5%90%8D%E8%AF%84%E5%88%86.png" alt="匿名评分"></p>
<h2 id="7-提交网址-amp-amp-购买域名"><a href="#7-提交网址-amp-amp-购买域名" class="headerlink" title="7 提交网址&amp;&amp;购买域名"></a>7 提交网址&amp;&amp;购买域名</h2><h3 id="7-1-向搜索引擎提交网址"><a href="#7-1-向搜索引擎提交网址" class="headerlink" title="7.1 向搜索引擎提交网址"></a>7.1 向搜索引擎提交网址</h3><p>这里主要是向谷歌、百度提交网址，以使得可以在搜索引擎中搜到本博客网站的内容。</p>
<p> 在站点根目录下执行以下命令安装相关依赖并重新生成静态文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save-dev</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save-dev</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>此时即可在 public 目录下找到 sitemap.xml 和 baidusitemap.xml 两个文件，将该文件提交到搜索引擎站长后台即可帮助搜索引擎分析收录站点内容，各个搜索引擎收录效率不同，可能需要耐心等上几天。 </p>
<p> 在 <a href="https://search.google.com/search-console" target="_blank" rel="noopener">Google Search Console</a> 中提交站点域名，此时会提供几种验证网站所有权的方法，建议使用<strong>HTML文件</strong>验证方法，非常简单，把给的HTML文件下载下来保存到<strong>根目录下source文件夹</strong>下，然后<code>hexo g &amp;&amp; hexo d</code>返回终端点击验证即可。</p>
<p><a href="https://ziyuan.baidu.com/site" target="_blank" rel="noopener">百度同理点这里</a>。</p>
<p><strong>注意这个HTML文件之后也不能删除</strong>。然后等一天左右就可以了。</p>
<h3 id="7-2-购买域名"><a href="#7-2-购买域名" class="headerlink" title="7.2 购买域名"></a>7.2 购买域名</h3><p>购买域名建议去阿里云或者腾讯云，貌似一些域名腾讯云会比阿里云便宜1块钱。至于后缀是选择<code>.com</code>还是别的看个人喜好就行，理论上不影响站点网速。价格上当然<code>.com</code>最贵啦，然后一般网址越短越贵，也越容易已经被人注册过了，已经被人注册了的域名需要回购，而阿里云的代理回购价格是2000起步。。。所以尽量选没人注册的域名吧。</p>
<p>根据网站提示，购买完以后根据相应的网站的提示进行操作和配置就可以了，绑定域名的方法选择<code>CNAME</code>，然后在根目录下的source文件夹中新建一个名为<code>CNAME</code>的文件，文件内容为你购买的域名。然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>基本过一小会就可以通过你购买的域名来访问自己的博客了。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows/Linux 下使用 hexo+github+NexT 主题建立个人博客网站</title>
    <url>/2019/12/30/HowToBuildABlog/</url>
    <content><![CDATA[<p>&emsp;&emsp;按照建站惯例（误），本网站的第一篇博客为建站过程，作为记录，以备之后查阅。</p>
<h2 id="1-注册Github"><a href="#1-注册Github" class="headerlink" title="1 注册Github"></a>1 注册Github</h2><p>&emsp;&emsp;本博客没有租用个人服务器，所以需要借助github，注意如果后续没有购买域名的话，最终个人博客的网址将是“xxxx.github.io”，<strong>其中“xxxx”即是你的github账号名</strong>，所以尽量取个喜欢的名字吧。点击<a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册。</p>
<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2 安装Git"></a>2 安装Git</h2><p>&emsp;&emsp;Windows：需要下载<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git客户端</a>，安装完成以后再安装目录下<code>git-bash.exe</code>、<code>git-cmd.exe</code>和<code>git-gui.exe</code>。在此建议使用<code>git-bash</code>，模拟了<code>bash</code>环境，可以使用大部分<code>unix</code>的标准命令。建议更改<code>git-bash.exe</code>的管理员权限，避免莫名其妙的权限问题。右键点击<code>git-bash.exe</code>，依次选择属性→兼容性→以管理员身份运行此程序→确定。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%8F%B3%E9%94%AE%E5%B1%9E%E6%80%A7.png" alt="图1"></p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8C%E6%AD%A4%E7%A8%8B%E5%BA%8F.png" alt="图2"></p>
<p>&emsp;&emsp;Linux：直接在终端中安装git，如<code>ubuntu</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在<code>git-bash</code>或打开中终端中配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"自定义名字"</span></span><br><span class="line">git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建Github-Pages"><a href="#3-创建Github-Pages" class="headerlink" title="3 创建Github Pages"></a>3 创建Github Pages</h2><p>&emsp;&emsp;<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 是面向用户、组织和项目开放的<strong>公共静态页面搭建托管服务</strong>，站点被<strong>免费托管在<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>上</strong>，可以使用Github Pages默认提供的域名github.io 或者另外购买域名来发布站点。 </p>
<h3 id="3-1-创建repository"><a href="#3-1-创建repository" class="headerlink" title="3.1 创建repository"></a>3.1 创建repository</h3><p>&emsp;&emsp;首先在Github新建一个repository，即点击右上角的加号，选择<code>New repository</code></p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="新建仓库"></p>
<p>&emsp;&emsp;这里的repository name必须是 <code>xxxx.github.io</code>，<strong>其中<code>xxxx</code>为你的github账号用户名</strong>。其他的默认就可以了。</p>
<h3 id="3-2-克隆repository到本地"><a href="#3-2-克隆repository到本地" class="headerlink" title="3.2 克隆repository到本地"></a>3.2 克隆repository到本地</h3><p>&emsp;&emsp;如果之前没有<code>SSH KEY</code>的话需要先创建<code>SSH KEY</code>，<a href="[https://github.com/Hunter1023/learn_Git/wiki/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93#ssh](https://github.com/Hunter1023/learn_Git/wiki/远程仓库#ssh)">可以参考这里</a>。</p>
<p>&emsp;&emsp;在上一步建好的repository的右上角点击<code>Clone or download</code>，使用<code>clone with SSH</code>，点击出现连接的右边按钮，复制SSH地址。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93.jpg" alt="克隆仓库"></p>
<p>&emsp;&emsp;然后在本地电脑的合适位置新建一个文件夹用于存放本地repository，进入建好的文件夹，Windows用户右键选择打开<code>git-bash.exe</code>，Linux用户就右键打开终端，然后在终端中粘贴刚才复制的SSH地址，回车执行。</p>
<h3 id="3-3-推送本地改动到github上"><a href="#3-3-推送本地改动到github上" class="headerlink" title="3.3 推送本地改动到github上"></a>3.3 推送本地改动到github上</h3><p>&emsp;&emsp;在刚才文件夹的写一个简单的<code>html</code>文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">“hello world！”</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在终端中执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时访问<code>xxxx.github.io</code>即可看到刚才的<code>hello world</code>网页。</p>
<h2 id="4-安装环境-amp-amp-创建本地博客"><a href="#4-安装环境-amp-amp-创建本地博客" class="headerlink" title="4 安装环境&amp;&amp;创建本地博客"></a>4 安装环境&amp;&amp;创建本地博客</h2><p>&emsp;&emsp;环境安装主要是<code>Nodejs</code>和<code>hexo</code>，Windows下具体可参考<a href="https://blog.csdn.net/weixin_39345384/article/details/80097858#t1" target="_blank" rel="noopener">安装Node.js</a>和<a href="https://blog.csdn.net/weixin_39345384/article/details/80098228#t2" target="_blank" rel="noopener">安装hexo</a>。Linux下和安装其他软件没有区别。</p>
<p>&emsp;&emsp;安装完环境以后，新建一个文件夹作为本地博客的目录，然后在该文件夹下右键打开<code>git-bash</code>或终端，依次输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中<code>hexo g</code> 即为<code>hexo generate</code>别名，同理<code>hexo s</code>为<code>hexo server</code>别名。</p>
<p>&emsp;&emsp;此时可以打开浏览器输入网站<code>localhost:4000</code>查看默认的博客。</p>
<h2 id="5-部署到Github-Pages"><a href="#5-部署到Github-Pages" class="headerlink" title="5 部署到Github Pages"></a>5 部署到Github Pages</h2><p>&emsp;&emsp;首先安装<code>hexo-deployer-git</code>，注意还是在本地博客文件夹下打开的<code>git-bash</code>键入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;修改博客文件夹根目录下的网站配置文件<code>_config.yml</code>中的<code>deploy</code>配置，<strong>注意冒号后有一个空格</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xxxx/xxxx.github.io.git</span>  <span class="comment">#3.2步骤中克隆仓库的SSH地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>  <span class="comment">#分支，一般用 master 即可</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保存修改后在<code>git-bash</code>或终端中键入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里<code>hexo d</code>为<code>hexo deploy</code>别名。</p>
<h2 id="6-使用NexT主题"><a href="#6-使用NexT主题" class="headerlink" title="6 使用NexT主题"></a>6 使用NexT主题</h2><p>&emsp;&emsp;可选的主题有很多，在这里<a href="https://hexo.io/themes/" target="_blank" rel="noopener">下载到各种官方主题</a>。</p>
<p>&emsp;&emsp;本站主题是基于<code>NexT主题 v6.4.2</code>版本，<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v6.4.2" target="_blank" rel="noopener">下载链接在这里</a>，后续文章将详细记录对主题如何配置和修改来达到和本站一样的效果。</p>
<p>&emsp;&emsp;下载主题的压缩包以后，将其解压到博客根目录下的<code>theme</code>文件夹下，并命名为<code>next</code>。</p>
<p>&emsp;&emsp;然后在网站的配置文件<code>_config.yml</code>中将<code>theme</code>字段的值修改为<code>next</code>，同样<strong>注意冒号后有一个空格</strong>，下文不再赘述。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时重新生成静态文件，重启服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;即可在本地端口<code>localhost:4000</code>中查看新主题下的网站</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/next%E4%B8%BB%E9%A2%98.png" alt="next主题"></p>
<p>&emsp;&emsp;如果对主题没有定制化需求的话，那么此时直接进行部署就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果想定制得和本网站类似的话，可以参考关于主题配置修改的后续博客。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
