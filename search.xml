<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Linux系统编程（五）：多进程和fork()</title>
    <url>/2020/02/24/apue-hm05/</url>
    <content><![CDATA[<h2 id="1-进程和PCB控制块"><a href="#1-进程和PCB控制块" class="headerlink" title="1 进程和PCB控制块"></a>1 进程和PCB控制块</h2><h3 id="1-1-进程简单描述"><a href="#1-1-进程简单描述" class="headerlink" title="1.1 进程简单描述"></a>1.1 进程简单描述</h3><p> 进程可以理解为程序的一次执行，也可以理解为程序运行的一个实例。<strong>进程是分配资源的基本单位</strong>。一个进程由三部分组成：进程控制块PCB（Process Control Block），有关程序段，该程序段对其操作的数据结构集。 </p>
<p>每个用户均可同时运行多个程序。为了区分每一个运行的程序，Linux<strong>给每个进程都做了标识</strong>，称为进程号PID（process ID），每个进程的进程号是<strong>唯一</strong>的。</p>
<p>Linux 给每个进程都打上了运行者的标志，<strong>用户可以控制自己的进程</strong>：给自己的进程分配不同的<strong>优先级</strong>，也可以随时<strong>终止</strong>自己的进程。其实就是进程继承了执行者的UID和GID。</p>
<p> Linux 不可能在一个 CPU 上同时处理多个任务（作业）请求，而是<strong>采用 “分时” 技术</strong>来处理这些任务请求。 </p>
<h3 id="1-2-ps和kill命令"><a href="#1-2-ps和kill命令" class="headerlink" title="1.2 ps和kill命令"></a>1.2 ps和kill命令</h3><p>常使用<code>ps</code>命令来查看当前运行的进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用ps ajx 可以查看其父进程</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ps aux</span></span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root         1  0.0  0.0   8892   228 ?        Ssl  13:13   0:00 /init</span><br><span class="line">root         8  0.0  0.0   8904   160 tty1     Ss   13:13   0:00 /init</span><br><span class="line">choupin      9  0.0  0.0   8436   100 tty1     S    13:13   0:03 /mnt/e/wsl-term</span><br><span class="line">choupin     11  0.0  0.0  22296  7476 pts/0    Ss   13:13   0:19 /bin/zsh</span><br><span class="line">root        46  0.0  0.0   8908   164 tty2     Ss   13:13   0:00 /init</span><br><span class="line">choupin     47  0.0  0.0  10660   476 tty2     S    13:13   0:00 sh -c "$VSCODE_</span><br><span class="line">choupin     48  0.0  0.0  10660   520 tty2     S    13:13   0:00 sh /mnt/c/Users</span><br><span class="line">choupin     53  0.0  0.0  10660   500 tty2     S    13:13   0:00 sh /home/choupi</span><br><span class="line">choupin     55  0.0  0.2 979712 49872 tty2     Sl   13:13   0:25 /home/choupin/.</span><br><span class="line">choupin     75  0.0  0.1 861412 20436 tty2     Sl   13:13   0:00 /home/choupin/.</span><br><span class="line">choupin     82  0.0  0.1 791204 19028 tty2     Sl   13:13   0:00 /home/choupin/.</span><br><span class="line">choupin    113  0.0  0.1 860912 19612 tty2     Sl   13:13   0:00 /home/choupin/.</span><br></pre></td></tr></table></figure>

<p><code>STAT</code>字段表示进程状态，在下一节介绍。详细命令参数可通过<code>man</code>手册查看。</p>
<p>可以使用<code>kill</code>命令通过进程PID号来终止进程</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">kill 9527 -9</span><br></pre></td></tr></table></figure>

<p>其中<code>-9</code>是终止的信号参数。</p>
<h3 id="1-2-进程的状态"><a href="#1-2-进程的状态" class="headerlink" title="1.2 进程的状态"></a>1.2 进程的状态</h3><p>一个进程至少具有5种基本状态：初始态、执行状态、等待（阻塞）状态、就绪状态、终止状态。</p>
<ul>
<li><strong>初始状态</strong>：进程刚被创建，由于其他进程正占有CPU所以得不到执行，只能处于初始状态。 </li>
<li><strong>就绪状态</strong>：只有处于就绪状态的经过调度才能到执行状态。</li>
<li><strong>运行状态</strong>：任意时刻处于执行状态的进程只能有一个。 </li>
<li><strong>等待状态</strong>：进程等待某件事件完成 </li>
<li><strong>终止状态</strong>：进程结束</li>
</ul>
<p>有的系统，为了暂时缓和内存的紧张状态，或为了调节系统负荷，又引入了<strong>挂起</strong>的功能：暂时挂起一部分进程，把他们从内存临时换出到外存。</p>
<p><strong>阻塞挂起</strong>：进程在外存并等待某事件的出现 </p>
<p><strong>就绪挂起</strong>：进程在外存，但只要进入内存，就可以运行</p>
<p>事实上不同系统不同翻译中对进程状态的描述略有差别。其中<code>STAT</code>字段即表示进程状态，通过<code>man ps</code>可以查看相关含义</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">D    uninterruptible sleep (usually IO)</span><br><span class="line">R    running or runnable (on run queue)</span><br><span class="line">S    interruptible sleep (waiting for an event to complete)</span><br><span class="line">T    stopped by job control signal</span><br><span class="line">t    stopped by debugger during the tracing</span><br><span class="line">W    paging (not valid since the 2.6.xx kernel)</span><br><span class="line">X    dead (should never be seen)</span><br><span class="line">Z    defunct ("zombie") process, terminated but not reaped by its parent</span><br><span class="line"></span><br><span class="line">&lt;    high-priority (not nice to other users)</span><br><span class="line">N    low-priority (nice to other users)</span><br><span class="line">L    has pages locked into memory (for real-time and custom IO)</span><br><span class="line">s    is a session leader</span><br><span class="line">l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)</span><br></pre></td></tr></table></figure>

<p>对应解释为</p>
<ol>
<li>R—TASK_RUNNING(可执行状态)</li>
<li>S—TASK_INTERRUPTIBLE(可中断的睡眠状态)</li>
<li>D—TASK_UNINTERRUPTIBLE(不可中断的睡眠状态)</li>
<li>T — TASK_STOPPED或TASK_TRACED（暂停状态或跟踪状态）</li>
<li>Z — TASK_DEAD - EXIT_ZOMBIE（退出状态，进程成为僵尸进程）</li>
<li>X — TASK_DEAD - EXIT_DEAD（退出状态，进程即将被销毁）</li>
</ol>
<p><a href="https://blog.csdn.net/wjd_231/article/details/81432999?depth_1-utm_source=distribute.pc_relevant.none-task&utm_source=distribute.pc_relevant.none-task" target="_blank" rel="noopener">详细介绍可见这里。</a></p>
<h3 id="1-3-PCB进程控制块"><a href="#1-3-PCB进程控制块" class="headerlink" title="1.3 PCB进程控制块"></a>1.3 PCB进程控制块</h3><p>在Linux中进程信息存放在叫做进程控制块的数据结构中，每个进程在内核中都有一个进程控制块（PCB）来维护进程相关的信息。Linux内核的进程控制块是task_struct结构体。这在不同系统中的实现略有差别。</p>
<p>task_struct是Linux内核的一种数据结构，它会被装载到RAM并且包含着进程的信息。每个进程都把它的信息放在task_struct这个数据结构体中，其中包含了众多信息。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/unp/PCB.gif" alt=""></p>
<p>主要信息有</p>
<ul>
<li><p>进程id</p>
</li>
<li><p>进程状态status </p>
</li>
<li><p>文件描述符表</p>
</li>
<li><p>进程工作目录位置</p>
</li>
<li><p>umask掩码</p>
</li>
<li><p>信号相关信息资源</p>
</li>
<li><p>用户id和组id</p>
</li>
</ul>
<p>详细内容见操作系统相关书籍，留待后续补充。</p>
<h2 id="2-fork-和父子进程"><a href="#2-fork-和父子进程" class="headerlink" title="2 fork()和父子进程"></a>2 fork()和父子进程</h2><h3 id="2-1-fork"><a href="#2-1-fork" class="headerlink" title="2.1 fork()"></a>2.1 fork()</h3><p>可以在程序中通过<code>fork()</code>来创建进程，此时创建的进程即是该程序进程的子进程。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

<p>这个函数非常奇妙，在正常执行的情况下，将会有两个返回值。所谓的两个返回值其实就是在父子进程中各返回一次，在父进程中返回的是子进程的PID，而在子进程中返回的是0，因此可以通过检查返回值，来确定后续代码在父进程还是子进程中执行。因为进程号都是大于0的，所以执行出错时返回-1。</p>
<h3 id="2-2-getpid-getppid"><a href="#2-2-getpid-getppid" class="headerlink" title="2.2 getpid()\getppid()"></a>2.2 getpid()\getppid()</h3><p>这两个函数分别可以获取当前进程的PID和当前进程父进程的PID。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> getpid(<span class="keyword">void</span>);</span><br><span class="line"><span class="keyword">pid_t</span> getppid(<span class="keyword">void</span>);</span><br></pre></td></tr></table></figure>

<p>该函数不会执行出错，无需判断返回值。</p>
<h3 id="2-3-父子进程关系"><a href="#2-3-父子进程关系" class="headerlink" title="2.3 父子进程关系"></a>2.3 父子进程关系</h3><p>在刚刚完成<code>fork()</code>后，父子进程间的data段、text段、堆、栈、环境变量、全局变量、宿主目录位置、进程工作目录位置、信号处理方式都完全一样。</p>
<p>而进程PID、<code>fork()</code>返回值、各自父进程、进程创建时间、闹钟、未决信号集则不一样。</p>
<p>而其相同的全局变量也并未完全是简单地拷贝，而是遵循“读时共享、写时复制”的原则。如文件描述符和mmap映射区。</p>
<h3 id="2-4-循环创建n个子进程"><a href="#2-4-循环创建n个子进程" class="headerlink" title="2.4 循环创建n个子进程"></a>2.4 循环创建n个子进程</h3><p>这里要求循环创建n个子进程时，并且保证所有子进程均由最初父进程产生，也就是说所有子进程应该是兄弟关系。并可以控制特定子进程完成特定操作。</p>
<figure class="highlight c"><figcaption><span>fork_loop.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (i == <span class="number">5</span>) &#123;</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"parent, and my PID is %d\n"</span>, getpid());</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(i);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%dth child, and my PID is %d, my parent's PID is %d\n"</span>, i + <span class="number">1</span>,</span><br><span class="line">               getpid(), getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译执行，看看效果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./fork_loop</span></span><br><span class="line">1th child, and my PID is 3669, my parent's PID is 3668</span><br><span class="line">2th child, and my PID is 3670, my parent's PID is 3668</span><br><span class="line">3th child, and my PID is 3671, my parent's PID is 3668</span><br><span class="line">4th child, and my PID is 3672, my parent's PID is 3668</span><br><span class="line">5th child, and my PID is 3673, my parent's PID is 3668</span><br><span class="line">parent, and my PID is 3668</span><br></pre></td></tr></table></figure>

<h2 id="3-wait-和waitpid"><a href="#3-wait-和waitpid" class="headerlink" title="3 wait()和waitpid()"></a>3 wait()和waitpid()</h2><h3 id="3-1-函数介绍"><a href="#3-1-函数介绍" class="headerlink" title="3.1 函数介绍"></a>3.1 函数介绍</h3><p>先介绍一下孤儿进程和僵尸进程。</p>
<ul>
<li>孤儿进程：父进程先于子进终止，子进程沦为“孤儿进程”，会被 init 进程领养。</li>
<li>僵尸进程：子进程终止，父进程尚未对子进程进行回收，在此期间，子进程为“僵尸进程”。kill 对其无效。子进程的PCB资源会残留在内核中，浪费内存资源。</li>
</ul>
<p>所以在子进程终止之后，父进程应当承担回收子进程的责任，否则就可能产生故而进程和僵尸进程。</p>
<p>可以在父进程中使用<code>wait()</code>或<code>waitpid()</code>来对子进程进行回收。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数为一个传出参数，表示回收子进程的状态</span></span><br><span class="line"><span class="comment">// 可传入NULL，表示不关心子进程终止状态</span></span><br><span class="line"><span class="keyword">pid_t</span> wait(<span class="keyword">int</span> *wstatus);</span><br><span class="line"><span class="comment">// 参数1指定要回收的子进程，参数3可设置WNOHANG非阻塞</span></span><br><span class="line"><span class="keyword">pid_t</span> waitpid(<span class="keyword">pid_t</span> pid, <span class="keyword">int</span> *wstatus, <span class="keyword">int</span> options);</span><br></pre></td></tr></table></figure>

<p><code>wait()</code>函数将<strong>阻塞</strong>地回收<strong>任意一个子进程</strong>；执行成功时将返回回收进程的PID，失败返回-1；通过传出参数<code>wstatus</code>可以获得子进程终止状态。</p>
<ul>
<li>获取子进程正常终止值：<code>WIFEXITED(status)</code>为真的话，可调用 <code>WEXITSTATUS(status)</code>获得子进程的退出值。</li>
<li>获取导致子进程异常终止信号：<code>WIFSIGNALED(status)</code>为真的话，可调用<code>WTERMSIG(status)</code>得到导致子进程异常终止的信号编号。</li>
</ul>
<p><code>waitpid()</code>则可以<strong>指定特定子进程</strong>进行回收，同时也可以设置非阻塞。返回值大于0时表示成功回收子进程，返回值就是对应PID；返回值为0时，表示设置了非阻塞且子进程未结束未能回收；返回值为-1时表程序执行出错。</p>
<p>注意无论这两个函数一次都只能回收一个子进程，需要回收多个子进程需要使用循环。</p>
<h3 id="3-2-使用实例"><a href="#3-2-使用实例" class="headerlink" title="3.2 使用实例"></a>3.2 使用实例</h3><p>在2.4节的程序中，子进程先于父进程终止，且父进程未对其回收，所以会产生僵尸进程。这里对其进行改进</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid, wpid;</span><br><span class="line">    <span class="keyword">int</span> status, i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; <span class="number">5</span>; ++i) &#123;</span><br><span class="line">        <span class="keyword">if</span> ((pid = fork()) == <span class="number">-1</span>)</span><br><span class="line">            sys_err(<span class="string">"fork error"</span>);</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 子进程</span></span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="number">5</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"It is a child process %d, and the parent process id is %d\n"</span>,</span><br><span class="line">               getpid(), getppid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"the child process going to die\n"</span>);</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123; <span class="comment">// 父进程</span></span><br><span class="line">        <span class="keyword">while</span>(i--)&#123;</span><br><span class="line">        wpid = wait(&amp;status);</span><br><span class="line">        <span class="keyword">if</span> (wpid == <span class="number">-1</span>)</span><br><span class="line">            sys_err(<span class="string">"wait error"</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"It is a parent process %d\n"</span>, getpid());</span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child exit with %d\n"</span>, WEXITSTATUS(status));</span><br><span class="line">        <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"child kill with signal %d\n"</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译后执行，得到结果</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./<span class="built_in">wait</span></span></span><br><span class="line">It is a child process 3938, and the parent process id is 3937</span><br><span class="line">It is a child process 3939, and the parent process id is 3937</span><br><span class="line">It is a child process 3940, and the parent process id is 3937</span><br><span class="line">It is a child process 3941, and the parent process id is 3937</span><br><span class="line">It is a child process 3942, and the parent process id is 3937</span><br><span class="line">the child process going to die</span><br><span class="line">the child process going to die</span><br><span class="line">It is a parent process 3937</span><br><span class="line">child exit with 0</span><br><span class="line">the child process going to die</span><br><span class="line">It is a parent process 3937</span><br><span class="line">child exit with 1</span><br><span class="line">the child process going to die</span><br><span class="line">It is a parent process 3937</span><br><span class="line">child exit with 2</span><br><span class="line">It is a parent process 3937</span><br><span class="line">child exit with 3</span><br><span class="line">the child process going to die</span><br><span class="line">It is a parent process 3937</span><br><span class="line">child exit with 4</span><br></pre></td></tr></table></figure>

<p>显然，所有子进程都已经被回收。</p>
<h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><p>本篇文章先简单介绍了进程和PCB控制块的概念，因为这其实应该是操作系统的相关概念，所以在此不多做纠缠，只是有个简单印象，同时记录了相关常用命令<code>ps</code>和<code>kill</code>；然后介绍了用来创建子进程的<code>fork()</code>函数，已经实现了一个循环创建特定个数子进程的小demo；最后介绍了用以回收子进程的<code>wait()</code>和<code>waitpid()</code>函数，并对之前的小demo做了改进，使其不再产生僵尸进程。</p>
<p><code>fork()</code>函数非常重要，在后续文章其他函数的学习中，还将多次使用其实现多进程程序的编写。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程（四）：utmp文件和who命令的实现</title>
    <url>/2020/02/23/apue-hm04/</url>
    <content><![CDATA[<p>本篇文章将会介绍<code>who</code>命令的工作原理，介绍了<code>utmp</code>文件和相应结构体，以及我们可以如何用简单代码将其实现，重点在如何查询和了解相关调用的过程。</p>
<p>当然最后实现的是不带任何参数的版本，否则过于复杂就偏离了学习系统编程的初心，而完全变成了几乎没有实用意义的造轮子。相较于上篇文章中<code>ls -l</code>的实现，<code>who</code>的实现更为简单。</p>
<h2 id="1-who-的作用"><a href="#1-who-的作用" class="headerlink" title="1 who 的作用"></a>1 who 的作用</h2><p><code>who</code>可以知道正在使用系统的用户信息</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ who</span><br><span class="line">choupin  tty7         2020-01-23 12:30 (:0)</span><br></pre></td></tr></table></figure>

<p>每一行代表一个已经登录的用户，第一列是用用户名，第二列是终端名，第三列是登录时间，第四列是用户登录地址。</p>
<h2 id="2-who-如何工作"><a href="#2-who-如何工作" class="headerlink" title="2 who 如何工作"></a>2 who 如何工作</h2><p>可以使用<code>man</code>来查看相关文档</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">man who</span><br></pre></td></tr></table></figure>

<p>可以看到类似</p>
<figure class="highlight stata"><table><tr><td class="code"><pre><span class="line"><span class="keyword">If</span> <span class="keyword">FILE</span> is not specified, <span class="keyword">use</span> /<span class="keyword">var</span>/<span class="keyword">run</span>/utmp.  /<span class="keyword">var</span>/<span class="keyword">log</span>/wtmp <span class="keyword">as</span> <span class="keyword">FILE</span> is common.</span><br></pre></td></tr></table></figure>

<p>可知<code>who</code>是从<code>utmp</code>文件中读取用户登录的信息。</p>
<p>然后使用</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man -k utmp</span><br></pre></td></tr></table></figure>

<p>查看相关帮助</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ man -k utmp</span><br><span class="line">endutent (3)         - access utmp file entries</span><br><span class="line">endutxent (3)        - access utmp file entries</span><br><span class="line">getutent (3)         - access utmp file entries</span><br><span class="line">getutent_r (3)       - access utmp file entries</span><br><span class="line">...</span><br><span class="line">utmp (5)             - login records</span><br><span class="line">utmpdump (1)         - dump UTMP and WTMP files <span class="keyword">in</span> raw format</span><br><span class="line">utmpname (3)         - access utmp file entries</span><br><span class="line">utmpx (5)            - login records</span><br><span class="line">utmpxname (3)        - access utmp file entries</span><br></pre></td></tr></table></figure>

<p>找到<code>utmp(5)</code>这一行，可知<code>utmp</code>与之相关，然后输入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">man 5 utmp</span><br></pre></td></tr></table></figure>

<p>可以看到</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">NAME</span><br><span class="line">       utmp, wtmp - login records</span><br><span class="line"></span><br><span class="line">SYNOPSIS</span><br><span class="line">       <span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utmp.h&gt;</span></span></span><br><span class="line">...</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> &#123;</span></span><br><span class="line">	short   ut_type;              <span class="comment">/* Type of record */</span></span><br><span class="line">	<span class="keyword">pid_t</span>   ut_pid;               <span class="comment">/* PID of login process */</span></span><br><span class="line">	<span class="keyword">char</span>    ut_line[UT_LINESIZE]; <span class="comment">/* Device name of tty - "/dev/" */</span></span><br><span class="line">	<span class="keyword">char</span>    ut_id[<span class="number">4</span>];             <span class="comment">/* Terminal name suffix, or inittab(5) ID */</span></span><br><span class="line">	<span class="keyword">char</span>    ut_user[UT_NAMESIZE]; <span class="comment">/* Username */</span></span><br><span class="line">	<span class="keyword">char</span>    ut_host[UT_HOSTSIZE]; <span class="comment">/* Hostname for remote login, or</span></span><br><span class="line"><span class="comment">								 kernel version for run-level</span></span><br><span class="line"><span class="comment">								 messages */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span>  <span class="title">exit_status</span> <span class="title">ut_exit</span>;</span>  <span class="comment">/* Exit status of a process</span></span><br><span class="line"><span class="comment">								 marked as DEAD_PROCESS; not</span></span><br><span class="line"><span class="comment">								 used by Linux init (1 */</span></span><br><span class="line">               <span class="comment">/* The ut_session and ut_tv fields must be the same size when</span></span><br><span class="line"><span class="comment">                  compiled 32- and 64-bit.  This allows data files and shared</span></span><br><span class="line"><span class="comment">                  memory to be shared between 32- and 64-bit applications. */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">if</span> __WORDSIZE == 64 &amp;&amp; defined __WORDSIZE_COMPAT32</span></span><br><span class="line">		<span class="keyword">int32_t</span> ut_session;           <span class="comment">/* Session ID (getsid(2)),</span></span><br><span class="line"><span class="comment">                                                used for windowing */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			<span class="keyword">int32_t</span> tv_sec;           <span class="comment">/* Seconds */</span></span><br><span class="line">			<span class="keyword">int32_t</span> tv_usec;          <span class="comment">/* Microseconds */</span></span><br><span class="line">		&#125; ut_tv;                      <span class="comment">/* Time entry was made */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">		<span class="keyword">long</span>   ut_session;           <span class="comment">/* Session ID */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timeval</span> <span class="title">ut_tv</span>;</span>        <span class="comment">/* Time entry was made */</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int32_t</span> ut_addr_v6[<span class="number">4</span>];        <span class="comment">/* Internet address of remote</span></span><br><span class="line"><span class="comment">                                                host; IPv4 address uses</span></span><br><span class="line"><span class="comment">                                                just ut_addr_v6[0] */</span></span><br><span class="line">	<span class="keyword">char</span> __unused[<span class="number">20</span>];            <span class="comment">/* Reserved for future use */</span></span><br><span class="line">&#125;;</span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>故而可知可以使用<code>struct utmp</code>来存放从<code>utmp</code>文件中读取的数据，且其成员就是<code>who</code>要展示的信息。</p>
<h2 id="3-who-的代码实现"><a href="#3-who-的代码实现" class="headerlink" title="3 who 的代码实现"></a>3 who 的代码实现</h2><h3 id="3-1-who的1-0版本"><a href="#3-1-who的1-0版本" class="headerlink" title="3.1 who的1.0版本"></a>3.1 who的1.0版本</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(struct utmp*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">cur_ut</span>;</span></span><br><span class="line">    <span class="keyword">int</span> utmpfd;</span><br><span class="line">    <span class="keyword">int</span> reclen = <span class="keyword">sizeof</span>(cur_ut);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((utmpfd = <span class="built_in">open</span>(UTMP_FILE, O_RDONLY)) == <span class="number">-1</span>) ERR_EXIT(<span class="string">"open error"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(utmpfd, &amp;cur_ut, reclen)) show_info(&amp;cur_ut);</span><br><span class="line">    <span class="built_in">close</span>(utmpfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(struct utmp* ut_ptr)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8.8s "</span>, ut_ptr-&gt;ut_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8.8s "</span>, ut_ptr-&gt;ut_line);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-u "</span>, ut_ptr-&gt;ut_time);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%s"</span>, ut_ptr-&gt;ut_host);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中<code>ERR_EXIT(m)</code>为一个宏，定义如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> ERR_EXIT(m) \</span></span><br><span class="line">    <span class="keyword">do</span> &#123;            \</span><br><span class="line">        perror(m);  \</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);    \</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<p>编译执行后结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ ./who1 </span><br><span class="line">reboot   ~        1580634912 5.3.0-26-generic</span><br><span class="line">runlevel ~        1580622998 5.3.0-26-generic</span><br><span class="line">LOGIN    tty1     1580373750 </span><br><span class="line">choupin  tty7     1580442826 :0</span><br></pre></td></tr></table></figure>

<p>系统的<code>who</code>命令执行结果如下</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ who</span><br><span class="line">choupin  tty7         2020-01-23 12:30 (:0)</span><br></pre></td></tr></table></figure>

<p>可见其存在两个问题</p>
<ul>
<li>时间显示不正确</li>
<li>显示了多余的非当前用户的信息</li>
</ul>
<p>在2.0版的实现中可以解决该问题</p>
<h3 id="3-2-who的2-0版本"><a href="#3-2-who的2-0版本" class="headerlink" title="3.2 who的2.0版本"></a>3.2 who的2.0版本</h3><p>主要做两点改进</p>
<ul>
<li>使用<code>ctime()</code>来将<code>time_t</code>格式的时间转换为正常时间</li>
<li>通过<code>utmp</code>结构中的<code>ut_type</code>是否定义为<code>USER_PROCESS</code>来判断是否是用户登录信息</li>
</ul>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;   // open()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;   // printf()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;    // ctime()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;  // read() close()</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utmp.h&gt;    // struct utmp</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(struct utmp* utptr)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">cur_ut</span>;</span></span><br><span class="line">    <span class="keyword">int</span> utfd;</span><br><span class="line">    <span class="keyword">if</span> ((utfd = <span class="built_in">open</span>(UTMP_FILE, O_RDONLY)) == <span class="number">-1</span>) ERR_EXIT(<span class="string">"error open"</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="built_in">read</span>(utfd, &amp;cur_ut, <span class="keyword">sizeof</span>(cur_ut)))</span><br><span class="line">        <span class="keyword">if</span> (cur_ut.ut_type == USER_PROCESS) show_info(&amp;cur_ut);</span><br><span class="line">    <span class="built_in">close</span>(utfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(struct utmp* utptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> tv = utptr-&gt;ut_time;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8.8s "</span>, utptr-&gt;ut_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8.8s "</span>, utptr-&gt;ut_line);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-24.24s"</span>, ctime(&amp;tv));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">    <span class="keyword">if</span> (utptr-&gt;ut_host[<span class="number">0</span>] != <span class="string">'\0'</span>) <span class="built_in">printf</span>(<span class="string">" （%-s）"</span>, utptr-&gt;ut_host);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SHOWHOST</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>执行结果为</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> ./who2</span><br><span class="line">choupin  tty7     Thu Jan 23 12:30:08 2020 (:0)</span><br></pre></td></tr></table></figure>

<p>可以看见此时结果与系统命令<code>who</code>输出的结果相当接近了。</p>
<h3 id="3-3-who的实现3-0版本"><a href="#3-3-who的实现3-0版本" class="headerlink" title="3.3 who的实现3.0版本"></a>3.3 who的实现3.0版本</h3><p>上述版本实现简单明了，但每次只从<code>utmp</code>文件中使用<code>read()</code>读取一个用户的数据，如果该主机同时有多个用户使用，就需要调用许多次<code>read()</code>，从而导致程序性能低下。</p>
<p>可以使用一个数组，然后用<code>read()</code>一次性读取的n个用户的信息，然后每次返回一个用户供输出信息，当将数组中存放的数据都输出完以后，再重新读取n个用户信息到数组中，直到输出完所有信息。</p>
<p>各个功能的函数实现如下，文件<code>utmplib.c</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;utmp.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SHOWHOST</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NRECS 16</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> NULLUT ((struct utmp*)NULL)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UTSIZE (sizeof(struct utmp))</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> utmpbuf[NRECS * UTSIZE];</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> num_recs;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> cur_rec;</span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> utmpfd = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utmp_open</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    utmpfd = <span class="built_in">open</span>(UTMP_FILE, O_RDONLY);</span><br><span class="line">    num_recs = cur_rec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> utmpfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">utmp_reload</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n_chars = <span class="built_in">read</span>(utmpfd, utmpbuf, NRECS * UTSIZE);</span><br><span class="line">    <span class="keyword">if</span> (n_chars == <span class="number">-1</span>) ERR_EXIT(<span class="string">"read error"</span>);</span><br><span class="line">    num_recs = n_chars / UTSIZE;</span><br><span class="line">    cur_rec = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> num_recs;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">struct utmp* <span class="title">utmp_next</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span>* <span class="title">recp</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (utmpfd == <span class="number">-1</span>) ERR_EXIT(<span class="string">"open utmp file error"</span>);</span><br><span class="line">    <span class="keyword">if</span> (cur_rec == num_recs &amp;&amp; utmp_reload() == <span class="number">0</span>) <span class="keyword">return</span> NULLUT;</span><br><span class="line">    recp = (struct utmp*)&amp;utmpbuf[cur_rec * UTSIZE];</span><br><span class="line">    cur_rec += <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> recp;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">utmp_close</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (utmpfd != <span class="number">-1</span>) <span class="built_in">close</span>(utmpfd);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">show_info</span><span class="params">(struct utmp* utptr)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">time_t</span> tv = utptr-&gt;ut_time;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8.8s "</span>, utptr-&gt;ut_name);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-8.8s "</span>, utptr-&gt;ut_line);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"%-24.24s"</span>, ctime(&amp;tv));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> SHOWHOST</span></span><br><span class="line">    <span class="keyword">if</span> (utptr-&gt;ut_host[<span class="number">0</span>] != <span class="string">'\0'</span>) <span class="built_in">printf</span>(<span class="string">" %-s"</span>, utptr-&gt;ut_host);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span>  <span class="comment">// SHOWHOST</span></span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主函数实现如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"utmplib.c"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span> <span class="title">cur_ut</span>;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">utmp</span>* <span class="title">utptr</span> = &amp;<span class="title">cur_ut</span>;</span></span><br><span class="line">    utmp_open();</span><br><span class="line">    <span class="keyword">while</span> ((utptr = utmp_next()) != NULLUT)</span><br><span class="line">        <span class="keyword">if</span> (utptr-&gt;ut_type == USER_PROCESS) show_info(utptr);</span><br><span class="line">    utmp_close();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><p>在本篇文章中，主要记录了<code>who</code>命令的工作原理，了解了<code>utmp</code>文件的作用，以及<code>struct utmp</code>。在具体的实现过程中，循序渐进，从易到难实现了多个版本，其实这是因为<code>who</code>的实现比上篇文章中<code>ls -l</code>更简单，也在书中更前面的位置。因此这里重在学会如何查询和学习命令的方法。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux系统编程（三）：stat函数和ls -l命令的实现</title>
    <url>/2020/02/23/apue-hm03/</url>
    <content><![CDATA[<p><a href="https://choubin.site/2020/02/23/apue-hm02/" target="_blank" rel="noopener">在该系列的上一篇中</a>，介绍了文件概念和相关的诸多函数，但实例仅有两三个。本篇文章不再专门介绍函数，而是先承接上文，记录一下通过<code>stat()</code>函数来实现ls -l命令。</p>
<h2 id="1-ls-l命令的作用"><a href="#1-ls-l命令的作用" class="headerlink" title="1 ls -l命令的作用"></a>1 ls -l命令的作用</h2><p><code>ls -l</code>命令用于查看当前或指定目录下文件的详细信息，使用效果如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 124</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 15768 Feb 15 22:19 cp01</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   987 Feb 15 22:19 cp01.c</span><br><span class="line">-rw-r--r-- 1 choupin choupin   987 Feb 23 18:49 cp02.c</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 11136 Feb 21 14:05 fork_loop</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   353 Feb 21 14:05 fork_loop.c</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 11720 Feb 18 14:03 ls01</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   483 Feb 18 14:03 ls01.c</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 18256 Feb 21 14:05 ls_l</span><br><span class="line">-rw-rw-rw- 1 choupin choupin  2681 Feb 19 17:05 ls_l.c</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 15808 Feb 17 17:56 lseek</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   824 Feb 17 17:55 lseek.c</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   164 Feb 20 17:23 makefile</span><br><span class="line">drwxrwxrwx 1 choupin choupin   512 Feb 18 13:56 testls</span><br><span class="line">-rw-r--r-- 1 choupin choupin   229 Feb 17 17:55 testlseek</span><br><span class="line">-rw-r--r-- 1 choupin choupin   229 Feb 17 17:56 testlseek.txt</span><br></pre></td></tr></table></figure>

<p>其中每行包含7个字段，分别</p>
<ul>
<li>模式mode：第一个字符表示文件类型，后面表示文件访问权限</li>
<li>链接数links：即文件被引用的次数</li>
<li>文件所有者owner：用户名</li>
<li>组group：文件所有者所在的组</li>
<li>大小size：以字节bytes为单位</li>
<li>最后修改时间last-modified：较新文件会列出月日时分，较老文件只列出月日年</li>
<li>文件名name：最长为256个字节</li>
</ul>
<h2 id="2-ls-l-如何工作"><a href="#2-ls-l-如何工作" class="headerlink" title="2 ls -l 如何工作"></a>2 ls -l 如何工作</h2><p>上篇文章中，我们已经实现过不带选项的ls命令，两者的区别就在于一个只简单地输出文件名，而另一个则需要输出文件的详细信息。</p>
<p>那么文件信息如何获取呢？答案是使用之前已经介绍过的<code>stat()</code>函数，<a href="https://choubin.site/2020/02/23/apue-hm02/" target="_blank" rel="noopener">关于该函数的介绍见上篇文章</a>。</p>
<p>所以其原理就是：</p>
<ol>
<li>打开当前或给定目录</li>
<li>循环读取目录中的文件，获取文件名</li>
<li>通过文件名来调用<code>stat()</code>函数来获取文件的详细信息</li>
<li>按照指定格式来输出文件信息。</li>
</ol>
<p>第1步和第2步已经在之前ls的实现中有过练习，显然这里的主要工作就是通过<code>stat()</code>获取文件信息和按照指定格式来输出信息。</p>
<h2 id="3-获取文件信息"><a href="#3-获取文件信息" class="headerlink" title="3 获取文件信息"></a>3 获取文件信息</h2><p><code>stat()</code>的返回值是一个<code>struct stat</code>，这里需要分析一下如何从这个结构体中获取我们要在ls -l命令中打印的信息，结构体信息摘录于下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 一个用来存放文件状态的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">	<span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">	<span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">	<span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">	<span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">	<span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">	<span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">	<span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">	<span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">	<span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-1-获取mode信息"><a href="#3-1-获取mode信息" class="headerlink" title="3.1 获取mode信息"></a>3.1 获取mode信息</h3><p>需要从成员<code>st_mode</code>中获取，其类型<code>mode_t</code>在我的系统中定义就是<code>unsigned int</code>。但在命令ls -l的输出应该是类似<code>-rw-rw-r--</code>的10个字符的字符串。这之间如何转换呢？</p>
<p>其实这些信息是以位图的方式放进了这个整数类型的16位中。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/unp/stat_st_mode.png" alt=""></p>
<p>其中前4位用作文件类型，最多可标识16种类型，目前已有7种文件类型。</p>
<p>接下来3位是文件特殊属性，分别是set-user-ID，set-group-ID和sticky位，1表示具有该属性，0表示没有。</p>
<p>最后9位表示许可权限，分为3组，分别对应文件所有者、同组用户、其他用户的读写执行权限。同样有的话为1，没有的话为0。</p>
<p>既然是位图，那么必然可以通过掩码来取得其信息。如关于文件类型，在<code>&lt;sys/stat.h&gt;</code>中定义了掩码<code>S_IFMT</code>来取得文件类型信息，用法如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="keyword">switch</span> (sb.st_mode &amp; S_IFMT) &#123;</span><br><span class="line">	<span class="keyword">case</span> S_IFBLK:  <span class="built_in">printf</span>(<span class="string">"block device\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> S_IFCHR:  <span class="built_in">printf</span>(<span class="string">"character device\n"</span>);        <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> S_IFDIR:  <span class="built_in">printf</span>(<span class="string">"directory\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> S_IFIFO:  <span class="built_in">printf</span>(<span class="string">"FIFO/pipe\n"</span>);               <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> S_IFLNK:  <span class="built_in">printf</span>(<span class="string">"symlink\n"</span>);                 <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> S_IFREG:  <span class="built_in">printf</span>(<span class="string">"regular file\n"</span>);            <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> S_IFSOCK: <span class="built_in">printf</span>(<span class="string">"socket\n"</span>);                  <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:       <span class="built_in">printf</span>(<span class="string">"unknown?\n"</span>);                <span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>而掩码<code>S_IFMT</code>以及表示相应文件类型的<code>S_IDBLK</code>等实际上是一些八进制位数的宏。</p>
<p>除了直接使用掩码来判断，更简单的方法是使用定义好的比较宏</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISDIR(m)	(((m)&amp;(0170000)) == (0040000))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISCHR(m)	(((m)&amp;(0170000)) == (0020000))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISBLK(m)	(((m)&amp;(0170000)) == (0060000))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> S_ISREG(m)	(((m)&amp;(0170000)) == (0100000))</span></span><br><span class="line"><span class="comment">// 判断一个文件是否为目录</span></span><br><span class="line"><span class="keyword">if</span>(S_ISDIR(info.st_mode))</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"this is a directory\n"</span>);</span><br></pre></td></tr></table></figure>

<p>而许可权限的信息同样可以通过相应的掩码来获取。</p>
<p>在获取之后这些信息之后，即可将其转换为对应的字符串类似<code>drwxrwxr--</code>。</p>
<h3 id="3-2-获取链接数、文件大小和时间信息"><a href="#3-2-获取链接数、文件大小和时间信息" class="headerlink" title="3.2 获取链接数、文件大小和时间信息"></a>3.2 获取链接数、文件大小和时间信息</h3><p>链接信息即保存在成员<code>st_nlinks</code>里，直接打印即可。</p>
<p>文件大小信息即保存在成员<code>st_size</code>里，同样直接打印即可。</p>
<p>时间信息即保存在成员<code>st_mtime</code>里，需要注意的是这里需要使用<code>ctime()</code>函数来将其转换成要求的格式来打印。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="comment">// 返回的是类似"Wed Jun 30 21:49:08 1993\n"一个字符串</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">ctime</span><span class="params">(<span class="keyword">const</span> <span class="keyword">time_t</span> *timep)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-3-获取所有者和组名信息"><a href="#3-3-获取所有者和组名信息" class="headerlink" title="3.3 获取所有者和组名信息"></a>3.3 获取所有者和组名信息</h3><p>首先需要知道Linux系统的用户信息保存在<code>/etc/passwd</code>中，但这个文件又没有包括所有的用户，在一些网络计算机系统中，所有主机通过NIS来进行身份验证，本地只保存所有用户的一个自己以备离线操作。</p>
<p>这里可以通过<code>getwuid()</code>来获取完整的用户列表，该调用会自动选择从<code>/etc/passwd</code>还是NIS中获取信息，提高了程序的可移植性。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 接受用户的uid作为参数，返回指针指向的结构体中包含了用户信息</span></span><br><span class="line"><span class="function">struct passwd *<span class="title">getpwuid</span><span class="params">(<span class="keyword">uid_t</span> uid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">passwd</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>   *pw_name;       <span class="comment">/* username */</span></span><br><span class="line">	<span class="keyword">char</span>   *pw_passwd;     <span class="comment">/* user password */</span></span><br><span class="line">	<span class="keyword">uid_t</span>   pw_uid;        <span class="comment">/* user ID */</span></span><br><span class="line">	<span class="keyword">gid_t</span>   pw_gid;        <span class="comment">/* group ID */</span></span><br><span class="line">	<span class="keyword">char</span>   *pw_gecos;      <span class="comment">/* user information */</span></span><br><span class="line">	<span class="keyword">char</span>   *pw_dir;        <span class="comment">/* home directory */</span></span><br><span class="line">	<span class="keyword">char</span>   *pw_shell;      <span class="comment">/* shell program */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>所以可以调用<code>getpwuid()</code>来获取用户信息，打印用户名称。另外还有一种可能是，文件所有者已经搬走了，账号被删除，但这个文件还在，此时该函数将返回NULL。所以这里还需要检查返回值，而不能直接读取，否则可能出现段错误。</p>
<p>类似的使用<code>getgrgid()</code>来获取组列表，用法大同小异</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="function">struct group *<span class="title">getgrgid</span><span class="params">(<span class="keyword">gid_t</span> gid)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">group</span> &#123;</span></span><br><span class="line">	<span class="keyword">char</span>   *gr_name;        <span class="comment">/* group name */</span></span><br><span class="line">	<span class="keyword">char</span>   *gr_passwd;      <span class="comment">/* group password */</span></span><br><span class="line">	<span class="keyword">gid_t</span>   gr_gid;         <span class="comment">/* group ID */</span></span><br><span class="line">	<span class="keyword">char</span>  **gr_mem;         <span class="comment">/* NULL-terminated array of pointers</span></span><br><span class="line"><span class="comment">                                to names of group members */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>该函数也是有可能返回NULL的。</p>
<h2 id="4-实现代码"><a href="#4-实现代码" class="headerlink" title="4 实现代码"></a>4 实现代码</h2><figure class="highlight c"><figcaption><span>ls-l.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;grp.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;pwd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 用于完成ls -l功能的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_ls</span><span class="params">(<span class="keyword">char</span>[])</span></span>;</span><br><span class="line"><span class="comment">// 获取文件信息并打印的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dostat</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"><span class="comment">// 将st_mode转换为字符串的函数</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mode_to_letters</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">char</span>[])</span></span>;</span><br><span class="line"><span class="comment">// 获取用户名的函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">uid_to_name</span><span class="params">(<span class="keyword">uid_t</span>)</span></span>;</span><br><span class="line"><span class="comment">// 获取用户组名的函数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gid_to_name</span><span class="params">(<span class="keyword">gid_t</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断参数个数</span></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>)</span><br><span class="line">        do_ls(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 循环对各个参数的目录进行操作</span></span><br><span class="line">        <span class="keyword">while</span> (--argc) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s:\n"</span>, *++argv);</span><br><span class="line">            do_ls(*argv);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_ls</span><span class="params">(<span class="keyword">char</span> dirname[])</span> </span>&#123;</span><br><span class="line">    DIR* dir_ptr;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span>* <span class="title">direntp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((dir_ptr = opendir(dirname)) == <span class="literal">NULL</span>)</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"ls:cannot open %s\n"</span>, dirname);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">while</span> ((direntp = readdir(dir_ptr)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">char</span> *dname = direntp-&gt;d_name;</span><br><span class="line">            <span class="comment">// 这里过滤一下“."和".."</span></span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">strcmp</span>(dname, <span class="string">"."</span>) &amp;&amp; <span class="built_in">strcmp</span>(dname, <span class="string">".."</span>)) &#123;</span><br><span class="line">                <span class="keyword">char</span> path[<span class="number">256</span>];</span><br><span class="line">                <span class="comment">// 如果这里不做拼接的话，将无法获取非当前目录下的文件信息</span></span><br><span class="line">                <span class="built_in">sprintf</span>(path, <span class="string">"%s%s"</span>, dirname, dname);</span><br><span class="line">                dostat(path, dname);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        closedir(dir_ptr);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dostat</span><span class="params">(<span class="keyword">char</span>* filename, <span class="keyword">char</span>* name)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">stat</span> <span class="title">info</span>;</span></span><br><span class="line">    <span class="keyword">if</span> (stat(filename, &amp;info) == <span class="number">-1</span>)</span><br><span class="line">        perror(filename);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">char</span> modestr[<span class="number">11</span>];</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">stat</span>* <span class="title">info_ptr</span> = &amp;<span class="title">info</span>;</span></span><br><span class="line">        mode_to_letters(info_ptr-&gt;st_mode, modestr);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s"</span>, modestr);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%4d "</span>, (<span class="keyword">int</span>)info_ptr-&gt;st_nlink);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-8s"</span>, uid_to_name(info_ptr-&gt;st_uid));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%-8s "</span>, gid_to_name(info_ptr-&gt;st_gid));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%8ld "</span>, (<span class="keyword">long</span>)info_ptr-&gt;st_size);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%.12s "</span>, <span class="number">4</span> + ctime(&amp;info_ptr-&gt;st_ctime));</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%s\n"</span>, name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">mode_to_letters</span><span class="params">(<span class="keyword">int</span> mode, <span class="keyword">char</span> str[])</span> </span>&#123;</span><br><span class="line">    <span class="built_in">strcpy</span>(str, <span class="string">"----------"</span>);</span><br><span class="line">    <span class="keyword">if</span> (S_ISDIR(mode)) str[<span class="number">0</span>] = <span class="string">'d'</span>;</span><br><span class="line">    <span class="keyword">if</span> (S_ISCHR(mode)) str[<span class="number">0</span>] = <span class="string">'c'</span>;</span><br><span class="line">    <span class="keyword">if</span> (S_ISBLK(mode)) str[<span class="number">0</span>] = <span class="string">'b'</span>;</span><br><span class="line">	<span class="comment">// 通过掩码来获取文件权限并将其转换对应字符</span></span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IRUSR) str[<span class="number">1</span>] = <span class="string">'r'</span>;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IWUSR) str[<span class="number">2</span>] = <span class="string">'w'</span>;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IXUSR) str[<span class="number">3</span>] = <span class="string">'x'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IRGRP) str[<span class="number">4</span>] = <span class="string">'r'</span>;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IWGRP) str[<span class="number">5</span>] = <span class="string">'w'</span>;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IXGRP) str[<span class="number">6</span>] = <span class="string">'x'</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IROTH) str[<span class="number">7</span>] = <span class="string">'r'</span>;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IWOTH) str[<span class="number">8</span>] = <span class="string">'w'</span>;</span><br><span class="line">    <span class="keyword">if</span> (mode &amp; S_IXOTH) str[<span class="number">9</span>] = <span class="string">'x'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">uid_to_name</span><span class="params">(<span class="keyword">uid_t</span> uid)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">passwd</span>* <span class="title">pw_ptr</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> uname[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span> ((pw_ptr = getpwuid(uid)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若没有该用户则打印uid</span></span><br><span class="line">        <span class="built_in">sprintf</span>(uname, <span class="string">"%d"</span>, uid);</span><br><span class="line">        <span class="keyword">return</span> uname;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> pw_ptr-&gt;pw_name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">char</span>* <span class="title">gid_to_name</span><span class="params">(<span class="keyword">gid_t</span> gid)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">group</span>* <span class="title">grp_ptr</span>;</span></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span> gname[<span class="number">10</span>];</span><br><span class="line">    <span class="keyword">if</span> ((grp_ptr = getgrgid(gid)) == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="comment">// 若没有该组则打印gid</span></span><br><span class="line">        <span class="built_in">sprintf</span>(gname, <span class="string">"%d"</span>, gid);</span><br><span class="line">        <span class="keyword">return</span> gname;</span><br><span class="line">    &#125; <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> grp_ptr-&gt;gr_name;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>将其编译并进行测试</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc ls_l.c -o ls_l</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./ls_l  /</span></span><br><span class="line">/:</span><br><span class="line">drwxr-xr-x   1 root    root          512 Jan 11 20:23 bin</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 boot</span><br><span class="line">drwxr-xr-x   1 root    root          512 Feb 23 13:13 dev</span><br><span class="line">drwxr-xr-x   1 root    root          512 Feb 23 13:13 etc</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:49 home</span><br><span class="line">-rwxr-xr-x   1 root    root       591344 Jan  1 08:00 init</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 20 15:22 lib</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 lib64</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 media</span><br><span class="line">drwxr-xr-x   1 root    root          512 Feb 23 13:13 mnt</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 opt</span><br><span class="line">dr-xr-xr-x  45 root    root            0 Feb 23 13:13 proc</span><br><span class="line">drwx------   1 root    root          512 Feb 11 10:08 root</span><br><span class="line">drwxr-xr-x   1 root    root          512 Feb 23 13:13 run</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 19 20:12 sbin</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 snap</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 srv</span><br><span class="line">dr-xr-xr-x  12 root    root            0 Feb 23 13:13 sys</span><br><span class="line">drwxrwxrwx   1 root    root          512 Feb 23 22:36 tmp</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 usr</span><br><span class="line">drwxr-xr-x   1 root    root          512 Dec 10 10:47 var</span><br></pre></td></tr></table></figure>

<p>实现完成。</p>
<h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5 结束语"></a>5 结束语</h2><p>本篇文章主要通过了实现<code>ls -l</code>来练习<code>stat()</code>相关函数以及<code>struct stat</code>的使用，熟悉了如何获取文件详细信息，并将其转换成我们需要的格式。在文件mode信息获取中，使用到的关于掩码的宏较多，通过这次练习即使记不住也有个大概印象，下次再需使用时也可以通过查询相关帮助信息来完成编写。</p>
<p>本篇文章主要内容依然总结自《Unix\Linux编程实践教程》一书，下一篇依然会是编程练习，记录<code>who</code>命令的实现。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统编程（二）：文件、文件操作函数和相关实例</title>
    <url>/2020/02/23/apue-hm02/</url>
    <content><![CDATA[<p>本篇文章主要简单介绍一些 Linux 系统编程中常用的函数，如<code>open()</code>、<code>close()</code>、<code>read()</code>、<code>write()</code>等，然后使用这些函数实现一些常见的 Linux 命令，如<code>more</code>、<code>who</code>、<code>ls</code>等。这样一方面可以练习这些函数的使用，另一方面也能对这些 Linux 命令有更深的理解。</p>
<h2 id="1-man-手册"><a href="#1-man-手册" class="headerlink" title="1 man 手册"></a>1 man 手册</h2><p>在介绍函数之前，先介绍<code>Linux man</code>手册的用法。在各种<code>Unix\Linux</code>系统中都有各自的<code>man</code>手册，里面包括了各种系统命令、系统调用、库函数等的文档，并且对应地分成不同章节，功能十分强大。</p>
<p>使用方法如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 2 是对应章节号 open是要查询的函数或命令</span></span><br><span class="line">man 2 open</span><br></pre></td></tr></table></figure>

<p>不同章节对应的是不同类型的内容，因为有些系统调用的函数名和系统命令或其他章节中的内容重名，如系统命令<code>write</code>用于给另一个用户发送信息，而系统调用<code>write()</code>则是向文件中写入数据，所以在使用的时候最好加上对应的章节名。</p>
<p>输入<code>man man</code>可以查看各个章节内容对应如下</p>
<ul>
<li>1 - Executable programs or shell commands：系统命令</li>
<li>2 - system calls(functions provided by the kernel)：系统调用函数，</li>
<li>3 - library calls(functions within program libraries)：库函数</li>
<li>4 - special file(usually found in /dev)：特殊文件</li>
<li>5 - file formats and convertions e.g /etc/passwd：文件格式</li>
<li>6 - games for linux：由系统中的游戏来定义</li>
<li>7 - Miscellaneous (including macro packages and conventions), e.g man(7), groff(7)：附件和一些变量</li>
<li>8 - System administration commands (usually only for root)：系统管理的命令</li>
<li>9 - Kernel routines [Non standard]：内核例程，非标准</li>
</ul>
<p>不同系统显示的结果会略有差异，但前 8 个几乎都是大同小异的。</p>
<p>如果不知道想用函数的具体名称和章节，还可以<code>-k</code>选项通过关键字来查找相关函数。如我想查找可以读取目录的相关函数可以这样做</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> man -k <span class="built_in">read</span> | grep directory</span></span><br><span class="line">readdir (2)          - read directory entry</span><br><span class="line">readdir (3)          - read a directory</span><br><span class="line">readdir (3am)        - directory input parser for gawk</span><br><span class="line">readdir_r (3)        - read a directory</span><br><span class="line"><span class="meta">#</span><span class="bash"> 通过结果知道readdir(3)很可能是需要的 再次使用man</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> man 3 readdir</span></span><br></pre></td></tr></table></figure>

<p>PS：其实大部分时候都是用<code>man</code>来查看相应函数的头文件以及可选参数名称。</p>
<h2 id="2-文件相关概念"><a href="#2-文件相关概念" class="headerlink" title="2 文件相关概念"></a>2 文件相关概念</h2><p>在 Linux 系统中，一切皆文件，所以对于初学者来说，文件的打开关闭、读取写入应该是最基本、最常见的操作了。而在学习相关函数之前还需要对文件相关概念有个基本的认识。</p>
<h3 id="2-1-文件的类型"><a href="#2-1-文件的类型" class="headerlink" title="2.1 文件的类型"></a>2.1 文件的类型</h3><p>Linux 下有七种文件类型，并用相应标识符来表示</p>
<table>
<thead>
<tr>
<th>文件类型标识</th>
<th>文件类型</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td>普通文件</td>
</tr>
<tr>
<td>d</td>
<td>目录</td>
</tr>
<tr>
<td>l</td>
<td>符号链接</td>
</tr>
<tr>
<td>s（伪文件）</td>
<td>套接字</td>
</tr>
<tr>
<td>b（伪文件）</td>
<td>块设备</td>
</tr>
<tr>
<td>c（伪文件）</td>
<td>字符设备</td>
</tr>
<tr>
<td>p（伪文件）</td>
<td>管道</td>
</tr>
</tbody></table>
<p>七种中仅有普通文件、目录、符号链接真正地占用磁盘空间，其余四种伪文件并不占用磁盘空间。</p>
<p>在使用<code>ls -l</code>命令查看当前目录下文件信息时，每行第一个字符即代表文件类型</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ls -l</span></span><br><span class="line">total 40</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   165 Feb 23 13:30 makefile</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 11576 Feb 23 14:05 mmap_r</span><br><span class="line">-rw-rw-rw- 1 choupin choupin   784 Feb 23 14:05 mmap_r.c</span><br><span class="line">-rwxrwxrwx 1 choupin choupin 11640 Feb 23 14:05 mmap_w</span><br><span class="line">-rw-rw-rw- 1 choupin choupin  1143 Feb 23 14:05 mmap_w.c</span><br><span class="line">-rw-rw-rw- 1 choupin choupin    24 Feb 23 14:05 test</span><br><span class="line">-------rwx 1 choupin choupin    24 Feb 23 13:53 test.txt</span><br></pre></td></tr></table></figure>

<h3 id="2-2-文件描述符"><a href="#2-2-文件描述符" class="headerlink" title="2.2 文件描述符"></a>2.2 文件描述符</h3><p>文件描述符是用来帮助进程来对文件进行操作的，称为 File Descriptor，在代码中表现为一个<code>int</code>类型整数。</p>
<p><a href="http://c.biancheng.net/view/3066.html" target="_blank" rel="noopener">以下内容主要来自这里</a>。</p>
<p>在一个 Linux 进程启动后，会在内核空间中创建一个 PCB 控制块，PCB 内部有一个文件描述符表（File descriptor table），记录着当前进程所有可用的文件描述符，也即当前进程所有打开的文件。 这个 PCB 控制块在代码实现中表现为一个<code>struct</code>。</p>
<p>除了文件描述符表，系统还需要维护另外两张表：</p>
<ul>
<li>打开文件表（open file table）</li>
<li>i-node 表（i-node table）</li>
</ul>
<p>文件描述符表每个进程都有一个，打开文件表和 i-node 表整个系统只有一个，它们三者之间的关系如下图所示。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/unp/filedescriptor.gif" alt=""></p>
<p>从本质上讲，这三种表都是结构体数组，0、1、2、73、1976 等都是数组下标。表头只是添加的注释，数组本身是没有的。实线箭头表示指针的指向，虚线箭头添加的注释。</p>
<p><strong>所以文件描述符不过是一个数组的下标</strong>。</p>
<p>通过文件描述符，可以找到文件指针，从而进入打开文件表。该表存储了以下信息：</p>
<ul>
<li>文件偏移量， 也就是文件内部指针偏移量。调用 read() 或者 write() 函数时，文件偏移量会自动更新，当然也可以使用 lseek() 直接修改。</li>
<li>状态标志，比如只读模式、读写模式、追加模式、覆盖模式等</li>
<li>i-node 表指针。</li>
</ul>
<p>然而要想真正读取文件，还需通过打开文件表的 i-node 指针进入 i-node 表，该表包含了诸如以下信息</p>
<ul>
<li>文件类型</li>
<li>文件大小</li>
<li>时间戳，包括创建时间、更新时间</li>
<li>文件锁</li>
</ul>
<p>对上图的进一步说明：</p>
<ul>
<li>在进程 A 中，文件描述符 1 和 20 都指向了同一个打开文件表项，标号为 23（指向了打开文件表中下标为 23 的数组元素），这可能是通过调用 dup()、dup2()、fcntl() 或者对同一个文件多次调用了 open() 函数形成的。</li>
<li>进程 A 的文件描述符 2 和进程 B 的文件描述符 2 都指向了同一个文件，这可能是在调用 fork() 后出现的（即进程 A、B 是父子进程关系），或者是不同的进程独自去调用 open() 函数打开了同一个文件，此时进程内部的描述符正好分配到与其他进程打开该文件的描述符一样。</li>
<li>进程 A 的描述符 0 和进程 B 的描述符 3 分别指向不同的打开文件表项，但这些表项均指向 i-node 表的同一个条目（标号为 1976）；换言之，它们指向了同一个文件。发生这种情况是因为每个进程各自对同一个文件发起了 open() 调用。同一个进程两次打开同一个文件，也会发生类似情况。</li>
</ul>
<p><strong>对于实际编程中，我们需要特别关注两个点</strong></p>
<ul>
<li>默认情况下，文件描述符范围为 0~1023，并每次默认使用表中可用的最小值</li>
<li>0，1，2 默认被系统占用，0 对应标准输入<code>STDIN_FILENO</code>，1 对应标准输出<code>STDOUT_FILENO</code>，2 对应标准错误输出<code>STDERR_FILENO</code>。</li>
</ul>
<h2 id="3-文件操作相关函数"><a href="#3-文件操作相关函数" class="headerlink" title="3 文件操作相关函数"></a>3 文件操作相关函数</h2><p>这里先将文件操作相关函数做一个总结式的罗列介绍，相关 demo 放到下一章和后续文章中。</p>
<h3 id="3-1-open-、creat-和-close"><a href="#3-1-open-、creat-和-close" class="headerlink" title="3.1 open()、creat()和 close()"></a>3.1 open()、creat()和 close()</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1是要打开的文件路径名称</span></span><br><span class="line"><span class="comment">// 参数2是打开方式，如O_RDONLY、O_WRONLY、O_RDWR，还可加入可选参数如O_CREATE</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags)</span></span>;</span><br><span class="line"><span class="comment">// 参数3是在参数2使用了O_CREATE新建文件后，可设置新建文件的权限</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">open</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">int</span> flags, <span class="keyword">mode_t</span> mode)</span></span>;</span><br><span class="line"><span class="comment">// 等同于使用了O_CREATE参数的open()</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">creat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, <span class="keyword">mode_t</span> mode)</span></span>;</span><br></pre></td></tr></table></figure>

<p>关于返回值， 成功返回对应的文件描述符，失败返回-1，并自动设置<code>errno</code>，所以在使用时，一般都要判断返回值。注意<code>open</code>的<code>flag</code>参数中，读写方式是必选的，可选的参数包括了<code>O_CREAT|O_APPEND|O_TRUNC|O_EXCL|O_NONBLOCK</code>，详细说明见<code>man</code>手册。</p>
<p>打开的文件在程序结束前要使用<code>close()</code>来关闭。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 唯一参数是要关闭的文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">close</span><span class="params">(<span class="keyword">int</span> fd)</span></span>;</span><br></pre></td></tr></table></figure>

<p>同样失败返回-1，成功的话返回 0。</p>
<h3 id="3-2-read-和-write"><a href="#3-2-read-和-write" class="headerlink" title="3.2 read()和 write()"></a>3.2 read()和 write()</h3><p>从文件中读取数据使用<code>read()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1是读取文件的文件描述符</span></span><br><span class="line"><span class="comment">// 参数2是存放读取数据的缓存数组指针</span></span><br><span class="line"><span class="comment">// 参数3是一次读取的数据Byte数</span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">read</span>(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>

<p>成功的话返回实际读取的 byte 数，失败的话返回-1，并设置<code>errno</code>，若<code>errno = EAGIN</code>或 <code>EWOULDBLOCK</code>, 说明不是<code>read</code>失败，而是<code>read</code>在以非阻塞方式读一个设备文件（网络文件），并且文件无数据。</p>
<div class="note danger"><p>阻塞与非阻塞是设备文件、网络文件的属性。在读取设备文件、网络文件时会产生阻塞，如终端文件<code>/dev/tty</code>和网络套接字。</p><p>可以使用<code>open(&quot;dev/tty&quot;, O_RDWR | O_NONBLOCK)</code>来设置非阻塞状态。</p></div>

<p>向文件中写入数据使用<code>write()</code></p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1为写入文件的文件描述符</span></span><br><span class="line"><span class="comment">// 参数2为存放需写入数据的缓存数组指针</span></span><br><span class="line"><span class="comment">// 参数3位一次写入的数据byte数</span></span><br><span class="line"><span class="keyword">ssize_t</span> <span class="built_in">write</span>(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> count);</span><br></pre></td></tr></table></figure>

<p>成功返回实际写入的 byte 数，失败时返回-1。</p>
<h3 id="3-3-fcntl"><a href="#3-3-fcntl" class="headerlink" title="3.3 fcntl()"></a>3.3 fcntl()</h3><p>该函数可以根据文件描述符来获取和改变文件属性。称为文件控制函数。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1为对应文件的文件描述符</span></span><br><span class="line"><span class="comment">// 参数2代表操作类型</span></span><br><span class="line"><span class="comment">// 可选参数根据参数2而相应设定</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fcntl</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> cmd, ... <span class="comment">/* arg */</span> )</span></span>;</span><br></pre></td></tr></table></figure>

<p>该函数主要有 5 种功能：</p>
<ul>
<li>复制一个现有的描述符（cmd=F_DUPFD）</li>
<li>获得／设置文件描述符标记(cmd=F_GETFD 或 F_SETFD)</li>
<li>获得／设置文件状态标记(cmd=F_GETFL 或 F_SETFL)</li>
<li>获得／设置异步 I/O 所有权(cmd=F_GETOWN 或 F_SETOWN)</li>
<li>获得／设置记录锁(cmd=F_GETLK,F_SETLK 或 F_SETLKW)</li>
</ul>
<p>参数比较复杂，后面用到时再做补充吧。</p>
<h3 id="3-4-lseek-和-truncate"><a href="#3-4-lseek-和-truncate" class="headerlink" title="3.4 lseek()和 truncate()"></a>3.4 lseek()和 truncate()</h3><p><code>lseek()</code>函数用以改变打开文件的当前偏移量。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1为文件描述符</span></span><br><span class="line"><span class="comment">// 参数2为需要更改的偏移量，可取负值</span></span><br><span class="line"><span class="comment">// 参数3为更改的位置，SEEK_SET、SEEK_CUR、SEEK_END分别代表起始位置，当前位置以及末尾</span></span><br><span class="line"><span class="keyword">off_t</span> lseek(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> offset, <span class="keyword">int</span> whence)</span><br></pre></td></tr></table></figure>

<p>成功的话返回<strong>较起始位置</strong>的偏移量，失败的话返回-1,设置<code>errno</code>。</p>
<p>常用于获取、拓展文件大小，使用方法在 4.3 节。</p>
<p>注意两点</p>
<ul>
<li>文件读写操作使用的是同一偏移量</li>
<li>要想真正拓展文件大小必须引起 IO 操作</li>
</ul>
<p>而使用<code>truncate()</code>函数可以直接拓展文件大小</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1为文件路径，参数2为文件拓展后大小</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">truncate</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *path, <span class="keyword">off_t</span> length)</span></span>;</span><br><span class="line"><span class="comment">// 参数1位文件描述符</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">ftruncate</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">off_t</span> length)</span></span>;</span><br></pre></td></tr></table></figure>

<p>两个版本作用相同，只是接受参数不一样。成功返回 0，失败返回-1。</p>
<p><strong>注意：如果函数设定的长度小于文件原本长度，那么超出部分将会被丢弃，反之填充<code>\0</code>。</strong></p>
<h3 id="3-5-stat-和-lstat"><a href="#3-5-stat-和-lstat" class="headerlink" title="3.5 stat()和 lstat()"></a>3.5 stat()和 lstat()</h3><p>该函数用于获取文件状态，如文件大小、类型、权限。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 一个用来存放文件状态的结构体</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">stat</span> &#123;</span></span><br><span class="line">    <span class="keyword">dev_t</span>     st_dev;         <span class="comment">/* ID of device containing file */</span></span><br><span class="line">	<span class="keyword">ino_t</span>     st_ino;         <span class="comment">/* Inode number */</span></span><br><span class="line">	<span class="keyword">mode_t</span>    st_mode;        <span class="comment">/* File type and mode */</span></span><br><span class="line">	<span class="keyword">nlink_t</span>   st_nlink;       <span class="comment">/* Number of hard links */</span></span><br><span class="line">	<span class="keyword">uid_t</span>     st_uid;         <span class="comment">/* User ID of owner */</span></span><br><span class="line">	<span class="keyword">gid_t</span>     st_gid;         <span class="comment">/* Group ID of owner */</span></span><br><span class="line">	<span class="keyword">dev_t</span>     st_rdev;        <span class="comment">/* Device ID (if special file) */</span></span><br><span class="line">	<span class="keyword">off_t</span>     st_size;        <span class="comment">/* Total size, in bytes */</span></span><br><span class="line">	<span class="keyword">blksize_t</span> st_blksize;     <span class="comment">/* Block size for filesystem I/O */</span></span><br><span class="line">	<span class="keyword">blkcnt_t</span>  st_blocks;      <span class="comment">/* Number of 512B blocks allocated */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_atim</span>;</span>  <span class="comment">/* Time of last access */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_mtim</span>;</span>  <span class="comment">/* Time of last modification */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timespec</span> <span class="title">st_ctim</span>;</span>  <span class="comment">/* Time of last status change */</span></span><br><span class="line"></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_atime st_atim.tv_sec      <span class="comment">/* Backward compatibility */</span></span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_mtime st_mtim.tv_sec</span></span><br><span class="line">	<span class="meta">#<span class="meta-keyword">define</span> st_ctime st_ctim.tv_sec</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// 参数1为文件路径名，参数2为存放文件状态的结构体指针</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">stat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">lstat</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname, struct stat *statbuf)</span></span>;</span><br></pre></td></tr></table></figure>

<p>常使用<code>struct stat</code>的<code>st_size</code>、<code>st_mode</code>来获取文件的大小、类型和权限，<code>st_mode</code>的第一位就是文件类型，该成员使用位图的原理来存放类型和权限信息。后面有相关例子。</p>
<p><strong>而<code>stat()</code>和<code>lstat()</code>的区别是一个会符号穿透，一个不会。</strong>即假如有一个符号链接<code>file1</code>，其指向文件<code>file2</code>，那么对<code>file1</code>使用<code>stat()</code>获取的是<code>file2</code>的状态，而使用<code>lstat()</code>的话获取的是符号链接<code>file1</code>的状态。</p>
<h3 id="3-6-link-和-ulink"><a href="#3-6-link-和-ulink" class="headerlink" title="3.6 link()和 ulink()"></a>3.6 link()和 ulink()</h3><p>在<code>struct stat</code>中有一个<code>st_nlink</code>成员代表该文件的链接数。在文件刚被<code>open()</code>或<code>creat()</code>创建时，该文件会有 1 个链接数；而在使用<code>close()</code>关闭打开文件时会检查文件的链接数，如果链接数为 0，则该文件将会被隐式删除，即在使用该文件的进程结束后，系统会根据自身算法对其择机删除。</p>
<p>而<code>link()</code>可以建立文件的硬链接。硬链接相当于文件的命名，相对原文件来说只是目录项<code>dir_entry</code>不一样，但其<code>dir_entry</code>中的<code>inode</code>是同一个，而<code>inode</code>的成员又指向实际的数据块，所以实际内存位置是同一个；软链接即符号链接，则相当于文件的快捷方式，其拥有不同于原文件的<code>dir_entry</code>、<code>inode</code>，自然最后指向的数据块也不一致，但其数据块存放了原文件的路径。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="comment">// 参数1为原文件路径名，参数2为新建硬链接的路径名</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">link</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *oldpath, <span class="keyword">const</span> <span class="keyword">char</span> *newpath)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>unlink()</code>可以删除硬链接和软链接。如果是软链接直接删除，如果是硬链接，则删除后如果原文件的链接数变为 0，才会在像在上文提到的那样被隐式删除。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">unlink</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *pathname)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-7-opendir-、closedir-和-readdir"><a href="#3-7-opendir-、closedir-和-readdir" class="headerlink" title="3.7 opendir()、closedir()和 readdir()"></a>3.7 opendir()、closedir()和 readdir()</h3><p>目录本质上也是文件，只是目录文件存放的是其他文件的<code>dir_entry</code>结构体。</p>
<p>可以使用<code>opendir()</code>和<code>closedir()</code>来打开和关闭目录。注意这是两个库函数，而不是系统调用函数，在<code>man</code>手册第 2 章。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="function">DIR *<span class="title">opendir</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *name)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">closedir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"><span class="function">struct dirent *<span class="title">readdir</span><span class="params">(DIR *dirp)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> &#123;</span></span><br><span class="line">    <span class="keyword">ino_t</span>          d_ino;       <span class="comment">/* Inode number */</span></span><br><span class="line">    <span class="keyword">off_t</span>          d_off;       <span class="comment">/* Not an offset; see below */</span></span><br><span class="line">    <span class="keyword">unsigned</span> short d_reclen;    <span class="comment">/* Length of this record */</span></span><br><span class="line">    <span class="keyword">unsigned</span> <span class="keyword">char</span>  d_type;      <span class="comment">/* Type of file; not supported</span></span><br><span class="line"><span class="comment">                                    by all filesystem types */</span></span><br><span class="line">    <span class="keyword">char</span>           d_name[<span class="number">256</span>]; <span class="comment">/* Null-terminated filename */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>需要注意的是，<code>opendir()</code>的参数和返回值和<code>open()</code>略有差别。参数无需多说，是相应目录的路径；在成功时返回一个<code>DIR*</code>类型的目录流，失败时返回<code>NULL</code>。</p>
<p><code>closedir()</code>成功返回 0，失败返回-1。</p>
<p>而<code>readdir()</code>接受一个目录流类型的指针，从该目录下对逐个文件读取信息，并存放在一个<code>struct dirent</code>中，并返回其指针。通过其返回的指针，我们就可以获取到目录中的信息。</p>
<h2 id="4-系统编程实践"><a href="#4-系统编程实践" class="headerlink" title="4 系统编程实践"></a>4 系统编程实践</h2><h3 id="4-1-cp-命令的实现"><a href="#4-1-cp-命令的实现" class="headerlink" title="4.1 cp 命令的实现"></a>4.1 cp 命令的实现</h3><p><code>cp</code>命名用于将文件拷贝，用法如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">cp file1 file2</span><br><span class="line">`</span><br></pre></td></tr></table></figure>

<h4 id="4-1-1-实现思路"><a href="#4-1-1-实现思路" class="headerlink" title="4.1.1 实现思路"></a>4.1.1 实现思路</h4><p>其原理非常简单，流程如下</p>
<ol>
<li>打开<code>file1</code>，新建文件<code>file2</code></li>
<li>读取<code>file1</code>内容到缓冲区</li>
<li>将缓冲区内容写入<code>file2</code></li>
<li>重复 2、3 直到<code>file1</code>文件被全部读取、写入</li>
</ol>
<h4 id="4-1-2-实现代码"><a href="#4-1-2-实现代码" class="headerlink" title="4.1.2 实现代码"></a>4.1.2 实现代码</h4><p>实现代码如下</p>
<figure class="highlight c"><figcaption><span>cp01.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> COPYMODE 0644</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">char</span>*, <span class="keyword">char</span>*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 判断参数个数是否合理</span></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>) &#123;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"usage: %s source destination\n"</span>, *argv);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> in_fd, out_fd, n_chars;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="comment">// 打开原文件</span></span><br><span class="line">    <span class="keyword">if</span> ((in_fd = <span class="built_in">open</span>(argv[<span class="number">1</span>], O_RDONLY)) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">"Cannot open "</span>, argv[<span class="number">1</span>]);</span><br><span class="line">    <span class="comment">// 新建目标文件</span></span><br><span class="line">    <span class="keyword">if</span> ((out_fd = creat(argv[<span class="number">2</span>], COPYMODE)) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">"Cannot creat "</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    <span class="comment">// 使用循环重复读取</span></span><br><span class="line">    <span class="keyword">while</span>((n_chars = <span class="built_in">read</span>(in_fd, buf, BUFFSIZE)) &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="comment">// 写入目标文件</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">write</span>(out_fd, buf, n_chars) != n_chars)</span><br><span class="line">            oops(<span class="string">"Write error to "</span>, argv[<span class="number">2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (n_chars == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">"Read error from "</span>, argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(in_fd) == <span class="number">-1</span> || <span class="built_in">close</span>(out_fd) == <span class="number">-1</span>)</span><br><span class="line">        oops(<span class="string">"Error closing files"</span>, <span class="string">""</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">oops</span><span class="params">(<span class="keyword">char</span>* s1, <span class="keyword">char</span>* s2)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">"Error: %s"</span>, s1);</span><br><span class="line">    perror(s2);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>编译完成以后执行一下，然后用 Linux 命令的<code>cmp</code>命令比较一下原文件和拷贝文件是否有不同</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> gcc cp01.c -o cp01</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> ./cp01 cp01.c cp02.c</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> cmp cp01.c cp02.c</span></span><br></pre></td></tr></table></figure>

<p>没有提示信息就是没有不同，说明程序正确。</p>
<h3 id="4-2-ls-命令的实现"><a href="#4-2-ls-命令的实现" class="headerlink" title="4.2 ls 命令的实现"></a>4.2 ls 命令的实现</h3><p>ls 可以说是 Linux 系统中最常用的命令之一了，用来查看当前或其他目录下的文件。但 ls 有许许多多的选项，全部实现自然不太可能，也没这个必要。这里我们仅实现最基础不带选项的功能版本，但要求其可以接受指定目录作为参数。</p>
<h4 id="4-2-1-实现思路"><a href="#4-2-1-实现思路" class="headerlink" title="4.2.1 实现思路"></a>4.2.1 实现思路</h4><p>首先 ls 既然是查看目录下文件，故而必须要打开目录，读取目录，返回目录信息，由于我们这里只实现不带选项的ls版本，所以只需返回目录下的文件名称即可。</p>
<ol>
<li>判断是否带参数，若带参数，以参数作为目录名，否则默认当前目录</li>
<li>使用<code>opendir</code>打开目录</li>
<li>使用<code>readdir</code>循环读取目录中文件，过滤<code>.</code>和<code>..</code></li>
<li>输出循环读取到文件的名称</li>
<li>读取完毕后使用<code>closedir</code>关闭目录流</li>
</ol>
<h4 id="4-2-2-实现代码"><a href="#4-2-2-实现代码" class="headerlink" title="4.2.2 实现代码"></a>4.2.2 实现代码</h4><figure class="highlight c"><figcaption><span>ls01.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;dirent.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../helper.h"</span></span></span><br><span class="line"><span class="comment">// sys_err定义在helper.h中，定义如下,后文不再赘述</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">void sys_err(char * s1) &#123;</span></span><br><span class="line"><span class="comment">    perror(s1);</span></span><br><span class="line"><span class="comment">    exit(1);</span></span><br><span class="line"><span class="comment">&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    DIR* dp;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">dirent</span> * <span class="title">sdp</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc == <span class="number">1</span>) dp = opendir(<span class="string">"."</span>);</span><br><span class="line">    <span class="keyword">else</span> dp = opendir(argv[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp == <span class="literal">NULL</span>)</span><br><span class="line">        sys_err(<span class="string">"opendir error"</span>);</span><br><span class="line">    <span class="keyword">while</span> ((sdp = readdir(dp))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(sdp-&gt;d_name, <span class="string">"."</span>) &amp;&amp; <span class="built_in">strcmp</span>(sdp-&gt;d_name, <span class="string">".."</span>))</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">"%s\t"</span>, sdp-&gt;d_name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">    closedir(dp);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-more-命令的实现"><a href="#4-3-more-命令的实现" class="headerlink" title="4.3 more 命令的实现"></a>4.3 more 命令的实现</h3><p><code>more</code>用于分屏查看文件内容，和<code>cat</code>直接打印文件内容有所不同，其可以通过接受键盘输入来逐行、下一屏、回退显示内容，如</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> more cp01.c</span></span><br></pre></td></tr></table></figure>

<h4 id="4-3-1-实现思路"><a href="#4-3-1-实现思路" class="headerlink" title="4.3.1 实现思路"></a>4.3.1 实现思路</h4><p>其工作流程可以用伪代码描述如下</p>
<figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">         open the file</span><br><span class="line">+------&gt; show <span class="number">24</span> lines from input</span><br><span class="line">| +----&gt; print [more?] message</span><br><span class="line">| |      input Enter, SPACE, or q</span><br><span class="line">| +----  <span class="keyword">if</span> Enter, advance one line</span><br><span class="line">+------  <span class="keyword">if</span> SPACE</span><br><span class="line">         <span class="keyword">if</span> q --&gt; <span class="keyword">exit</span>;</span><br></pre></td></tr></table></figure>

<p>即先打开文件，以文件流作为输入，显示一屏幕内容，固定行数如 24 行的内容，然后显示提示“more？”，根据用户的输入来进行下一步操作：若用户键入回车，则获取一行内容，多显示一行；若用户键入空格，则再次获取 24 行内容来显示下一屏幕的内容；若用户键入“q”，则退出程序。</p>
<h4 id="4-3-2-实现版本-1-0"><a href="#4-3-2-实现版本-1-0" class="headerlink" title="4.3.2 实现版本 1.0"></a>4.3.2 实现版本 1.0</h4><p>在这个版本中，将显示内容和接受用户输入的操作作为两个函数<code>do_more()</code>和<code>see_more()</code>来实现。用法将满足第 1 节中的 3 种用法。</p>
<p>在主函数中，先判断是否给定文件参数，有的话，再打开文件，将文件描述符传入<code>do_more()</code>，对每个文件参数执行结束后，关闭文件；<code>do_more()</code>函数将会从文件中读取内容，将其显示，并调用<code>see_more()</code>接受用户阅读内容中输入的参数。</p>
<p>实现代码如下</p>
<figure class="highlight c"><figcaption><span>more1.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGELEN 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINELEN 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_more</span><span class="params">(FILE*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">see_more</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span>* av[])</span> </span>&#123;</span><br><span class="line">    FILE* fd;</span><br><span class="line">    <span class="comment">// 若没有参数则从标准中接受内容，以此接受重定向内容</span></span><br><span class="line">    <span class="keyword">if</span> (ac == <span class="number">1</span>)</span><br><span class="line">        do_more(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="comment">// 显示文件参数中的每一个文件内容</span></span><br><span class="line">        <span class="keyword">while</span> (--ac) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((fd = fopen(*(++av), <span class="string">"r"</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                do_more(fd);</span><br><span class="line">                fclose(fd);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_more</span><span class="params">(FILE* fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[LINELEN];</span><br><span class="line">    <span class="keyword">int</span> num_of_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> reply;</span><br><span class="line">    <span class="comment">// 以行为单位不断从文件流中获取内容</span></span><br><span class="line">    <span class="keyword">while</span> (fgets(<span class="built_in">line</span>, LINELEN, fd)) &#123;</span><br><span class="line">        <span class="comment">// 若已经显示了一屏幕内容，则等待用户键入命令</span></span><br><span class="line">        <span class="keyword">if</span> (num_of_lines == PAGELEN) &#123;</span><br><span class="line">            reply = see_more();</span><br><span class="line">            <span class="keyword">if</span> (reply == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            num_of_lines -= reply;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 逐行显示</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputs</span>(<span class="built_in">line</span>, <span class="built_in">stdout</span>) == EOF) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        num_of_lines += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 显示内容时接受用户命令的函数</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">see_more</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[7mmore?\033[m"</span>);</span><br><span class="line">    <span class="keyword">while</span> ((c = getchar()) != EOF) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'q'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">return</span> PAGELEN;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>但目前该程序存在一个问题，使用其显示重定向的内容会出现问题，如下命令</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">who | ./more1</span><br></pre></td></tr></table></figure>

<p>此时在程序中，将通过标准输入<code>stdin</code>来读取重定向的内容，但在<code>see_more()</code>函数中，同样使用<code>getchar()</code>来从标准输入中读取用户命令，这样显然起了冲突。</p>
<p>解决方法是，从标准输入中读取要显示的内容，然后直接从键盘读取用户输入的命令，见下一节的实现。</p>
<h4 id="4-3-3-实现版本-2-0"><a href="#4-3-3-实现版本-2-0" class="headerlink" title="4.3.3 实现版本 2.0"></a>4.3.3 实现版本 2.0</h4><p>类 Unix 系统中，文件<code>/dev/tty</code>是键盘和显示器的设备描述文件，向这个文件写相当于显示在用户的屏幕上，读相当于从键盘获取用户的输入。即使程序的输入输出被重定向，程序还是可以通过这个文件与终端交换数据。</p>
<p>实现方式很简单，只需要改变<code>see_more()</code>函数，使该函数接受<code>/dev/tty</code>文件流而不是标准输入即可。</p>
<p>代码如下</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> PAGELEN 24</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINELEN 512</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_more</span><span class="params">(FILE*)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">see_more</span><span class="params">(FILE*)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> ac, <span class="keyword">char</span>* av[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (ac == <span class="number">1</span>)</span><br><span class="line">        do_more(<span class="built_in">stdin</span>);</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        FILE* fd;</span><br><span class="line">        <span class="keyword">while</span> (--ac)</span><br><span class="line">            <span class="keyword">if</span> ((fd = fopen(*(++av), <span class="string">"r"</span>)) != <span class="literal">NULL</span>) &#123;</span><br><span class="line">                do_more(fd);</span><br><span class="line">                fclose(fd);</span><br><span class="line">            &#125; <span class="keyword">else</span></span><br><span class="line">                <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">do_more</span><span class="params">(FILE* fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> <span class="built_in">line</span>[LINELEN];</span><br><span class="line">    <span class="keyword">int</span> num_of_lines = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> reply;</span><br><span class="line">    FILE* fd_tty = fopen(<span class="string">"/dev/tty"</span>, <span class="string">"r"</span>);</span><br><span class="line">    <span class="keyword">if</span> (fd_tty == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        perror(<span class="string">"open tty error"</span>);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (fgets(<span class="built_in">line</span>, LINELEN, fd)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (num_of_lines == PAGELEN) &#123;</span><br><span class="line">            reply = see_more(fd_tty);</span><br><span class="line">            <span class="keyword">if</span> (reply == <span class="number">0</span>) <span class="keyword">break</span>;</span><br><span class="line">            num_of_lines -= reply;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">fputs</span>(<span class="built_in">line</span>, <span class="built_in">stdout</span>) == EOF) <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">        num_of_lines += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">see_more</span><span class="params">(FILE* fd_tty)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\033[7m more?\033[m"</span>);</span><br><span class="line">    <span class="keyword">while</span> ((c = getc(fd_tty) != EOF)) &#123;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'q'</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">' '</span>) <span class="keyword">return</span> PAGELEN;</span><br><span class="line">        <span class="keyword">if</span> (c == <span class="string">'\n'</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-4-lseek-的使用"><a href="#4-4-lseek-的使用" class="headerlink" title="4.4 lseek 的使用"></a>4.4 lseek 的使用</h3><p>下面这段展示了如何通过<code>lseek()</code>改变偏移量来先将数据写入，再从头将写入数据读出，以及通过<code>lseek()</code>来改变文件大小的方法</p>
<figure class="highlight c"><figcaption><span>lseek.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt; // strlen</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt; // lseek write</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;  // open</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../helper.h"</span> <span class="comment">// sys_err</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd;</span><br><span class="line">    <span class="keyword">ssize_t</span> n_chars;</span><br><span class="line">    <span class="keyword">char</span> msg[] = <span class="string">"it's a test file for lseek.\n"</span>;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> ((fd = <span class="built_in">open</span>(<span class="string">"testlseek.txt"</span>, O_RDWR | O_CREAT, <span class="number">0644</span>)) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"open error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">write</span>(fd, msg, <span class="built_in">strlen</span>(msg));</span><br><span class="line">    lseek(fd, <span class="number">0</span>, SEEK_SET);	<span class="comment">// 写入数据后偏移量改变，重新设定偏移量再读</span></span><br><span class="line">    <span class="keyword">while</span> ((n_chars = <span class="built_in">read</span>(fd, buf, BUFFSIZE))) &#123;</span><br><span class="line">        <span class="keyword">if</span> (n_chars &lt; <span class="number">0</span>) sys_err(<span class="string">"read error"</span>);</span><br><span class="line">        <span class="built_in">write</span>(STDOUT_FILENO, buf, n_chars);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 通过文件尾部到初始位置的偏移量来获取文件长度</span></span><br><span class="line">    <span class="keyword">off_t</span> filelen = lseek(fd, <span class="number">0</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"file old length is %ld.\n"</span>, filelen);</span><br><span class="line">    filelen = lseek(fd, <span class="number">200</span>, SEEK_END);</span><br><span class="line">    <span class="built_in">write</span>(fd, <span class="string">"\0"</span>, <span class="number">1</span>); <span class="comment">// 需要写入操作才能真正改变文件长度</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"file new length is %ld\n"</span>, (filelen + <span class="number">1</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"Done.\n"</span>);</span><br><span class="line">    <span class="built_in">close</span>(fd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5 结束语"></a>5 结束语</h2><p>本篇文章在先介绍了<code>man</code>手册的用法，这将是之后最常用的查询函数说明的方法；然后主要简单地总结了 Linux 中的文件类型，介绍了文件描述符的原理；接着对文件操作常用的相关函数做了简单记录，对一些要点做了说明；最后通过实现<code>cp</code>和<code>more</code>命令作为两个小 demo，这两个 demo 的代码参照了《Unix\Linux 编程实践教程》一书，这里还补充了<code>lseek()</code>函数的例子。</p>
<p>还有<code>stat()</code>等函数的使用实例将留待后续文章中补充。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 系统编程（一）：C/C++程序编译与gdb调试</title>
    <url>/2020/02/15/apue-hm01/</url>
    <content><![CDATA[<p>程序编译方法和 gdb 调试技巧，严格来说不应该算作 Linux 系统编程的内容，但 Linux 系统编程主要使用 C 语言进行，离不开程序编译、调试的基础，所以将这部分知识作为第一部分的入门知识。</p>
<p>在此仅仅对我所学到的做一个粗略简单的总结。</p>
<h2 id="1-编译基本过程"><a href="#1-编译基本过程" class="headerlink" title="1 编译基本过程"></a>1 编译基本过程</h2><p>C/C++ 程序编译主要有四个步骤</p>
<ul>
<li>预处理：由预处理器完成，生成<code>.i</code>文件；主要做些代码文本替换工作，如展开头文件、展开宏、处理条件编译过滤不必要代码，过滤注释，添加行号和文件名标识，保留<code>#pragma</code>指令，该指令由编译器处理；</li>
<li>编译：由编译器完成，生成<code>.s</code>文件；进行语法、词法分析，检查是否有错，并且根据编译器的不同还会对代码进行不同的优化，在 gcc 中优化的级别可以设定，最后翻译成汇编语言；</li>
<li>汇编：由汇编器完成，生成<code>.o</code>文件；将汇编语言翻译成目标机器指令，目标文件由段组成，至少包含代码段和数据段；</li>
<li>链接：由链接器完成，一般生成<code>.out</code>格式，在 Linux 中无所谓；将目标文件与其他使用到的函数的源文件、库进行链接，生成二进制可执行文件；</li>
</ul>
<h2 id="2-gcc-g-编译指令"><a href="#2-gcc-g-编译指令" class="headerlink" title="2 gcc/g++ 编译指令"></a>2 gcc/g++ 编译指令</h2><p>gcc 和 g++都能编译 C/C++代码，仅仅稍有区别</p>
<ul>
<li>对于文件<strong>后缀为.c</strong>的，gcc 把它当成是<strong>C 程序</strong>，而 g++当作是<strong>C++程序</strong>；后缀为.cpp 的，两者都会认为是<strong>C++程序</strong>。（两者语法不完全一样）</li>
<li><strong>编译阶段，g++会调用 gcc</strong>，对于 C++代码，两者是等价的，<strong>但是因为 gcc 命令不能自动和 C ＋＋程序使用的库联接，所以通常用 g++来完成链接</strong></li>
<li>对于<strong>__cplusplus 宏</strong>，实际上，这个宏只是标志着编译器将会把代码按 C 还是 C++语法来解释，如上所述，<strong>如果后缀为.c，并且采用 GCC 编译器，则该宏就是未定义的，否则，就是已定义</strong>。</li>
</ul>
<p>上述规则看似有点绕，反正我的习惯就是 C 用<code>gcc</code>，C++用<code>g++</code>，肯定不会错。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 预处理指令，-o选项用于命名</span></span><br><span class="line">gcc -E file.c -o file.i</span><br><span class="line"><span class="meta">#</span><span class="bash"> 编译指令</span></span><br><span class="line">gcc -S file.i -o file.s</span><br><span class="line"><span class="meta">#</span><span class="bash"> 汇编指令</span></span><br><span class="line">gcc -c file.s -o file.o</span><br><span class="line">gcc -c file1.c -o file1.o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 链接指令</span></span><br><span class="line">gcc -o file.o file1.o -o file.out</span><br><span class="line"><span class="meta">#</span><span class="bash"> 显示所有警告信息</span></span><br><span class="line">gcc -o file.o file1.o -o file.out -Wall</span><br><span class="line"><span class="meta">#</span><span class="bash"> 向程序中注册宏定义</span></span><br><span class="line">gcc -o file.o file1.o -o file.out -D DEBUG</span><br></pre></td></tr></table></figure>

<h2 id="3-静态库制作和使用"><a href="#3-静态库制作和使用" class="headerlink" title="3 静态库制作和使用"></a>3 静态库制作和使用</h2><p>所谓静态和动态，是指链接过程是静态的还是动态的。</p>
<p>程序在与静态库链接时， 会将汇编生成的目标文件.o 与引用到的库一起链接打包到可执行文件中。因此对应的链接方式称为静态链接。</p>
<p>故而静态库类似于汇编生成的<code>.o</code>目标文件，其特点如下</p>
<ul>
<li>静态库对函数库的链接是放在编译时期完成的。</li>
<li>程序在运行时与函数库再无瓜葛，移植方便。</li>
<li>浪费空间和资源，因为所有相关的目标文件与牵涉到的函数库被链接合成一个可执行文件。</li>
<li>静态库更新，程序需要重新编译进行<strong>全量更新</strong></li>
</ul>
<h3 id="3-1-静态库制作"><a href="#3-1-静态库制作" class="headerlink" title="3.1 静态库制作"></a>3.1 静态库制作</h3><p>静态库命名和格式有固定规则，命名必须以<code>lib</code>开头，格式一般为<code>.a</code>或<code>.lib</code></p>
<p>以加减乘除为例，先写一个<code>.c</code>文件</p>
<figure class="highlight c"><figcaption><span>mymath.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>再写一个头文件</p>
<figure class="highlight c"><figcaption><span>mymath.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MYMATH_H_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYMATH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYMATH_H_</span></span></span><br></pre></td></tr></table></figure>

<p>然后开始制作静态库</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 首先生成源代码的目标文件</span></span><br><span class="line">gcc -c mymath.c -o mymath.o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用ar工具制作静态库</span></span><br><span class="line">ar rcs libmymath.lib mymath.o</span><br></pre></td></tr></table></figure>

<p>至此文件目录下就多出<code>libmymath.lib</code>静态库文件了。</p>
<h3 id="3-2-使用静态库"><a href="#3-2-使用静态库" class="headerlink" title="3.2 使用静态库"></a>3.2 使用静态库</h3><p>写一个 C 文件</p>
<figure class="highlight c"><figcaption><span>testlib.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mymath.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">6</span>, b =<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a + b = %d\n"</span>, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a - b = %d\n"</span>, sub(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a * b = %d\n"</span>, mul(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a / b = %d\n"</span>, div(a, b));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将此文件与静态库一起编译、链接</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testlib.c libmymath.lib -o testlib.out</span><br></pre></td></tr></table></figure>

<p>然后运行生成的可执行文件</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> ./testlib.out</span></span><br><span class="line">a + b = 8</span><br><span class="line">a - b = 4</span><br><span class="line">a * b = 12</span><br><span class="line">a / b = 3</span><br></pre></td></tr></table></figure>

<h2 id="4-动态库制作和使用"><a href="#4-动态库制作和使用" class="headerlink" title="4 动态库制作和使用"></a>4 动态库制作和使用</h2><p>动态库在程序编译时并不会被连接到目标代码中，而是在程序运行是才被载入。<strong>不同的应用程序如果调用相同的库，那么在内存里只需要有一份该共享库的实例</strong>，规避了空间浪费问题。动态库在程序运行是才被载入，也解决了静态库对程序的更新、部署和发布页会带来麻烦。用户只需要更新动态库即可，<strong>增量更新</strong>。</p>
<p>动态库又称为分享库，其特点如下</p>
<ul>
<li><p>动态库把对一些库函数的链接载入推迟到程序运行的时期。</p>
</li>
<li><p>可以实现进程之间的资源共享。（因此动态库也称为共享库）</p>
</li>
<li><p>将一些程序升级变得简单。</p>
</li>
<li><p>甚至可以真正做到链接载入完全由程序员在程序代码中控制（<strong>显示调用</strong>）。</p>
</li>
</ul>
<p>不同平台下制作动态库有些差异</p>
<ul>
<li><p>在 Windows 系统下的执行文件格式是 PE 格式，动态库需要一个<strong>DllMain</strong>函数做出初始化的入口，通常在导出函数的声明时需要有_declspec(dllexport)关键字。</p>
</li>
<li><p>Linux 下 gcc 编译的执行文件默认是 ELF 格式，<strong>不需要初始化入口，亦不需要函数做特别的声明，</strong>编写比较方便。</p>
</li>
</ul>
<h3 id="4-1-动态库的制作"><a href="#4-1-动态库的制作" class="headerlink" title="4.1 动态库的制作"></a>4.1 动态库的制作</h3><p>动态库的制作比静态库简单，无需使用<code>ar</code>进行打包。</p>
<p>同样以加减乘除的 C 代码为例</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用两条指令</span></span><br><span class="line">gcc -fPIC -c mymath.c</span><br><span class="line">gcc -shared -o libDynMymath.so mymath.o</span><br><span class="line"><span class="meta">#</span><span class="bash"> 或者合并为一条指令</span></span><br><span class="line">gcc -fPIC -shared -o libDynMymath.so mymath.c</span><br></pre></td></tr></table></figure>

<h3 id="4-2-动态库的使用"><a href="#4-2-动态库的使用" class="headerlink" title="4.2 动态库的使用"></a>4.2 动态库的使用</h3><p>由于刚才生成的动态库在当前目录下，不在系统默认的动态库路径中，所以使用前需要先将动态库路径的环境变量声明为当前目录，或者将制作的动态库移动到默认的动态库路径。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 声明环境变量</span></span><br><span class="line">export LD_LIBRARY_PATH=~/cppunp/hmunp</span><br><span class="line"><span class="meta">#</span><span class="bash"> 与动态库链接，注意-L参数后带动态库路径</span></span><br><span class="line">gcc testlib.c -o testdynlib.out -lDynMymath   -L../hmunp/</span><br><span class="line"><span class="meta">#</span><span class="bash"> 执行生成程序</span></span><br><span class="line">./testdynlib.out</span><br><span class="line">a + b = 8</span><br><span class="line">a - b = 4</span><br><span class="line">a * b = 12</span><br><span class="line">a / b = 3</span><br></pre></td></tr></table></figure>

<h2 id="5-makefile-的编写"><a href="#5-makefile-的编写" class="headerlink" title="5 makefile 的编写"></a>5 makefile 的编写</h2><p>在一个 C/C++ 项目中，通常一个程序需要多个文件来进行编译完成，使用<code>gcc</code>指令来生成所有目标文件、再链接生成程序，未免过于繁琐，而且在对项目文件进行修改后，每次使用<code>gcc</code>指令重新编译也非常麻烦、耗时。</p>
<p>而<code>makefile</code>文件可以大大简化这一过程，几乎一劳永逸，书写完成后即使项目结构发生很大变化，也仅需要做很小的更改，甚至无需更改。</p>
<p>另外每次使用<code>makefile</code>来对项目进行编译时，其仅会对更改过的文件重新生成目标文件，大大降低了程序总编译时间。</p>
<h3 id="5-1-所使用的示例代码"><a href="#5-1-所使用的示例代码" class="headerlink" title="5.1 所使用的示例代码"></a>5.1 所使用的示例代码</h3><p>这里同样以加减乘除的程序作为示例，但是将加减乘除分为四个 c 文件。如下</p>
<figure class="highlight c"><figcaption><span>add.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>sub.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>mul.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a * b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c"><figcaption><span>div.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a / b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后将四个函数声明放入一个头文件</p>
<figure class="highlight c"><figcaption><span>mymath.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">if</span> !defined(MYMATH_H_)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MYMATH_H_</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">sub</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mul</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">div</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// MYMATH_H_</span></span></span><br></pre></td></tr></table></figure>

<p>再写一个主程序测试函数</p>
<figure class="highlight c"><figcaption><span>main.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"mymath.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = <span class="number">10</span>, b = <span class="number">2</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a + b = %d\n"</span>, add(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a - b = %d\n"</span>, sub(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a * b = %d\n"</span>, mul(a, b));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"a / b = %d\n"</span>, div(a, b));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果直接使用<code>gcc</code>命令来编译链接生成程序的话，我们需要以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">gcc -c add.c sub.c mul.c div.c</span><br><span class="line">gcc main.c add.o sub.o mul.o div.o -o main.out</span><br></pre></td></tr></table></figure>

<p>然后测试一下生成的主程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">./main.out</span><br><span class="line">a + b = 12</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 20</span><br><span class="line">a / b = 5</span><br></pre></td></tr></table></figure>

<h3 id="5-2-makefile-的基本规则"><a href="#5-2-makefile-的基本规则" class="headerlink" title="5.2 makefile 的基本规则"></a>5.2 makefile 的基本规则</h3><p><code>makefile</code>类似于<code>shell</code>脚本，可以使用<code>shell</code>函数、语法以及通配符。</p>
<p><code>makefile</code>的规则包含两个部分，一个是依赖关系，一个是生成目标的方法即对应指令。</p>
<p>在<code>makefile</code>中，规则的顺序是很重要的，因为，<code>makefile</code>中只应该有一个最终目标，其它的目标都是被这 个目标所连带出来的，所以一定要让<code>make</code>知道你的最终目标是什么。一般来说，定义在<code>makefile</code>中的目标 可能会有很多，但是第一条规则中的目标将被确立为最终的目标。如果第一条规则中的目标有很多个，那么 ，第一个目标会成为最终的目标。make 所完成的也就是这个目标。</p>
<p>基本格式如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># ALL 指定最终生成的程序</span></span><br><span class="line"><span class="section">ALL:hello.out</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 冒号左边是目标文件，右边是依赖文件</span></span><br><span class="line"><span class="comment"># 下一行一个Tab后书写对应命令</span></span><br><span class="line"><span class="section">hello.out:hello.o</span></span><br><span class="line">	gcc hello.o -o hello.out</span><br><span class="line"></span><br><span class="line"><span class="section">hello.o:hello.c</span></span><br><span class="line">	gcc -c hello.c -o hello.o</span><br><span class="line"></span><br><span class="line"><span class="comment"># make clean 指令将会执行的指令</span></span><br><span class="line"><span class="comment"># 第一个'-'表示删除不存在的文件不报错</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf *.o *.out</span><br></pre></td></tr></table></figure>

<p>根据基本格式，我们可以用示例代码写一个最基础的<code>makefile</code>文件</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="section">ALL:main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main:main.o add.o sub.o mul.o div.o</span></span><br><span class="line">	gcc main.o add.o sub.o mul.o div.o -o main</span><br><span class="line"></span><br><span class="line"><span class="section">mian.o:mian.c</span></span><br><span class="line">	gcc -c main.c -o main.o</span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c add.c -o add.o</span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c sub.c -o sub.o</span><br><span class="line"></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">	gcc -c mul.c -o mul.o</span><br><span class="line"></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">	gcc -c div.c -o div.o</span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf *.o *.out main</span><br></pre></td></tr></table></figure>

<p>由于之前已经用<code>gcc</code>命令编译过一次，所以先执行<code>make clean</code>将之前生成的目标文件和主程序删除，再执行<code>make</code>使用<code>makefile</code>文件规则进行编译</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> make clean</span></span><br><span class="line">rm -rf *.o *.out main</span><br><span class="line"><span class="meta">$</span><span class="bash"> make</span></span><br><span class="line">cc    -c -o main.o main.c</span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line">gcc main.o add.o sub.o mul.o div.o -o main</span><br><span class="line"><span class="meta">$</span><span class="bash"> ./main</span></span><br><span class="line">a + b = 12</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 20</span><br><span class="line">a / b = 5</span><br></pre></td></tr></table></figure>

<p>可见这个最基础的<code>makefile</code>文件已经奏效。</p>
<h3 id="5-3-加入-shell-函数和自动变量"><a href="#5-3-加入-shell-函数和自动变量" class="headerlink" title="5.3 加入 shell 函数和自动变量"></a>5.3 加入 shell 函数和自动变量</h3><p>显然，如果一个项目中文件很多的话，上面的<code>makefile</code>文件将会变得极其冗长，光依赖文件就要写很长一串，这显然很不方便。</p>
<p>可以引入两个<code>shell</code>函数</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 将./目录下所有.c文件的文件名组成列表，然后赋值给src变量</span></span><br><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 将参数3的src中所有符合参数1匹配规则的文件替换为参数2的格式，得到的新列表复制给obj变量</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %c, %.o, <span class="variable">$(src)</span>)</span></span><br></pre></td></tr></table></figure>

<p>再介绍 3 个自动变量</p>
<ul>
<li><code>$@</code>：用于表示目标</li>
<li><code>$^</code>：用于表示所有依赖条件</li>
<li><code>$&lt;</code>：用于表示第一个依赖条件，还可以将依赖条件从依赖列表中依次取出</li>
</ul>
<p>在<code>makefile</code>中的应用如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"><span class="comment"># main.o 不生成也无妨，链接时会自动生成</span></span><br><span class="line"><span class="section">mian.o:mian.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">add.o:add.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">sub.o:sub.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">mul.o:mul.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">div.o:div.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure>

<p>这个版本在命名上取得了一定简化，但依然有大量类似代码来生成各种目标文件，实际上这部分类似代码可以使用<code>%.o:%.c</code>的规则来简化。优化如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> %.c, %.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line"><span class="section">ALL:main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">%.o:%.c</span></span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> main</span><br></pre></td></tr></table></figure>

<p>这样就简单很多了，依然在 shell 中测试一下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">$ make clean</span><br><span class="line">rm -rf  ./mul.o  ./main.o  ./add.o  ./div.o  ./sub.o main</span><br><span class="line">$ make</span><br><span class="line">gcc -c mul.c -o mul.o</span><br><span class="line">gcc -c main.c -o main.o</span><br><span class="line">gcc -c add.c -o add.o</span><br><span class="line">gcc -c div.c -o div.o</span><br><span class="line">gcc -c sub.c -o sub.o</span><br><span class="line">gcc mul.o main.o add.o div.o sub.o -o main</span><br><span class="line">$ ./main</span><br><span class="line">a + b = 12</span><br><span class="line">a - b = 8</span><br><span class="line">a * b = 20</span><br><span class="line">a / b = 5</span><br></pre></td></tr></table></figure>

<h3 id="5-4-源代码在子文件夹时的优化"><a href="#5-4-源代码在子文件夹时的优化" class="headerlink" title="5.4 源代码在子文件夹时的优化"></a>5.4 源代码在子文件夹时的优化</h3><p>之前所有的源文件、头文件以及<code>makefile</code>文件都在同一个文件夹里，在实际中更常见的情况应该是源文件、头文件都放在不同的文件夹中，而<code>makefile</code>文件则在根目录下。并且有时也需要加入或更改一些编译的参数如<code>-Wall</code>和用于调试的<code>-g</code>等。这里根据该种情况对<code>makefile</code>文件进行优化。</p>
<p>假如所有.c 文件都放入<code>src</code>的子文件夹，所有头文件都放入<code>inc</code>的子文件夹，然后新建一个<code>obj</code>文件用以存放生成的目标文件。结构如下</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> tree</span></span><br><span class="line">.</span><br><span class="line">├── inc</span><br><span class="line">│   └── mymath.h</span><br><span class="line">├── makefile</span><br><span class="line">├── obj</span><br><span class="line">└── src</span><br><span class="line">    ├── add.c</span><br><span class="line">    ├── div.c</span><br><span class="line">    ├── main.c</span><br><span class="line">    ├── mul.c</span><br><span class="line">    └── sub.c</span><br></pre></td></tr></table></figure>

<p>源文件的路径变化，只需在<code>makefile</code>文件中修改<code>wildcard</code>和<code>patsubst</code>函数的参数即可；由于头文件也更改了路径，在主程序中不做修改的话，则需在生成目标文件时指定头文件目录，所以需要一个变量来保存头文件路径；关于编译参数<code>-Wall</code>和<code>-g</code>，为了方便修改，也将其定义为一个变量。</p>
<p>优化后如下</p>
<figure class="highlight makefile"><table><tr><td class="code"><pre><span class="line">src = <span class="variable">$(<span class="built_in">wildcard</span> ./src/*.c)</span></span><br><span class="line">obj = <span class="variable">$(<span class="built_in">patsubst</span> ./src%.c, ./obj/%.o, <span class="variable">$(src)</span>)</span></span><br><span class="line"></span><br><span class="line">inc_path = ./inc</span><br><span class="line">myArgs = -Wall -g</span><br><span class="line"></span><br><span class="line"><span class="section">ALL:main</span></span><br><span class="line"></span><br><span class="line"><span class="section">main:<span class="variable">$(obj)</span></span></span><br><span class="line">	gcc <span class="variable">$^</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span></span><br><span class="line"></span><br><span class="line"><span class="variable">$(obj)</span>:./obj/%.o:./src/%.c</span><br><span class="line">	gcc -c <span class="variable">$&lt;</span> -o <span class="variable">$@</span> <span class="variable">$(myArgs)</span> -I <span class="variable">$(inc_path)</span></span><br><span class="line"></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">	-rm -rf <span class="variable">$(obj)</span> main</span><br><span class="line"><span class="comment"># 伪目标，防止有生成名为clean的文件后，make clean指令失效</span></span><br><span class="line"><span class="meta"><span class="meta-keyword">.PHONY</span>:clean</span></span><br></pre></td></tr></table></figure>

<p>注意文件中关于伪目标的注释。</p>
<p>还有一种情况就是同一个项目有时需要使用不同的<code>makefile</code>规则来进行测试或适应不同的环境，那么可以在使用<code>make</code>指令时加上<code>-f</code>选项，后面再接指定的<code>makefile</code>文件名。如新建一个<code>makefile</code>文件，将其命名为<code>make_ubuntu</code>，</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">make -f make_ubuntu</span><br></pre></td></tr></table></figure>

<h2 id="6-GDB-调试基础"><a href="#6-GDB-调试基础" class="headerlink" title="6 GDB 调试基础"></a>6 GDB 调试基础</h2><p>GDB, 是 The GNU Project Debugger 的缩写, 是 Linux 下功能全面的调试工具。GDB 支持断点、单步执行、打印变量、观察变量、查看寄存器、查看堆栈等调试手段。在 Linux 环境软件开发中，GDB 是主要的调试工具，用来调试 C 和 C++ 程序。</p>
<p>实际上，一般调试程序都会借助一些 IDEA 或者编辑器上的插件，比如我之前都是用 VScode 进行配置后来调试的。</p>
<p>虽然直接使用 GDB 的情况并不多，但了解一些基本指令和方法还是有一些帮助的。在此对 GDB 的一些调试指令做一个简单的总结记录。</p>
<h3 id="6-1-GDB-使用方法"><a href="#6-1-GDB-使用方法" class="headerlink" title="6.1 GDB 使用方法"></a>6.1 GDB 使用方法</h3><p>在使用 GDB 调试前，要<strong>保证生成的程序包含调试信息</strong>，也就是说在使用 gcc 进行编译生成程序时，<strong>必须要加<code>-g</code>参数</strong>来生成调试信息。</p>
<p>这里使用一个简单的示例程序</p>
<figure class="highlight c"><figcaption><span>testgdb.c</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="comment">// 使用随机数初始化数组</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_arr</span><span class="params">(<span class="keyword">int</span>* arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        arr[i] = rand() % <span class="number">20</span> + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数组进行打印输出</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">print_arr</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"arr: "</span>);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"%d "</span>, arr[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"\n"</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 将数组进行选择排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="keyword">int</span> *arr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i, j, k, tmp;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; len - <span class="number">1</span>; ++i) &#123;</span><br><span class="line">        k = i;</span><br><span class="line">        <span class="keyword">for</span> (j = i + <span class="number">1</span>; j &lt; len; ++j) &#123;</span><br><span class="line">            <span class="keyword">if</span> (arr[k] &gt; arr[j])</span><br><span class="line">                k = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( i != k) &#123;</span><br><span class="line">            tmp = arr[i];</span><br><span class="line">            arr[i] = arr[k];</span><br><span class="line">            arr[k] = tmp;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> arr[<span class="number">20</span>];</span><br><span class="line">    <span class="keyword">char</span> *p = <span class="string">"hello"</span>;</span><br><span class="line"></span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    init_arr(arr, <span class="number">20</span>);</span><br><span class="line">    print_arr(arr, <span class="number">20</span>);</span><br><span class="line">    select_sort(arr, <span class="number">20</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"------------after sort-----------\n"</span>);</span><br><span class="line">    print_arr(arr, <span class="number">20</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用 gcc 来编译程序</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gcc testgdb.c -o test -g</span><br></pre></td></tr></table></figure>

<p>然后进入 gdb 命令界面</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">gdb test</span><br><span class="line">GNU gdb (Ubuntu 8.1-0ubuntu3.2) 8.1.0.20180409-git</span><br><span class="line">Copyright (C) 2018 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later</span><br><span class="line">...省略n行</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure>

<p>在 gdb 命令行界面，<strong>输入 run 执行待调试程序</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br></pre></td></tr></table></figure>

<p>在 gdb 命令行界面，<strong>输入 quit 退出 gdb</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) quit</span><br></pre></td></tr></table></figure>

<p>在 gdb 命令行界面，<strong>使用 (gdb) help command 可以查看命令的用法</strong>。</p>
<p>在 gdb 命令行界面可以<strong>执行外部的 Shell 命令</strong>：</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">(gdb) !shell 命令</span><br></pre></td></tr></table></figure>

<p>例如查看当前目录的文件：</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) !ls</span><br><span class="line">test  testgdb.c</span><br></pre></td></tr></table></figure>

<h3 id="6-2-GDB-常用指令"><a href="#6-2-GDB-常用指令" class="headerlink" title="6.2 GDB 常用指令"></a>6.2 GDB 常用指令</h3><h4 id="list-l-查看源代码"><a href="#list-l-查看源代码" class="headerlink" title="list/l 查看源代码"></a>list/l 查看源代码</h4><p>使用<code>list 1</code>从第一行列出源代码，数字可以更改</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) list 1</span><br><span class="line">1       #include &lt;time.h&gt;</span><br><span class="line">2       #include &lt;stdlib.h&gt;</span><br><span class="line">3       #include &lt;stdio.h&gt;</span><br><span class="line">4</span><br><span class="line">5       void init_arr(int* arr, int len) &#123;</span><br><span class="line">6           for(int i = 0; i &lt; len; ++i)</span><br><span class="line">7               arr[i] = rand() % 20 + 1;</span><br><span class="line">8       &#125;</span><br><span class="line">9</span><br><span class="line">10      void print_arr(int *arr, int len) &#123;</span><br></pre></td></tr></table></figure>

<p>继续输入<code>list</code>或<code>l</code>可以继续显示剩下的代码</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) l</span><br><span class="line">11          printf("arr: ");</span><br><span class="line">12          for (int i = 0; i &lt; len; ++i)</span><br><span class="line">13              printf("%d ", arr[i]);</span><br><span class="line">14          printf("\n");</span><br><span class="line">15      &#125;</span><br><span class="line">16</span><br><span class="line">17      void select_sort(int *arr, int len) &#123;</span><br><span class="line">18          int i, j, k, tmp;</span><br><span class="line">19          for (i = 0; i &lt; len - 1; ++i) &#123;</span><br><span class="line">20              k = i;</span><br></pre></td></tr></table></figure>

<h4 id="break-b-设置断点"><a href="#break-b-设置断点" class="headerlink" title="break/b 设置断点"></a>break/b 设置断点</h4><p>使用<code>break</code>或<code>b</code>设置断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) break 38</span><br><span class="line">Breakpoint 1 at 0xa07: file testgdb.c, line 38.</span><br><span class="line">(gdb) b 40</span><br><span class="line">Breakpoint 2 at 0xa29: file testgdb.c, line 40.</span><br></pre></td></tr></table></figure>

<p>所设置的断点可以使用<code>info b</code>来查看。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) info b</span><br><span class="line">Num     Type           Disp Enb Address            What</span><br><span class="line">1       breakpoint     keep y   0x0000000008000a43 in main at testgdb.c:38</span><br><span class="line">2       breakpoint     keep y   0x0000000008000a65 in main at testgdb.c:40</span><br></pre></td></tr></table></figure>

<p>还可以设置条件断点</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) b 20 if i = 5</span><br><span class="line">Breakpoint 3 at 0x8000904: file testgdb.c, line 20.</span><br></pre></td></tr></table></figure>

<h4 id="run-r-运行程序"><a href="#run-r-运行程序" class="headerlink" title="run/r 运行程序"></a>run/r 运行程序</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/choupin/cppunp/hmapue/day02/test</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at testgdb.c:38</span><br><span class="line">38          init_arr(arr, 20);</span><br></pre></td></tr></table></figure>

<h4 id="next-n-运行至下一语句"><a href="#next-n-运行至下一语句" class="headerlink" title="next/n 运行至下一语句"></a>next/n 运行至下一语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) next</span><br><span class="line">39          print_arr(arr, 20);</span><br><span class="line">(gdb) next</span><br><span class="line">arr: 14 8 11 3 16 15 12 16 13 20 8 20 4 11 10 2 8 2 13 4</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at testgdb.c:40</span><br><span class="line">40          select_sort(arr, 20);</span><br></pre></td></tr></table></figure>

<h4 id="step-s-单步调试"><a href="#step-s-单步调试" class="headerlink" title="step/s 单步调试"></a>step/s 单步调试</h4><p>单步调试遇到函数调用，将会进入函数，逐句执行</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">arr: 16 17 19 17 17 9 15 1 6 12 4 8 16 19 2 12 20 7 20 15</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main () at testgdb.c:40</span><br><span class="line">40          select_sort(arr, 20);</span><br><span class="line"><span class="meta">#</span><span class="bash"> 接上一步</span></span><br><span class="line">(gdb) s</span><br><span class="line">select_sort (arr=0x7ffffffedc50, len=20) at testgdb.c:19</span><br><span class="line">19          for (i = 0; i &lt; len - 1; ++i) &#123;</span><br><span class="line">(gdb) s</span><br><span class="line">20              k = i;</span><br><span class="line">(gdb) step</span><br><span class="line">21              for (j = i + 1; j &lt; len; ++j) &#123;</span><br></pre></td></tr></table></figure>

<h4 id="print-p-查看变量的值"><a href="#print-p-查看变量的值" class="headerlink" title="print/p 查看变量的值"></a>print/p 查看变量的值</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) p i</span><br><span class="line"><span class="meta">$</span><span class="bash">1 = 0</span></span><br><span class="line">(gdb) p j</span><br><span class="line"><span class="meta">$</span><span class="bash">2 = 32767</span></span><br><span class="line">(gdb) s</span><br><span class="line">22                  if (arr[k] &gt; arr[j])</span><br><span class="line">(gdb) p j</span><br><span class="line"><span class="meta">$</span><span class="bash">3 = 1</span></span><br></pre></td></tr></table></figure>

<h4 id="finish-结束当前函数调用"><a href="#finish-结束当前函数调用" class="headerlink" title="finish 结束当前函数调用"></a>finish 结束当前函数调用</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) finish</span><br><span class="line">Run till exit from #0  select_sort (arr=0x7ffffffedc50, len=20)</span><br><span class="line">    at testgdb.c:21</span><br><span class="line">main () at testgdb.c:41</span><br><span class="line">41          printf("------------after sort-----------\n");</span><br><span class="line">(gdb) p arr</span><br><span class="line"><span class="meta">$</span><span class="bash">5 = &#123;1, 2, 4, 6, 7, 8, 9, 12, 12, 15, 15, 16, 16, 17, 17, 17,</span></span><br><span class="line">  19, 19, 20, 20&#125;</span><br></pre></td></tr></table></figure>

<h4 id="continue-继续执行断点后续语句"><a href="#continue-继续执行断点后续语句" class="headerlink" title="continue 继续执行断点后续语句"></a>continue 继续执行断点后续语句</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) continue</span><br><span class="line">Continuing.</span><br><span class="line">------------after sort-----------</span><br><span class="line">arr: 1 2 4 6 7 8 9 12 12 15 15 16 16 17 17 17 19 19 20 20</span><br><span class="line">[Inferior 1 (process 5646) exited normally]</span><br></pre></td></tr></table></figure>

<h3 id="6-3-GDB-其他指令"><a href="#6-3-GDB-其他指令" class="headerlink" title="6.3 GDB 其他指令"></a>6.3 GDB 其他指令</h3><h4 id="设置-main-函数命令行参数"><a href="#设置-main-函数命令行参数" class="headerlink" title="设置 main 函数命令行参数"></a>设置 main 函数命令行参数</h4><p>进行 gdb 命令行后，可以有两种方法设置<code>main</code>函数的命令行参数。</p>
<p>先修改一下源文件</p>
<figure class="highlight diff"><table><tr><td class="code"><pre><span class="line"><span class="deletion">-int main() &#123;</span></span><br><span class="line"><span class="addition">+int main(int argc, char *argv[]) &#123;</span></span><br><span class="line"><span class="addition">+    printf("%s %s %s\n", argv[1], argv[2], argv[3]);</span></span><br><span class="line">    int arr[20];</span><br><span class="line">    char *p = "hello";</span><br><span class="line">    srand(time(NULL));</span><br><span class="line">    init_arr(arr, 20);</span><br><span class="line">    print_arr(arr, 20);</span><br><span class="line">    select_sort(arr, 20);</span><br><span class="line">    printf("------------after sort-----------\n");</span><br><span class="line">    print_arr(arr, 20);</span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>重新编译生成程序，再进入 gdb。</p>
<p>第一种，在<code>run</code>之前使用<code>set args</code>设置参数，再<code>run</code>或<code>start</code></p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) set args aa bb cc</span><br><span class="line">(gdb) run</span><br><span class="line">Starting program: /home/choupin/cppunp/hmapue/day02/test aa bb cc</span><br><span class="line">aa bb cc</span><br><span class="line">arr: 18 17 9 13 1 16 8 7 18 5 3 11 2 15 16 16 16 1 10 12</span><br><span class="line">------------after sort-----------</span><br><span class="line">arr: 1 1 2 3 5 7 8 9 10 11 12 13 15 16 16 16 16 17 18 18</span><br><span class="line">[Inferior 1 (process 5818) exited normally]</span><br></pre></td></tr></table></figure>

<p>第二种，在<code>run</code>的时候直接加所需要的参数</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) run aa bb cc</span><br><span class="line">Starting program: /home/choupin/cppunp/hmapue/day02/test aa bb cc</span><br><span class="line">aa bb cc</span><br><span class="line">arr: 15 4 19 7 17 19 6 2 12 18 6 6 9 15 20 9 12 15 5 1</span><br><span class="line">------------after sort-----------</span><br><span class="line">arr: 1 2 4 5 6 6 6 7 9 9 12 12 15 15 15 17 18 19 19 20</span><br><span class="line">[Inferior 1 (process 5822) exited normally]</span><br></pre></td></tr></table></figure>

<h4 id="ptype-查看变量类型"><a href="#ptype-查看变量类型" class="headerlink" title="ptype 查看变量类型"></a>ptype 查看变量类型</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) ptype arr</span><br><span class="line">type = int [20]</span><br></pre></td></tr></table></figure>

<h4 id="backtrace-bt-列出当前程序正在存活的栈帧"><a href="#backtrace-bt-列出当前程序正在存活的栈帧" class="headerlink" title="backtrace/bt 列出当前程序正在存活的栈帧"></a>backtrace/bt 列出当前程序正在存活的栈帧</h4><p>先<code>next</code>到<code>select_sort()</code>函数，然后<code>step</code>进入，再使用<code>bt</code>查看当前栈帧</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) n</span><br><span class="line">arr: 5 12 1 18 4 7 18 13 1 9 3 16 7 16 1 20 4 8 8 15</span><br><span class="line"></span><br><span class="line">Breakpoint 2, main (argc=4, argv=0x7ffffffedd78) at testgdb.c:40</span><br><span class="line">40          select_sort(arr, 20);</span><br><span class="line">(gdb) s</span><br><span class="line">select_sort (arr=0x7ffffffedc30, len=20) at testgdb.c:19</span><br><span class="line">19          for (i = 0; i &lt; len - 1; ++i) &#123;</span><br><span class="line">(gdb) bt</span><br><span class="line"><span class="meta">#</span><span class="bash">0  select_sort (arr=0x7ffffffedc30, len=20) at testgdb.c:19</span></span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x0000000008000a76 <span class="keyword">in</span> main (argc=4, argv=0x7ffffffedd78) at testgdb.c:40</span></span><br></pre></td></tr></table></figure>

<h4 id="frame-切换栈帧"><a href="#frame-切换栈帧" class="headerlink" title="frame 切换栈帧"></a>frame 切换栈帧</h4><p>切换栈帧需要知道当前栈帧的编号</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) frame 0</span><br><span class="line"><span class="meta">#</span><span class="bash">0  select_sort (arr=0x7ffffffedc30, len=20) at testgdb.c:19</span></span><br><span class="line">19          for (i = 0; i &lt; len - 1; ++i) &#123;</span><br><span class="line">(gdb) frame 1</span><br><span class="line"><span class="meta">#</span><span class="bash">1  0x0000000008000a76 <span class="keyword">in</span> main (argc=4, argv=0x7ffffffedd78) at testgdb.c:40</span></span><br><span class="line">40          select_sort(arr, 20);</span><br></pre></td></tr></table></figure>

<h4 id="display-undisplay-设置或取消跟踪变量"><a href="#display-undisplay-设置或取消跟踪变量" class="headerlink" title="display/undisplay 设置或取消跟踪变量"></a>display/undisplay 设置或取消跟踪变量</h4><p>使用<code>display</code>可以设置需要跟踪的变量，之后再使用<code>run</code>，将会在每一步展示设置后的变量，变量前是展示的编号，可以使用<code>display</code>加编号来取消。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">(gdb) display arr</span><br><span class="line">3: arr = (int *) 0x7ffffffedc30</span><br><span class="line">(gdb) run</span><br><span class="line">The program being debugged has been started already.</span><br><span class="line">Start it from the beginning? (y or n) y</span><br><span class="line">Starting program: /home/choupin/cppunp/hmapue/day02/test aa bb cc</span><br><span class="line">aa bb cc</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main (argc=4, argv=0x7ffffffedd78) at testgdb.c:38</span><br><span class="line">38          init_arr(arr, 20);</span><br><span class="line">1: arr = &#123;9, 0, -12573088, 32767, -74584, 32767, 15775231, 0, 1, 0, 134220541, 0,</span><br><span class="line">  -12514912, 32767, 0, 0, 134220464, 0, 134219536, 0&#125;</span><br><span class="line">(gdb) n</span><br><span class="line">39          print_arr(arr, 20);</span><br><span class="line">1: arr = &#123;19, 6, 14, 16, 17, 17, 13, 9, 16, 17, 3, 11, 3, 18, 10, 10, 4, 2, 1, 16&#125;</span><br><span class="line">(gdb) undisplay 1</span><br></pre></td></tr></table></figure>

<h3 id="7-结束语"><a href="#7-结束语" class="headerlink" title="7 结束语"></a>7 结束语</h3><p>本篇文章从介绍 C/C++ 程序最基本的编译链接过程开始，接着介绍了 Linux 平台下使用<code>gcc</code>编译程序的基本指令，以此为基础，介绍了静态库和动态库，以及相应的制作和使用方法，最后两个部分分别记录了 <code>makefile</code>文件的书写方法和<code>GDB</code>调试的常用指令。虽然本篇文章的内容并不和 Linux 系统编程直接相关，但确实是重要的基础。之后的部分将会记录 Linux 系统编程常用的函数，以及一些系统指令的实现。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>Linux系统编程</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>Linux</tag>
        <tag>GDB</tag>
      </tags>
  </entry>
  <entry>
    <title>Linux 网络编程（一）：socket相关函数与C/S模型实现</title>
    <url>/2020/02/13/unp-01/</url>
    <content><![CDATA[<h2 id="1-计算机网络基础"><a href="#1-计算机网络基础" class="headerlink" title="1 计算机网络基础"></a>1 计算机网络基础</h2><h3 id="1-1-网络分层模型和代表协议"><a href="#1-1-网络分层模型和代表协议" class="headerlink" title="1.1 网络分层模型和代表协议"></a>1.1 网络分层模型和代表协议</h3><p>常见网络分层模型主要有两种：OSI 七层模型和TCP/IP四层模型。</p>
<p>OSI七层模型是ISO组织提出的，如下</p>
<ul>
<li>应用层：HTTP，FTP</li>
<li>表示层：ASCII，PICT，TIFF，JPEG</li>
<li>会话层：RPC，SQL，NFS</li>
<li>传输层：TCP，UDP，SPX</li>
<li>网络层：IP，ICMP</li>
<li>数据链路层：802.2等等</li>
<li>物理层</li>
</ul>
<p>实际中常常以TCP/IP四层模型代替，其代表协议如下</p>
<ul>
<li>应用层：<code>http</code>，<code>ftp</code>，<code>nfs</code>，<code>ssh</code>，<code>telnet</code></li>
<li>传输层：<code>TCP</code>、<code>UDP</code></li>
<li>网络层：<code>IP</code>，<code>ICMP</code>，<code>IGMP</code></li>
<li>链路层：以太网帧协议，<code>ARP</code></li>
</ul>
<p><a href="https://zhuanlan.zhihu.com/p/32059190" target="_blank" rel="noopener">详细介绍可见这里</a>。</p>
<h3 id="1-2-C-S模型和B-S模型"><a href="#1-2-C-S模型和B-S模型" class="headerlink" title="1.2 C/S模型和B/S模型"></a>1.2 C/S模型和B/S模型</h3><p>C/S模型即client/server模型，分为客户端和服务端。</p>
<ul>
<li>优点：客户端可以缓存大量数据，在实现上协议选择灵活，完全可以自己设计协议，速度快</li>
<li>缺点：安全性不佳，跨平台性差，开发工作量大</li>
</ul>
<p>B/S模型即browser/server模型，只需在浏览器中即可访问服务</p>
<ul>
<li>优点：能够跨平台使用，开发工作量小</li>
<li>缺点：不能缓存大量数据，需要严格遵守HTTP相关协议</li>
</ul>
<h3 id="1-3-数据传输过程"><a href="#1-3-数据传输过程" class="headerlink" title="1.3 数据传输过程"></a>1.3 数据传输过程</h3><p>应用数据在网络进行传输前需要进行逐层封装，不封装则无法在网络中进行传输。</p>
<p>如TCP/IP协议传输的话，应用数据进入传输层时需要打上TCP首部称为数据段Segment，进入网络层时再打上IP首部称为数据包Packet，最后在链路层中还要打上以太网首部和以太网尾部称为帧Freame。其中TCP首部20Bytes，IP首部20Bytes，以太网首部20Bytes，以太网尾部4Bytes。802.3以太网帧最大为1530Bytes（帧间距另外还需要12Bytes）。</p>
<p>同样接收方在接受到数据的过程中也需要逐层解封装。</p>
<p><a href="https://liamlin.me/2019/06/06/the-basic-principles-of-tcp-ip" target="_blank" rel="noopener">传输的详细过程可以看这个博客</a>。</p>
<h3 id="1-4-以太网帧格式和ARP协议"><a href="#1-4-以太网帧格式和ARP协议" class="headerlink" title="1.4 以太网帧格式和ARP协议"></a>1.4 以太网帧格式和ARP协议</h3><p>ARP(Addree Resolution Protocal)即地址解析协议，用于实现从IP地址到MAC地址的映射，即询问目标IP对应的MAC地址。</p>
<p>在传输数据的封装过程中，不仅需要封装源主机和目的主机的IP地址，还需要封装各自的MAC地址。在上层程序中一般更关心IP地址，所以在传输时，需要将其给出的IP地址通过ARP协议来获取目的主机的MAC地址，完成数据封装。</p>
<p>在以太网链路上传输的数据包称为以太帧。</p>
<p> 以太帧起始部分由前导码和帧开始符组成。后面紧跟着一个以太网报头，以MAC地址说明目的地址和源地址。帧的中部是该帧负载的包含其他协议报头的数据包(例如IP协议)。以太帧由一个32位冗余校验码结尾。它用于检验数据传输是否出现损坏。</p>
<h3 id="1-5-IP协议"><a href="#1-5-IP协议" class="headerlink" title="1.5 IP协议"></a>1.5 IP协议</h3><p>IP协议是TCP/IP协议族的核心协议，也是<code>socket</code>网络编程的基础。</p>
<p>IP协议的主要的主要特点如下</p>
<ul>
<li>无状态：IP通信双方不同步传输数据的状态信息，所有IP数据报的发送、传输、接受都是相互独立、没有上下文关系的。这种服务优点在于简单、高效。最大的缺点是无法处理乱序和重复的IP数据报，确保IP数据报完整的工作只能交给上层协议来完成。</li>
<li>无连接： IP通信双方都不长久地维持对方的任何信息。上层协议每次发送数据的时候，都需要明确指出对方的IP地址。 </li>
<li>不可靠： IP协议不能保证IP数据报准确到达接收端，它指承诺尽最大努力交付。IP模块一旦检测到数据报发送失败，就通知上层协议，而不会试图重传。 </li>
</ul>
<p>IPv4的头部见下图</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/unp/unp02-ipv4.png" alt=""></p>
<p>IPv6的头部见下图</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/unp/unp03-ipv6.png" alt=""></p>
<p><a href="https://www.jianshu.com/p/58a77f173f71" target="_blank" rel="noopener">对于头部中各部分的说明见这里</a>。</p>
<p>注意IP地址为4字节32位。</p>
<h3 id="1-6-TCP和UDP"><a href="#1-6-TCP和UDP" class="headerlink" title="1.6 TCP和UDP"></a>1.6 TCP和UDP</h3><p> TCP（Transmission Control Protocol，传输控制协议）是面向连接的协议，也就是说，在收发数据前，必须和对方建立可靠的连接。 建立连接需要所谓的“三次握手”，断开连接需要“四次挥手”。其对系统资源要求较多，流模式，TCP保证传输数据的有序和正确性。</p>
<p>其包头结构如下图</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/unp/unp03-tcp.png" alt=""></p>
<p> UDP（User Data Protocol，用户数据报协议）是一个非连接的协议，传输数据之前源端和终端不建立连接， 当它想传送时就简单地去抓取来自应用程序的数据，并尽可能快地把它扔到网络上。 在发送端，UDP传送数据的速度仅仅是受应用程序生成数据的速度、 计算机的能力和传输带宽的限制； 在接收端，UDP把每个消息段放在队列中，应用程序每次从队列中读一个消息段。 </p>
<p>注意端口号为2字节8位，所以端口号最大为<code>2^16 - 1 = 65536</code>,最小为0，端口号小于256的定义为常用端口，服务器一般都是通过常用端口号来识别的。任何TCP/IP实现所提供的服务都用1—1023之间的端口号，是由ICANN来管理的；端口号从1024—49151是被注册的端口，也成为“用户端口”，被IANA指定为特殊服务使用。</p>
<p>大多数TCP/IP实现给临时端口号分配1024—5000之间的端口号。大于5000的端口号是为其他服务器预留的。</p>
<p>关于“三次握手”和“四次挥手”，<a href="https://zhuanlan.zhihu.com/p/53374516" target="_blank" rel="noopener">可参见这里</a>。</p>
<h2 id="2-socket编程相关函数"><a href="#2-socket编程相关函数" class="headerlink" title="2 socket编程相关函数"></a>2 socket编程相关函数</h2><h3 id="2-1-字节序转换"><a href="#2-1-字节序转换" class="headerlink" title="2.1 字节序转换"></a>2.1 字节序转换</h3><p>字节序又分为大端字节序和小端字节序。</p>
<ul>
<li>大端字节序：将高位数据存放到低位内存地址</li>
<li>小端字节序：将低位数据存放到高位内存地址</li>
</ul>
<p><strong>网络字节序都是大端字节序</strong>。</p>
<p>字节序转换的相关函数：</p>
<ul>
<li><code>uint32_t htonl(uint32_t hostlong)</code>：将<code>long</code>类型的主机字节序转为网络字节序</li>
<li><code>uint16_t htons(uint16_t hostshort)</code>：将<code>short</code>类型的主机字节序转为网络字节序</li>
<li><code>uint32_t ntohl(uint32_t netlong)</code>：同上相反</li>
<li><code>uint16_t ntohs(uint16_t netshort)</code>：同上相反</li>
</ul>
<h3 id="2-2-地址转换函数"><a href="#2-2-地址转换函数" class="headerlink" title="2.2 地址转换函数"></a>2.2 地址转换函数</h3><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_aton</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span> *cp, struct in_addr *inp)</span></span>; <span class="comment">// 将点分十进制地址转换为32位整数</span></span><br><span class="line"><span class="keyword">in_addr_t</span> inet_addr(<span class="keyword">const</span> <span class="keyword">char</span>* cp); <span class="comment">// 将点分十进制地址转换成32位整数</span></span><br><span class="line"><span class="function"><span class="keyword">char</span> *<span class="title">inet_ntoa</span><span class="params">(struct in_addr in)</span></span>; <span class="comment">// 将32位整数转换为点分十进制地址</span></span><br><span class="line"><span class="comment">// 将本地字节序转换为网络字节序</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">inet_pton</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">char</span> *src, <span class="keyword">void</span> *dst)</span></span>; <span class="comment">// af为IP协议，src为点分十进制IP地址，dst为转换后IP地址</span></span><br><span class="line"><span class="comment">// 将网络字节序转换为本地字节序</span></span><br><span class="line"><span class="function"><span class="keyword">const</span> <span class="keyword">char</span> *<span class="title">inet_ntop</span><span class="params">(<span class="keyword">int</span> af, <span class="keyword">const</span> <span class="keyword">void</span> *src, <span class="keyword">char</span> *dst, <span class="keyword">socklen_t</span> <span class="built_in">size</span>)</span></span>;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-地址结构"><a href="#2-3-地址结构" class="headerlink" title="2.3 地址结构"></a>2.3 地址结构</h3><p>套接口地址结构</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">socketaddr_in</span> &#123;</span></span><br><span class="line">	<span class="keyword">sa_family_t</span> sin_family; <span class="comment">// 地址家族，一般设为 AF_INET</span></span><br><span class="line">	<span class="keyword">in_port_t</span> sin_port; <span class="comment">// 端口</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> <span class="title">sin_addr</span>;</span> <span class="comment">// IPv4的地址</span></span><br><span class="line">    <span class="keyword">char</span> sin_zero[<span class="number">8</span>]; <span class="comment">// 暂不使用 一般设为0</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">in_addr</span> &#123;</span></span><br><span class="line">	<span class="keyword">uint32_t</span> s_addr; <span class="comment">// 只包含一个32位无符号数表示地址</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>由于历史原因，有些函数需要使用通用地址结构作为参数，所以有时需要将两种结构的指针进行转换</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sockaddr</span> &#123;</span></span><br><span class="line"><span class="keyword">uint8_t</span> sin_len; <span class="comment">// 整个sockaddr结构体的长度</span></span><br><span class="line"><span class="keyword">sa_family_t</span> sin_family; <span class="comment">// 指定该地址家族</span></span><br><span class="line"><span class="keyword">char</span> sa_data[<span class="number">14</span>]; <span class="comment">// 根据上一成员决定形式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-相关函数"><a href="#2-4-相关函数" class="headerlink" title="2.4 相关函数"></a>2.4 相关函数</h3><h4 id="2-4-1-socket-函数"><a href="#2-4-1-socket-函数" class="headerlink" title="2.4.1 socket 函数"></a>2.4.1 socket 函数</h4><p>创建一个套接字用于通信</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;sys/socket.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocol)</span></span>; <span class="comment">//三个三参数分别指定通信协议族、socket类型、协议类型</span></span><br></pre></td></tr></table></figure>

<p>若创建成功返回非负整数，与文件描述符类似，俗称套接口描述字。</p>
<p>失败返回-1。</p>
<h4 id="2-4-2-bind-函数"><a href="#2-4-2-bind-函数" class="headerlink" title="2.4.2 bind 函数"></a>2.4.2 bind 函数</h4><p>绑定一个本地地址到套接字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">&lt;sys/socket.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p>三个参数分别为套接字、要绑定的地址、地址长度。</p>
<p>失败返回-1，成功返回0。</p>
<h4 id="2-4-3-listen-函数"><a href="#2-4-3-listen-函数" class="headerlink" title="2.4.3 listen 函数"></a>2.4.3 listen 函数</h4><p>将套接字用于监听进入的连接</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">listen</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">int</span> backlog)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>sockfd</code>为要监听的套接字，<code>backlog</code>规定内核为此套接字排队的最大连接个数。</p>
<p>成功返回0，失败返回-1。</p>
<p>监听以后，套接字变为被动套接字，用于在<code>accept</code>函数之前调用，否则默认为主动套接字。</p>
<p>对于给定的监听套接口，内核要维护两个队列：</p>
<ul>
<li>已有客户发出并到达服务器，服务器正在等待完成相应的TCP三路握手过程</li>
<li>已完成连接的队列</li>
</ul>
<h4 id="2-4-4-accept-函数"><a href="#2-4-4-accept-函数" class="headerlink" title="2.4.4 accept 函数"></a>2.4.4 accept 函数</h4><p>从已完成连接队列返回第一个连接，如果已完成连接队列为空则阻塞</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line">include &lt;sys/socket.h&gt;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">accept</span><span class="params">(<span class="keyword">int</span> sockfd, struct sockaddr* addr, <span class="keyword">socklen_t</span> *addrlen)</span></span></span><br></pre></td></tr></table></figure>

<p><code>sockfd</code>为服务器套接字，<code>addr</code>是将返回对等方的套接字地址，<code>addrlen</code>返回对等方的套接字地址长度。</p>
<p>成功返回非负整数，失败返回-1</p>
<h4 id="2-4-5-connect-函数"><a href="#2-4-5-connect-函数" class="headerlink" title="2.4.5 connect 函数"></a>2.4.5 connect 函数</h4><p>功能是建立一个连接至<code>addr</code>所指定的套接字</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">connect</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr* addr, <span class="keyword">socklen_t</span> addrlen)</span></span>;</span><br></pre></td></tr></table></figure>

<p><code>sockfd</code>是未连接的套接字，<code>addr</code>是要连接的套接字地址，<code>addrlen</code>是第二个参数<code>addr</code>的长度。</p>
<p>成功返回0，失败返回-1。</p>
<h2 id="3-C-S模型实现"><a href="#3-C-S模型实现" class="headerlink" title="3 C/S模型实现"></a>3 C/S模型实现</h2><h3 id="3-1-基本实现思路"><a href="#3-1-基本实现思路" class="headerlink" title="3.1 基本实现思路"></a>3.1 基本实现思路</h3><p>这里实现一个简单的C/S模型，分别实现服务端和客户端，完成从客户端发送字符，服务端收到后将字符转换为大写，然后回传到客户端，客户端收到后将其打印。</p>
<p>服务端的实现流程：</p>
<ul>
<li>使用<code>socket()</code>创建套接字</li>
<li>使用<code>bind()</code>绑定服务端地址和端口号</li>
<li>使用<code>listen()</code>设定套接字监听上限</li>
<li>使用<code>accpet()</code>阻塞监听客户端的连接</li>
<li>使用<code>read()</code>从读取字符，用<code>toupper()</code>将其转为大写，然后用<code>write()</code>写会客户端</li>
<li>当客户端关闭后，使用<code>close()</code>关闭套接字</li>
</ul>
<p>客户端实现则比较简单</p>
<ul>
<li>使用<code>socket()</code>创建套接字</li>
<li>使用<code>connect()</code>与服务器进行连接</li>
<li>使用通过<code>fgets()</code>从键盘接收输入，然后使用<code>write()</code>写向服务端，最后用<code>read()</code>读取服务端数据，将其打印</li>
<li>当接收到中断程序信息，则使用<code>close()</code>关闭套接字</li>
</ul>
<h3 id="3-2-C-S模型1-0版"><a href="#3-2-C-S模型1-0版" class="headerlink" title="3.2 C/S模型1.0版"></a>3.2 C/S模型1.0版</h3><p>在这个版本里只需根据3.1节的实现流程按部就班调用函数实现即可</p>
<h4 id="3-2-1-服务端实现"><a href="#3-2-1-服务端实现" class="headerlink" title="3.2.1 服务端实现"></a>3.2.1 服务端实现</h4><p>直接看服务端代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"socker error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clit_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line">    <span class="keyword">if</span> (bind(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"bind error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(sockfd, <span class="number">128</span>) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"listen error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> nsockfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">socklen_t</span> cli_addr_len = <span class="keyword">sizeof</span>(clit_addr), cli_ip;</span><br><span class="line">    <span class="keyword">char</span> cli_IP[<span class="number">64</span>];</span><br><span class="line">    <span class="keyword">if</span> ((nsockfd = accept(sockfd, (struct sockaddr*)&amp;clit_addr, &amp;cli_addr_len)) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"accept error"</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip: %s port: %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;clit_addr.sin_addr.s_addr, cli_IP, <span class="keyword">sizeof</span>(cli_IP)), </span><br><span class="line">            ntohs(clit_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(ret = <span class="built_in">read</span>(nsockfd, buf, BUFFSIZE)) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, buf, ret);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        <span class="built_in">write</span>(nsockfd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="built_in">close</span>(nsockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-2-2-客户端实现"><a href="#3-2-2-客户端实现" class="headerlink" title="3.2.2 客户端实现"></a>3.2.2 客户端实现</h4><p>再看客户端代码</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd;</span><br><span class="line">    <span class="keyword">if</span> ((sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">    </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">connect</span>(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr)) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"connect error"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(fgets(buf, BUFFSIZE, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">        <span class="built_in">write</span>(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFSIZE);</span><br><span class="line">        ret = <span class="built_in">read</span>(sockfd, buf, BUFFSIZE);</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">close</span>(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中头文件<code>helper.h</code>有一些宏和错误辅助函数的实现，后续一些辅助的函数都会放入这个文件中</p>
<figure class="highlight c"><figcaption><span>helper.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifndef</span> UNP_HELPER_H_</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> UNP_HELPER_H_</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;errno.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUFFSIZE 4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LINESIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SERV_PORT 9527</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span> <span class="comment">// UNP_HELPER_H_</span></span></span><br></pre></td></tr></table></figure>

<p>将服务端和客户端程序分别编译完成后，<strong>先运行服务端，再运行客户端</strong>。然后在客户端中输入任意小写英文字符，即可看到屏幕将对应大写字符打印在shell中。</p>
<h3 id="3-3-C-S模型2-0版-函数的异常封装"><a href="#3-3-C-S模型2-0版-函数的异常封装" class="headerlink" title="3.3 C/S模型2.0版-函数的异常封装"></a>3.3 C/S模型2.0版-函数的异常封装</h3><p>由于我们使用到的大多数函数都需要保证其异常情况，如判断其调用后返回值是否等于<code>-1</code>，如果在主程序中挨个对其判断异常，则会大大降低主程序的可读性，程序逻辑不够突出。</p>
<h4 id="3-3-1-常用函数封装"><a href="#3-3-1-常用函数封装" class="headerlink" title="3.3.1 常用函数封装"></a>3.3.1 常用函数封装</h4><p>因此可以将这些常用的需要保证异常安全的函数进行简单封装，将出错处理与逻辑分离，提高主程序的代码整洁性，如</p>
<figure class="highlight c"><figcaption><span>helper.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">sys_err</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* str)</span> </span>&#123;</span><br><span class="line">    perror(str);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Socket</span><span class="params">(<span class="keyword">int</span> domain, <span class="keyword">int</span> type, <span class="keyword">int</span> protocal)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> fd = socket(domain, type, protocal);</span><br><span class="line">    <span class="keyword">if</span> (fd ==  <span class="number">-1</span>) </span><br><span class="line">        sys_err(<span class="string">"socket error"</span>);</span><br><span class="line">    <span class="keyword">return</span> fd;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>封装后的函数名即是将原函数的首字母大写，并使其形参与原函数完全一致，这样既不影响对原函数的接口调用，又可以提高程序整洁性，同时也方便直接使用<code>man</code>命名查看相关函数原型。</p>
<p>其他函数的封装过程如下</p>
<figure class="highlight c"><figcaption><span>helper.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Bind</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr* addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (bind(fd, addr, len) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"bind error"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Listen</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">int</span> n)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">listen</span>(fd, n) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"listen error"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Accept</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr* addr, <span class="keyword">socklen_t</span>* len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd;</span><br><span class="line">again:</span><br><span class="line">    lfd = accept(fd, addr, len);</span><br><span class="line">    <span class="keyword">if</span> (lfd == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> ((errno == ECONNABORTED) || (errno == EINTR))</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            sys_err(<span class="string">"accept error"</span>);</span><br><span class="line">    <span class="keyword">return</span> lfd;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Connect</span><span class="params">(<span class="keyword">int</span> fd, struct sockaddr* addr, <span class="keyword">int</span> len)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(<span class="built_in">connect</span>(fd, addr, len) == <span class="number">-1</span>) </span><br><span class="line">        sys_err(<span class="string">"connect error"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Read(<span class="keyword">int</span> fd, <span class="keyword">void</span> *buf, <span class="keyword">size_t</span> nbytes) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">read</span>(fd, buf, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">ssize_t</span> Write(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">void</span>* buf, <span class="keyword">size_t</span> nbytes) &#123;</span><br><span class="line">    <span class="keyword">ssize_t</span> n;</span><br><span class="line">again:</span><br><span class="line">    <span class="keyword">if</span> ((n = <span class="built_in">write</span>(fd, buf, nbytes)) == <span class="number">-1</span>)</span><br><span class="line">        <span class="keyword">if</span> (errno == EINTR)</span><br><span class="line">            <span class="keyword">goto</span> again;</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Close</span><span class="params">(<span class="keyword">int</span> fd)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">close</span>(fd) == <span class="number">-1</span>)</span><br><span class="line">        sys_err(<span class="string">"close error"</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-2-服务端2-0版本"><a href="#3-3-2-服务端2-0版本" class="headerlink" title="3.3.2 服务端2.0版本"></a>3.3.2 服务端2.0版本</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>* argv[])</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sockfd = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> nsockfd = <span class="number">0</span>;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>, <span class="title">clit_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    serv_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> cli_addr_len = <span class="keyword">sizeof</span>(clit_addr), cli_ip;</span><br><span class="line">    <span class="keyword">char</span> cli_IP[<span class="number">64</span>];</span><br><span class="line"></span><br><span class="line">    sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    Bind(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    Listen(sockfd, <span class="number">128</span>);</span><br><span class="line">    nsockfd = Accept(sockfd, (struct sockaddr*)&amp;clit_addr, &amp;cli_addr_len);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">"client ip: %s port: %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;clit_addr.sin_addr.s_addr, cli_IP, <span class="keyword">sizeof</span>(cli_IP)), </span><br><span class="line">            ntohs(clit_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line">    <span class="keyword">while</span>(ret = <span class="built_in">read</span>(nsockfd, buf, BUFFSIZE)) &#123;</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, buf, ret);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">            buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">        <span class="built_in">write</span>(nsockfd, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(sockfd);</span><br><span class="line">    Close(nsockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="3-3-3-客户端2-0版本"><a href="#3-3-3-客户端2-0版本" class="headerlink" title="3.3.3 客户端2.0版本"></a>3.3.3 客户端2.0版本</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">serv_addr</span>;</span></span><br><span class="line">    serv_addr.sin_family = AF_INET;</span><br><span class="line">    serv_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    inet_pton(AF_INET, <span class="string">"127.0.0.1"</span>, &amp;serv_addr.sin_addr.s_addr);</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> sockfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    Connect(sockfd, (struct sockaddr*)&amp;serv_addr, <span class="keyword">sizeof</span>(serv_addr));</span><br><span class="line">    <span class="keyword">while</span> (fgets(buf, BUFFSIZE, <span class="built_in">stdin</span>)) &#123;</span><br><span class="line">        <span class="built_in">write</span>(sockfd, buf, <span class="built_in">strlen</span>(buf));</span><br><span class="line">        <span class="built_in">memset</span>(buf, <span class="number">0</span>, BUFFSIZE);</span><br><span class="line">        ret = <span class="built_in">read</span>(sockfd, buf, BUFFSIZE);</span><br><span class="line">        <span class="built_in">write</span>(STDERR_FILENO, buf, ret);</span><br><span class="line">    &#125;</span><br><span class="line">    Close(sockfd);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>使用效果同1.0版本一致</p>
<h3 id="3-4-C-S模型3-0-多进程并发"><a href="#3-4-C-S模型3-0-多进程并发" class="headerlink" title="3.4 C/S模型3.0-多进程并发"></a>3.4 C/S模型3.0-多进程并发</h3><p>前两个版本实现，服务器同时都只能接受一个客户端的连接，这显然并不合理，因此可以使用多进程或者多线程来实现简单的并发功能，使得服务器可以同时接受多个客户端的连接，并正常提供服务。</p>
<p>在此实现一下多进程版本，主要使用<code>fork()</code>函数来生成子进程。</p>
<h4 id="3-4-1-使用fork-开启多进程"><a href="#3-4-1-使用fork-开启多进程" class="headerlink" title="3.4.1 使用fork()开启多进程"></a>3.4.1 使用<code>fork()</code>开启多进程</h4><p><code>fork()</code>函数如下。</p>
<figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="keyword">pid_t</span> fork(); <span class="comment">// pid_t 是int的别名</span></span><br></pre></td></tr></table></figure>

<p><code>fork()</code>可以讲运行着的程序分成2个几乎完全一样的进程，每个进程都启动一个从代码同一位置开始执行的现成，这两个进程中的线程继续执行。在父进程中，<code>fork()</code>的返回值是子进程的进程ID；在子进程中<code>fork()</code>返回值为0；出错时返回 -1。</p>
<p>另外，还需要借助<code>signal</code>机制来回收子进程，否则进程不安全。</p>
<h4 id="3-4-2-服务端3-0版本"><a href="#3-4-2-服务端3-0版本" class="headerlink" title="3.4.2 服务端3.0版本"></a>3.4.2 服务端3.0版本</h4><figure class="highlight c"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;ctype.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;signal.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;strings.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"../helper.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">catch_child</span><span class="params">(<span class="keyword">int</span> signum)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (waitpid(<span class="number">0</span>, <span class="literal">NULL</span>, WNOHANG) &gt; <span class="number">0</span>)</span><br><span class="line">        ;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> lfd, cfd, ret;</span><br><span class="line">    <span class="keyword">char</span> buf[BUFFSIZE];</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span> <span class="title">ser_addr</span>, <span class="title">clt_addr</span>;</span></span><br><span class="line">    ser_addr.sin_family = AF_INET;</span><br><span class="line">    ser_addr.sin_port = htons(SERV_PORT);</span><br><span class="line">    ser_addr.sin_addr.s_addr = htonl(INADDR_ANY);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">socklen_t</span> addr_len = <span class="keyword">sizeof</span>(clt_addr);</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line"></span><br><span class="line">    bzero(&amp;clt_addr, addr_len);</span><br><span class="line"></span><br><span class="line">    lfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line">    Bind(lfd, (struct sockaddr*)&amp;ser_addr, addr_len);</span><br><span class="line">    Listen(lfd, <span class="number">128</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        cfd = Accept(lfd, (struct sockaddr*)&amp;clt_addr, &amp;addr_len);</span><br><span class="line">        <span class="keyword">char</span> cli_IP[<span class="number">32</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">"client ip: %s port: %d\n"</span>,</span><br><span class="line">            inet_ntop(AF_INET, &amp;clt_addr.sin_addr.s_addr, cli_IP, <span class="keyword">sizeof</span>(cli_IP)), </span><br><span class="line">            ntohs(clt_addr.sin_port));</span><br><span class="line">    </span><br><span class="line">        pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="built_in">close</span>(lfd);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            struct sigaction act;</span><br><span class="line">            act.sa_handler = catch_child;</span><br><span class="line">            sigemptyset(&amp;act.sa_mask);</span><br><span class="line">            act.sa_flags = <span class="number">0</span>;</span><br><span class="line">            ret = sigaction(SIGCHLD, &amp;act, <span class="literal">NULL</span>);</span><br><span class="line">            <span class="keyword">if</span> (ret = <span class="number">0</span>)</span><br><span class="line">                sys_err(<span class="string">"sigaction error"</span>);</span><br><span class="line">            <span class="built_in">close</span>(cfd);</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            sys_err(<span class="string">"fork error"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">while</span> (ret = <span class="built_in">read</span>(cfd, buf, BUFFSIZE)) &#123;</span><br><span class="line">            <span class="built_in">write</span>(STDERR_FILENO, buf, ret);</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; ret; ++i)</span><br><span class="line">                buf[i] = <span class="built_in">toupper</span>(buf[i]);</span><br><span class="line">            <span class="built_in">write</span>(cfd, buf, ret);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">close</span>(cfd);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>客户端则无需变化。</p>
<h2 id="4-结束语"><a href="#4-结束语" class="headerlink" title="4 结束语"></a>4 结束语</h2><p>本文先在第一部分记录了一些 Linux 网络编程中的一些基础知识，然后在第二部分介绍了一个简单 C/S模型中会使用的相关函数，最后在第三部分循序渐进地实现了多个版本简单 C/S 模型，作为练习。</p>
<p>总体来说是网络编程的一个简单入门demo，接下来会对学习到的更深的知识进行记录和总结。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>网络编程</category>
      </categories>
      <tags>
        <tag>Linux</tag>
        <tag>网络编程</tag>
        <tag>APUE</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL实现项目（四）：迭代器、反向迭代器及初始化工具</title>
    <url>/2020/02/13/STL4-IteratorAndInitTool/</url>
    <content><![CDATA[<p>在进行<code>vector</code>、<code>list</code>等容器设计之前，我们还需要进行一些准备工作。首先因为容器主要是通过迭代器进行读取和修改操作的，所以我们需要设计迭代器相关工具；另外还需要为部分容器设计反向迭代器，令其支持反向读取操作；最后还需要一组初始化工具，用于容器对象创建时，开辟内存空间后，向其填充元素。</p>
<h2 id="1-迭代器-iterator-概念"><a href="#1-迭代器-iterator-概念" class="headerlink" title="1 迭代器 iterator 概念"></a>1 迭代器 iterator 概念</h2><h3 id="1-1-迭代器的作用"><a href="#1-1-迭代器的作用" class="headerlink" title="1.1 迭代器的作用"></a>1.1 迭代器的作用</h3><p>迭代器最直接的作用就是可以迭代地访问容器元素。</p>
<p>迭代器<code>iterator</code>在STL中的角色非常关键，可以说代表了STL设计的中心思想：将容器<code>containers</code>和算法<code>algorithms</code>分开，使用泛型思想独立设计，然后使用迭代器进行两者的交互，这样就可以在保证性能最大化的同时，让一种算法可以应用在多种容器上。</p>
<p>例如算法<code>find</code></p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line">temlate &lt;<span class="class"><span class="keyword">class</span> <span class="title">InputIterator</span>, <span class="title">class</span> <span class="title">T</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">InputIterator</span> <span class="title">find</span>(<span class="title">InputIterator</span> <span class="title">first</span>,</span></span><br><span class="line"><span class="class">                   <span class="title">InputIterator</span> <span class="title">last</span>, </span></span><br><span class="line"><span class="class">                   <span class="title">const</span> <span class="title">T</span>&amp; <span class="title">value</span>) &#123;</span></span><br><span class="line">    <span class="keyword">while</span> (first != last &amp;&amp; *first != value)</span><br><span class="line">        ++first;</span><br><span class="line">    <span class="keyword">return</span> first;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其可以接受两个迭代器，来表示容器中的一个<strong>前闭后开</strong>的区间范围，然后在这个范围中寻找是否含有值为<code>value</code>的目标迭代器，如果未找到，则返回区间最后一个迭代器。而这些迭代器可以来自<code>vector</code>、<code>list</code>、<code>stack</code>等等容器。</p>
<p>迭代器与指针又是什么关系呢？</p>
<p>迭代器的行为类似指针，<strong>可以说迭代器就是一种智能指针<code>smart pointer</code></strong>，使用它不用担心内存泄露等等问题。</p>
<p>事实上，很多迭代器的实现，就是对指针的包装，其最重要的工作就是对<code>operator*</code>和<code>operator-&gt;</code>进行重载。</p>
<h3 id="1-2-迭代器型别"><a href="#1-2-迭代器型别" class="headerlink" title="1.2 迭代器型别"></a>1.2 迭代器型别</h3><p>在前面的文章中，已经提到过使用<code>traits</code>技巧可以“萃取”对象或类的某种特性。</p>
<p>那么迭代器有哪些特性需要供人“萃取”呢？那就要说到迭代器的五种型别</p>
<ul>
<li>value_type：迭代器所指对象的型别。</li>
<li>difference_type：用来表示迭代器之间的距离，可以用来表示一个容器的最大容量。</li>
<li>reference：在对迭代器<code>iter</code>进行解引用<code>*iter</code>时应该返回的类型；若迭代器为<code>mutable</code>这里即为<code>value_type&amp;</code>，若迭代器为<code>constant</code>，这里即为<code>const value_type&amp;</code>。</li>
<li>pointer：迭代器所指对象的指针类型</li>
<li>iterator_category：迭代器的类型，这里所说的类型根据迭代器的移动和读写特性分成了五类。</li>
</ul>
<p>迭代器的类型<code>iterator_category</code>分为以下5类</p>
<ol>
<li><code>input iterator</code>：只读，即不允许通过迭代器改变所指对象；单向移动， 支持<code>operator++</code></li>
<li><code>output iterator</code>：只写；单向移动，支持<code>operator++</code></li>
<li><code>forward iterator</code>：允许读写；单向移动，支持<code>operator++</code></li>
<li><code>bidirectional iterator</code>：允许读写；双向移动，支持<code>operator++</code>和<code>operator--</code></li>
<li><code>random access iterator</code>：允许读写；既可双向移动，也可随机访问，即同时支持<code>++</code>、<code>–-</code>、<code>+n</code>、<code>-n</code></li>
</ol>
<p>迭代器的类型非常重要，根据迭代器的具体类型，可以为同一种算法提供不同设计，以达到最优效率。例如，显然<code>random access iterator</code>对元素的读取就比其他类型的迭代器方便得多，可以减少许多不必要的遍历，从而提升效率。</p>
<h2 id="2-迭代器的设计"><a href="#2-迭代器的设计" class="headerlink" title="2 迭代器的设计"></a>2 迭代器的设计</h2><h3 id="2-1-迭代器的五种类型设计"><a href="#2-1-迭代器的五种类型设计" class="headerlink" title="2.1 迭代器的五种类型设计"></a>2.1 迭代器的五种类型设计</h3><p>1.2节中已经提到，我们的算法可以根据不同的迭代器类型来优化，显然我们可以使用重载机制，根据参数中迭代器的类型对同一种算法进行重载。而重载函数需要区分形参的个数与类型，我们可以使用如下思路来设计</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algo</span><span class="params">(Iterator first, Iterator last)</span></span>&#123;</span><br><span class="line">    algo_aux(first, last, Iterator::iterator_category);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algo_aux</span><span class="params">(Iterator first,Iterator last, InputIterator)</span></span>&#123;</span><br><span class="line">    <span class="comment">// do something;</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">algo_aux</span><span class="params">(Iterator first, Iterator last, RandomAccessIterator)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// do otherthing;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以对于五种类型的设计，应当设计为不同的类型，以方便作为重载函数的形参，实现如下</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">input_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">output_iterator_tag</span> &#123;</span>&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">forward_iterator_tag</span> :</span> <span class="keyword">public</span> input_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bidirectional_iterator_tag</span> :</span> <span class="keyword">public</span> forward_iterator_tag &#123;&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">random_access_iterator_tag</span> :</span> <span class="keyword">public</span> bidirectional_iterator_tag &#123;&#125;;</span><br></pre></td></tr></table></figure>

<p>这是五种没有任何成员的<code>struct</code>，并且之间还有继承关系。没有任何成员则不带来任何负担，而之间的继承关系，则可以保证作为子类的迭代器类型可以在为父类迭代器设计的函数中正常运行。</p>
<p>比如有一种算法，仅为<code>input_iterator_tag</code>和<code>random_iterator_tag</code>设计了重载函数，那么由于继承关系，类型为<code>forward_iterator_tag</code>和<code>bidirectional_iterator_tag</code>也可以使用为<code>input_iterator_tag</code>设计的版本。否则就需要为每一种可能可以使用的迭代器类型单独重载一个版本，这就带来了许多不必要的工作。</p>
<h3 id="2-2-迭代器模板设计"><a href="#2-2-迭代器模板设计" class="headerlink" title="2.2 迭代器模板设计"></a>2.2 迭代器模板设计</h3><p>由于规定了STL使用的迭代器必须拥有1.2节中所规定的型别定义，以供<code>traits</code>，所以可以写一个基本的迭代器模板，只包含型别定义，那么每次自己设计迭代器时，继承自这个基本迭代器即可，无需自己再写一遍型别定义。</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> Category, <span class="keyword">typename</span> T, <span class="keyword">typename</span> Distance = <span class="keyword">ptrdiff_t</span>,</span><br><span class="line">         <span class="keyword">typename</span> Pointer = T*, <span class="keyword">typename</span> Reference = T&amp;&gt;</span><br><span class="line">struct iterator&#123;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = Category;</span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = Distance;</span><br><span class="line">    <span class="keyword">using</span> pointer           = Pointer;</span><br><span class="line">    <span class="keyword">using</span> reference         = Reference;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="2-3-迭代器的traits工具设计"><a href="#2-3-迭代器的traits工具设计" class="headerlink" title="2.3 迭代器的traits工具设计"></a>2.3 迭代器的traits工具设计</h3><p>因为实际使用中迭代器的设计各种各样，有的容器并不会单独设计一种迭代器，而是直接使用原生指针，那么直接通过<code>iterator::value_type</code>的方式来直接取得迭代器型别便不一定行得通。</p>
<p>那么为了统一接口，我们可以设计一个<code>iterator_traits</code>，用来取得所有被视为迭代器类型的型别。</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 迭代器的 traits</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = <span class="keyword">typename</span> Iterator::value_type;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = <span class="keyword">typename</span> Iterator::iterator_category;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">typename</span> Iterator::difference_type;</span><br><span class="line">    <span class="keyword">using</span> pointer           = <span class="keyword">typename</span> Iterator::pointer;</span><br><span class="line">    <span class="keyword">using</span> reference         = <span class="keyword">typename</span> Iterator::reference;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化版本</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;T*&gt;&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">iterator_traits</span>&lt;const T*&gt;&#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line">    <span class="keyword">using</span> pointer           = <span class="keyword">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = <span class="keyword">const</span> T&amp;;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这里的偏特化版本，就可以解决那些采用原生指针作为迭代器的traits问题，从而保证只要被视为迭代器，都可以通过<code>iterator_traits&lt;iterator&gt;::value_type</code>的方式来获取型别。</p>
<p>然而在实际使用中，很多时候还需要在取得类型时加<code>typename</code>来表示我们取出的类型别名定义，而不是成员函数等等，而且还需要获得迭代器本身的类型作为模板参数。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> iterator_traits&lt;Iteraror&gt;::value_type;</span><br></pre></td></tr></table></figure>

<p>这样难免觉得麻烦，也降低了代码的可读性，所以我们可以定义一组函数，让函数直接接受迭代器对象作为参数，然后返回我们需要萃取的型别的对象，此返回的对象还可以直接作为我们重载函数的参数。如下</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">iterator_category <span class="title">iterator_category</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> category = <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::iterator_category;</span><br><span class="line">    <span class="keyword">return</span> category();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">difference_type* <span class="title">difference_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::difference*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Iterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::<span class="function">value_type* <span class="title">value_type</span><span class="params">(<span class="keyword">const</span> Iterator&amp;)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">typename</span> iterator_traits&lt;Iterator&gt;::value_type*&gt;(<span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-4-advance-和-distance"><a href="#2-4-advance-和-distance" class="headerlink" title="2.4 advance 和 distance"></a>2.4 advance 和 distance</h3><p>在算法实现中，难免需要经常用到让迭代器前进一段距离，或是获取两个迭代器直接距离的操作。这对于分类为<code>random_access_iterator_tag</code>的随机访问迭代器来说，自然易如反掌，但对于仅支持<code>operator++</code>的其他迭代器来说，就有些麻烦，需要一位位地前进。</p>
<p>所以可以为这两个常用的迭代器操作各自设计函数，并且在函数实现中为不同类型的迭代器进行重载，保证所有类型迭代器都可用，还能兼顾效率。</p>
<p>实现如下</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">distance_aux(InputIterator first, InputIterator last, input_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type n = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; first != last; ++first, ++n);</span><br><span class="line">    <span class="keyword">return</span> n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;RandomAccessIterator&gt;::difference_type</span><br><span class="line">distance_aux(RandomAccessIterator first, RandomAccessIterator last, random_access_iterator_tag) &#123;</span><br><span class="line">    <span class="keyword">return</span> last - first;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">typename</span> iterator_traits&lt;InputIterator&gt;::difference_type</span><br><span class="line">distance(InputIterator first, InputIterator last) &#123;</span><br><span class="line">    <span class="keyword">return</span> distance_aux(first, last, iterator_category(first));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance_aux</span><span class="params">(InputIterator iter,<span class="keyword">const</span> Distance&amp; n, input_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; n != <span class="number">0</span>; --n, ++iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> BidirectionIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance_aux</span><span class="params">(BidirectionIterator iter, <span class="keyword">const</span> Distance&amp; n, bidirectional_iterator_tag)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (n &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">for</span>(; n != <span class="number">0</span>; --n, ++iter);</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">for</span>(; n != <span class="number">0</span>; ++n, --iter);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance_aux</span><span class="params">(RandomAccessIterator iter, <span class="keyword">const</span> Distance&amp; n, random_access_iterator_tag)</span> </span>&#123;</span><br><span class="line">    iter += n;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">advance</span><span class="params">(InputIterator iter, <span class="keyword">const</span> Distance&amp; n)</span> </span>&#123;</span><br><span class="line">    advance_aux(iter, n, iterator_category(iter));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="3-反向迭代器的设计"><a href="#3-反向迭代器的设计" class="headerlink" title="3 反向迭代器的设计"></a>3 反向迭代器的设计</h2><p>在STL为支持随机访问的容器如<code>vector</code>提供了反向迭代器，使用方法如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *vec.rbegin() &lt;&lt; <span class="built_in">endl</span>; 		 <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(vec.rbegin() + <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; <span class="comment">// 4</span></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; *(vec.rend() - <span class="number">1</span>) &lt;&lt; <span class="built_in">endl</span>; 	 <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>

<p>显然对于一个反向迭代器对象，<code>+1</code>则指向对象的索引<code>-1</code>，反之亦然。所以对于反向迭代器，最关键的实现部分就是对其操作符进行重载。</p>
<p>在实现思路上，我们可以设计一个模板类，接受一个普通迭代器类型作为模板参数，然后这个反向迭代器的模板类中，唯一的成员就是这个普通迭代器对象，然后按照反向迭代器的逻辑对各种操作符进行重载。</p>
<h3 id="3-1-基本设计"><a href="#3-1-基本设计" class="headerlink" title="3.1 基本设计"></a>3.1 基本设计</h3><p>说到底，其实反向迭代器不过就是初始迭代器的一个封装，只是要求封装后的接口能够满足“反向”的逻辑。</p>
<p>首先，我们要求能够转换为反向迭代器的初始迭代器的访问类型必须是<code>random access iterator</code>，自然也就能支持自增、自减操作。</p>
<p>然后反向迭代器也是迭代器，故而用于<code>traits</code>的型别定义不能少。另外还需定义一个成员函数<code>base()</code>用于取出其初始迭代器。</p>
<p>其基本的代码实现如下：</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 反向迭代器的实现</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> Reference = T&amp;,</span><br><span class="line">          <span class="keyword">typename</span> Distance = <span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line">class reverse_iterator&#123;</span><br><span class="line"><span class="keyword">protected</span>:</span><br><span class="line">    <span class="keyword">using</span> self = reverse_iterator&lt;RandomAccessIterator, T&gt;;</span><br><span class="line">    RandomAccessIterator current;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">using</span> iterator_category = random_access_iterator_tag;</span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = Distance;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = Reference;</span><br><span class="line">    reverse_iterator() &#123;&#125;</span><br><span class="line">    explicit reverse_iterator(RandomAccessIterator iter) : current(iter) &#123;&#125;</span><br><span class="line">    <span class="function">RandomAccessIterator <span class="title">base</span><span class="params">()</span> <span class="keyword">const</span> </span>&#123; <span class="keyword">return</span> current; &#125;</span><br><span class="line">    <span class="comment">// 还需实现操作符重载</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="3-2-类内操作符重载"><a href="#3-2-类内操作符重载" class="headerlink" title="3.2 类内操作符重载"></a>3.2 类内操作符重载</h3><p>操作符的重载其实是有固定的实现方法，故而不对语法进行详细分析，这里仅仅需要将原来的<code>+</code>、<code>-</code>、<code>+=</code>、<code>-=</code>的逻辑进行加减互换即可</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator, <span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> Reference = T&amp;,</span><br><span class="line">          <span class="keyword">typename</span> Distance = <span class="keyword">ptrdiff_t</span>&gt;</span><br><span class="line">class reverse_iterator&#123;</span><br><span class="line">    <span class="comment">/* 接迭代器基本设计之后 */</span></span><br><span class="line">    </span><br><span class="line">	<span class="comment">// 各种操作符重载</span></span><br><span class="line">    Reference <span class="keyword">operator</span>*() <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(current - <span class="number">1</span>); &#125;</span><br><span class="line">    pointer <span class="keyword">operator</span>-&gt;() &#123; <span class="keyword">return</span> &amp;(<span class="keyword">operator</span>*()); &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>++() &#123;</span><br><span class="line">        --current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>++(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        --current;</span><br><span class="line">        <span class="keyword">return</span> tmp;</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>--() &#123;</span><br><span class="line">        ++current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>--(<span class="keyword">int</span>) &#123;</span><br><span class="line">        self tmp = *<span class="keyword">this</span>;</span><br><span class="line">        ++current;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>+(Distance n) &#123;</span><br><span class="line">        <span class="keyword">return</span> self(current - n);</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>+=(Distance n) &#123;</span><br><span class="line">        current -= n;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    self <span class="keyword">operator</span>-(Distance n) &#123;</span><br><span class="line">        <span class="keyword">return</span> self(current + n);</span><br><span class="line">    &#125;</span><br><span class="line">    self&amp; <span class="keyword">operator</span>-=(Distance n) &#123;</span><br><span class="line">        current += n;</span><br><span class="line">        <span class="keyword">return</span> *<span class="keyword">this</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    Reference <span class="keyword">operator</span>[](Distance n) <span class="keyword">const</span> &#123; <span class="keyword">return</span> *(*<span class="keyword">this</span>); &#125;</span><br><span class="line">&#125;; <span class="comment">// end reverse_iterator</span></span><br></pre></td></tr></table></figure>

<h3 id="3-3-全局比较操作符重载"><a href="#3-3-全局比较操作符重载" class="headerlink" title="3.3 全局比较操作符重载"></a>3.3 全局比较操作符重载</h3><p>显然在类的设计中，还需要对<code>==</code>等比较操作符重载，在此将其作为全局操作符实现。实现代码如下</p>
<figure class="highlight c++"><figcaption><span>iterator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator,</span><br><span class="line">          <span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> Reference,</span><br><span class="line">          <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; lhs,</span><br><span class="line">                      reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.base() &lt; rhs.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator,</span><br><span class="line">          <span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> Reference,</span><br><span class="line">          <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> Distance <span class="keyword">operator</span>-(reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; lhs,</span><br><span class="line">                          reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; rhs) &#123;</span><br><span class="line">    <span class="keyword">return</span> lhs.base() - rhs.base();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> RandomAccessIterator,</span><br><span class="line">          <span class="keyword">typename</span> T,</span><br><span class="line">          <span class="keyword">typename</span> Reference,</span><br><span class="line">          <span class="keyword">typename</span> Distance&gt;</span><br><span class="line"><span class="keyword">inline</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt; <span class="keyword">operator</span>+(Distance n,</span><br><span class="line">                      reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;&amp; iter) &#123;</span><br><span class="line">    <span class="keyword">return</span> reverse_iterator&lt;RandomAccessIterator, T, Reference, Distance&gt;(iter.base() - n);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该反向迭代器的使用将会在下一篇<code>vector</code>的实现中看到。</p>
<h2 id="4-容器初始化工具设计"><a href="#4-容器初始化工具设计" class="headerlink" title="4 容器初始化工具设计"></a>4 容器初始化工具设计</h2><p>在之前空间分配器<code>allocator</code>的设计中已经提到，在STL中，将容器对象创建过程中的分配内存、构造对象分成了两步。在分配内存中我们已经拥有了<code>alloc</code>（实际STL标准中没有此接口）和<code>allocator</code>两种工具，这里，我们实现一下在分配好的内存中填充元素的初始化工具。</p>
<h3 id="4-1-uninitialized-copy"><a href="#4-1-uninitialized-copy" class="headerlink" title="4.1 uninitialized_copy"></a>4.1 uninitialized_copy</h3><p>在STL容器的使用中，我们是可以通过许多方法来创建新容器，既可以自己设定初始值，也可以拷贝已有容器内的元素。如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec1(<span class="number">5</span>, <span class="number">5</span>);</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lis1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>&#125;;</span><br><span class="line"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec2(vec1.<span class="built_in">begin</span>(), vec1.<span class="built_in">end</span>());</span><br><span class="line"><span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; lis2(vec2.<span class="built_in">begin</span>()+<span class="number">1</span>, vec.<span class="built_in">end</span>());</span><br></pre></td></tr></table></figure>

<p>其中后面两种方法通过迭代器将已有容器的元素进行拷贝，来初始化创建的容器对象。</p>
<p>所以我们需要使用一个工具，可以接受两个迭代器表示需要拷贝的范围，然后还需要一个迭代器参数，表示目的地点，返回值则是一个迭代器，<strong>指向拷贝完成的后一个位置</strong>。函数原型如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_copy</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InputIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ForwardIterator result)</span></span>;</span><br></pre></td></tr></table></figure>

<div class="note danger"><p>注意两个模板参数的命名，可以看出迭代器参数的<code>iterator_category</code>类型，一个是<code>input</code>一个是<code>forward</code>。<strong>这是STL中的命名习惯，表示该算法所接受迭代器最低类型要求</strong>，也就是说，<code>first</code>和<code>last</code>只需是<code>input</code>类型及以上都可以，但是<code>result</code>至少得是<code>forward</code>类型的，如果也是<code>input</code>类型，则函数无法正常运行。</p></div>

<p>而根据迭代器指向对象的不同，如是否为<code>POD</code>类型，来决定拷贝对象的方式，来达到效率的提升。关于<code>POD</code>类型，可见<a href="https://choubin.site/2020/01/01/STL1-TraitsAndType-traitsTemplate/" target="_blank" rel="noopener">TinySTL实现项目（一）：traits 技巧与 type_traits 模板</a>。</p>
<p>具体实现如下</p>
<figure class="highlight c++"><figcaption><span>uninitialized.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_copy</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          InputIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ForwardIterator result)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type =</span><br><span class="line">        <span class="keyword">typename</span> mystl::iterator_traits&lt;ForwardIterator&gt;::value_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD = <span class="keyword">typename</span> type_traits&lt;value_type&gt;::is_POD_type;</span><br><span class="line">    <span class="keyword">return</span> uninitialized_copy_aux(first, last, result, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_copy_aux</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              InputIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ForwardIterator result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              _true_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::copy(first, last, result);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> InputIterator, <span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_copy_aux</span><span class="params">(InputIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              InputIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ForwardIterator result,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              _false_type)</span> </span>&#123;</span><br><span class="line">    ForwardIterator cur = result;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; first != last; ++first, ++cur)</span><br><span class="line">            construct(cur, *first);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(result, cur);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如在<code>POD</code>类型的介绍中所说，如果是<code>POD</code>类型，则可以使用<code>memcpy</code>等C函数来提升效率。这里为了不影响代码的阅读逻辑，并且控制项目的复杂度，所以在<code>is_POD</code>为<code>_true_type</code>的重载版本中直接调用<code>copy</code>函数。本项目当前主要专注于容器和算法的设计上，暂未实现自己的<code>copy</code>函数，所以先调用STL中的接口。</p>
<p>事实上，<code>copy</code>函数也不过是对各种数据类型的重载和偏特化罢了，核心思想还是使用<code>traits</code>技巧来进行<code>dismatch</code>，以此提高效率。在思想和技巧上我们已经体现，所以暂时也没必要浪费时间在此。</p>
<div class="note info"><p>关于异常处理，STL的思想是<code>commit or rollback</code>，大概意思就是全部成功或一个不留，如果构造填充的过程出了错，就需要将已构造的部分进行析构，恢复原样。</p></div>

<h3 id="4-2-uninitialized-fill"><a href="#4-2-uninitialized-fill" class="headerlink" title="4.2 uninitialized_fill"></a>4.2 uninitialized_fill</h3><p>该函数也是类似的，只不过是想目标区域填充固定的数，而不是从某一个范围拷贝。</p>
<p>其接口是接受一个范围作为填充目标区域，当然还需要接受一个值作为填充初始值。注意此函数返回值为<code>void</code>，这是STL标准中要求的。直接看代码</p>
<figure class="highlight c++"><figcaption><span>uninitialized.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uninitialized_fill</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          ForwardIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                          <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type =</span><br><span class="line">        <span class="keyword">typename</span> mystl::iterator_traits&lt;ForwardIterator&gt;::value_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD = <span class="keyword">typename</span> type_traits&lt;value_type&gt;::is_POD_type;</span><br><span class="line">    uninitialized_fill_aux(first, last, value, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uninitialized_fill_aux</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ForwardIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              _true_type)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">fill</span>(first, last, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">uninitialized_fill_aux</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              ForwardIterator last,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              <span class="keyword">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                              _false_type)</span> </span>&#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; cur != last; ++cur)</span><br><span class="line">            construct(cur, value);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(first, cur);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-uninitialized-fill-n"><a href="#4-3-uninitialized-fill-n" class="headerlink" title="4.3 uninitialized_fill_n"></a>4.3 uninitialized_fill_n</h3><p>此函数同<code>uninitialized_fill</code>作用类似，只不过只需接受一个迭代器参数表示填充起点，另外接受一个参数表示填充个数。最后其返回值是一个迭代器，指向填充完成后的下一个位置</p>
<figure class="highlight c++"><figcaption><span>uninitialized.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                            <span class="keyword">const</span> T&amp; value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">using</span> value_type =</span><br><span class="line">        <span class="keyword">typename</span> mystl::iterator_traits&lt;ForwardIterator&gt;::value_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD = <span class="keyword">typename</span> type_traits&lt;value_type&gt;::is_POD_type;</span><br><span class="line">    <span class="keyword">return</span> uninitialized_fill_n_aux(first, n, value, is_POD());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n_aux</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                _true_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">std</span>::fill_n(first, n, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> ForwardIterator, <span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> ForwardIterator <span class="title">uninitialized_fill_n_aux</span><span class="params">(ForwardIterator first,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">size_t</span> n,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                <span class="keyword">const</span> T&amp; value,</span></span></span><br><span class="line"><span class="function"><span class="params">                                                _false_type)</span> </span>&#123;</span><br><span class="line">    ForwardIterator cur = first;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="keyword">for</span> (; n != <span class="number">0</span>; --n, ++cur)</span><br><span class="line">            construct(cur, value);</span><br><span class="line">        <span class="keyword">return</span> cur;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (...) &#123;</span><br><span class="line">        destroy(first, cur);</span><br><span class="line">        <span class="keyword">throw</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5 结束语"></a>5 结束语</h2><p>在本部分主要进行了迭代器、反向迭代器以及容器初始化工具的实现，其完整代码同样可以在<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">这里看到</a>。下一篇开始，将开始容器的设计。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL实现项目（三）：具有SGI特色的两级分配器alloc模板类</title>
    <url>/2020/01/07/STL3-SGI2StageAllocator/</url>
    <content><![CDATA[<h2 id="1-SGI-STL-2-91-中空间分配器alloc的设计思想"><a href="#1-SGI-STL-2-91-中空间分配器alloc的设计思想" class="headerlink" title="1 SGI STL 2.91 中空间分配器alloc的设计思想"></a>1 SGI STL 2.91 中空间分配器alloc的设计思想</h2><p>在<a href="https://choubin.site/2020/01/02/STL2-AlloctorAndCtorDtor/" target="_blank" rel="noopener">上篇文章</a>中，我们实现了使用<code>::operator new</code>和<code>::operator delete</code>来分配、释放内存的空间分配器<code>allocator</code>模板类。但在SGI STL 2.91版的源码实现中，其使用的空间分配器并非如此简单，而是以更底层的<code>malloc()</code>、<code>free()</code>来分配、释放内存，其设计哲学在《STL源码剖析》中总结如下：</p>
<div class="note info"><ul><li>向 system heap 要求空间</li><li>考虑多线程状态</li><li>考虑内存不足时的应变措施</li><li>考虑过多小型区块可能造成的<strong>内存碎片（fragment）</strong>问题</li></ul></div>

<p>而其避免<strong>内存碎片问题</strong>的方法就是设计了两级分配器</p>
<ul>
<li><p>第一级分配器：当一次要求的内存<strong>超过</strong>128bytes时使用，其直接使用<code>malloc()</code>、<code>free()</code></p>
</li>
<li><p>第二级分配器：当一次要求的内存<strong>小于</strong>128bytes时使用， 采用了内存池<code>memory pool</code>整理方式，维护了16个链表，这些链表分别负责从8bytes、16bytes、24bytes直到128bytes的16种小型内存块的分配。</p>
</li>
</ul>
<p>其中第一级分配器还考虑了<strong>OOM(out of memory)</strong>时的处理，实现了类似C++中<code>new-handler</code>的机制，使得在内存不足抛出<code>std::bad_alloc</code>异常前，可以调用一个用户自行定义的函数来尝试解决内存不足问题，如果用户没有定义该函数，则直接抛出<code>std::bad_alloc</code>异常。</p>
<p>而在实现中，甚至都没有完全符合STL标准，比如<code>alloc::construct</code>就不存在，这里简单说一下其具体实现。</p>
<h3 id="1-1-SGI-的第一级分配器"><a href="#1-1-SGI-的第一级分配器" class="headerlink" title="1.1 SGI 的第一级分配器"></a>1.1 SGI 的第一级分配器</h3><p>第一级分配器：一个名为<code>__malloc_alloc_template&lt;int inst&gt;</code>的模板类，模板参数实际上并没用上；分别基于<code>malloc()</code>、<code>free()</code>、<code>realloc()</code>来实现<code>allocate()</code>、<code>deallocate()</code>、<code>reallocate()</code>这三个<code>public</code>成员函数；另外拥有一个函数指针类型的静态成员<code>malloc_alloc_oom_handler</code>和设定该静态成员的<code>public</code>成员函数<code>set_malloc_handler</code>，这是用于实现上述<code>new-handler</code>机制的；最后还有两个<code>private</code>的函数<code>oom_malloc</code>、<code>oom_realloc</code>来处理OOM情况，这两个函数会先调用之前的那个函数指针静态成员所指向的函数，然后再尝试分配内存，如果用户没有实现设定该静态成员指向的函数，会直接报错<code>cerr &lt;&lt; “out of memory”</code>然后<code>exit(1)</code>中止程序。部分实现如下：</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">int</span> inst&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> __<span class="title">malloc_alloc_template</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> *<span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span> *, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* __malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> *result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_malloc(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* n */</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">free</span>(p);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> * <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span> *p, <span class="keyword">size_t</span> <span class="comment">/* old_sz */</span>, <span class="keyword">size_t</span> new_sz)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> * result = <span class="built_in">realloc</span>(p, new_sz);</span><br><span class="line">    <span class="keyword">if</span> (<span class="number">0</span> == result) result = oom_realloc(p, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(* set_malloc_handler(<span class="keyword">void</span> (*f)()))</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">void</span> (* old)() = __malloc_alloc_oom_handler;</span><br><span class="line">    __malloc_alloc_oom_handler = f;</span><br><span class="line">    <span class="keyword">return</span>(old);</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h3 id="1-2-SGI-的第二级分配器"><a href="#1-2-SGI-的第二级分配器" class="headerlink" title="1.2 SGI 的第二级分配器"></a>1.2 SGI 的第二级分配器</h3><p>第二级分配器：具体实现有点小复杂，由于本项目使用的第二级分配器基本同SGI的一致，所以具体函数实现留待下文讲解，这里只简单总结一下其思路。同上文所述，其将小于128bytes的内存按照8bytes为间隔，划分为16种大小的内存区块，然后用16条链表来维护这些区块。</p>
<p>比如第一条链表管理8bytes的内存块，假设其有10个节点，这10个节点每个都有8bytes的空间可以拨给用户使用，用户用<code>allocate()</code>请求8bytes大小的空间时，就返回给用户1个节点的空间，此时剩9个节点，如果用户用<code>deallocate()</code>释放了8bytes的空间，那么这个节点又会被回收到这条链表上，又变成了10个节点。其他的链表就是如此依次维护16bytes、24bytes、32bytes等等大小的内存块。</p>
<p>那如果用户请求的bytes数目大小不是8的倍数呢？比如30，分配器就会将其自动上调为32，然后找负责32bytes的链表分配空间。需要说明的是，这里的链表节点使用了<code>union</code>类型，而不是常用的<code>struct</code>，这是因为<code>union</code>类型用在这里更节约空间。</p>
<div class="note info"><p><code>union</code>类型比较特殊，其内部成员可以共享内存，每个<code>union</code>对象分配的内存以其最大的成员而定，这里的最大指的是<code>sizeof()</code>后最大。 </p><p>当多个基本数据类型或复合数据结构要占用同一片内存时，我们要使用联合体；当多种类型，多个对象，多个事物只取其一时（我们姑且通俗地称其为“n 选1”），我们也可以使用联合体来发挥其长处。 </p><p>这里用<code>union</code>实现的链表，每个节点包含一个指向自身类型的指针<code>next</code>和一个<code>char*</code>类型指针，那么其第一个成员<code>next</code>可以用来连接链表，而第二个成员<code>char*</code>又可以表示为一个指向实际内存区块的指针，可以用来分配给用户使用。</p></div>

<p>最终第一级分配器和第二级分配器的实现也并未完全符合STL的标准，比如<code>allocate()</code>的参数就和STL要求的不一样，<code>reallocate()</code>也不是STL要求的，另外<code>allocate::construct()</code>等函数也没有实现。所以SGI还将其包装了一个接口，使分配器的<code>allocate()</code>和<code>deallocate()</code>符合STL标准，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="class"><span class="keyword">class</span> <span class="title">T</span>, <span class="title">class</span> <span class="title">Alloc</span>&gt;</span></span><br><span class="line"><span class="class"><span class="title">class</span> <span class="title">simple_alloc</span> &#123;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> <span class="number">0</span> == n? <span class="number">0</span> : (T*) Alloc::allocate(n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T *<span class="title">allocate</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">return</span> (T*) Alloc::allocate(<span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p, <span class="keyword">size_t</span> n)</span></span></span><br><span class="line"><span class="function">                </span>&#123; <span class="keyword">if</span> (<span class="number">0</span> != n) Alloc::deallocate(p, n * <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T *p)</span></span></span><br><span class="line"><span class="function">                </span>&#123; Alloc::deallocate(p, <span class="keyword">sizeof</span> (T)); &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>实际上，SGI STL的源码中，第二级分配器还考虑了多线程情况，而我们的项目是以学习为目的，自然对复杂程度要有所取舍，故而在我们的实现中只考虑单线程的普通情况。</p>
<p>接下来即是根据SGI STL源码来实现的一个不使用多线程的<code>alloc</code>模板类。在代码上仅做了极小的修改，看完了本项目的实现，也就明白了SGI的实现。</p>
<div class="note warning"><p>为什么本节标题要强调2.91的SGI实现版本呢？因为在部分后续版本的实现中，SGI就去掉了两级分配器和memory poll的实现思想。去掉原因目前我还不知道。。。</p></div>

<h2 id="2-部分考虑和相应改动"><a href="#2-部分考虑和相应改动" class="headerlink" title="2 部分考虑和相应改动"></a>2 部分考虑和相应改动</h2><p>本项目的这部分的实现思路将基本参照 SGI，仅做小部分的改动。</p>
<p>考虑1：在SGI 的实现中，第一级分配器是一个类模板，但是却没有用到模板参数，第二级分配器也是一个类模板，第一个模板参数考虑多线程，第二个模板参数依然没用上。而在我们的实现中，不考虑多线程情况，就没有必要使用多余的模板参数了，甚至没必要使用模板。</p>
<p>改动1：<strong>直接将两级分配器设计为两个普通类</strong>。</p>
<p>考虑2：如上文所述，SGI 对两级分配器的包装是一个带两个参数的模板类<code>simple_alloc</code>，使用时还需要根据宏定义在第二模板参数上确定仅使用第一级分配器还是同时使用两级分配器，然后再将分配器作为模板参数放入，由于命名问题还需要为具化后的<code>simple_alloc</code>定义别名。</p>
<p>改动2：本项目中将其包装的模板改动为<strong>一个参数的模板类</strong>，在该模板的成员函数中<strong>直接调用第二级分配器</strong>，并且为该模板<strong>补充<code>alloc::construct</code>等 STL 要求的标准接口</strong>。另外由于本项目已实现名为<code>allocator</code>的分配器，故而将本部分的分配器包装接口命名为<code>alloc</code>。</p>
<h2 id="3-TinySTL-第一级分配器的实现"><a href="#3-TinySTL-第一级分配器的实现" class="headerlink" title="3 TinySTL 第一级分配器的实现"></a>3 TinySTL 第一级分配器的实现</h2><h3 id="3-1-接口总览"><a href="#3-1-接口总览" class="headerlink" title="3.1 接口总览"></a>3.1 接口总览</h3><p>因为第一级分配器直接使用<code>malloc()</code>来分配内存，这里将其取名为<code>malloc_alloc</code>。在 SGI 的实现中，其是一个类模板，但却并没有使用到其模板参数，所以这里直接将其设计为普通的类。先确定要实现的相应函数和成员，代码如下：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用 malloc 和 free 实现的一级分配器</span></span><br><span class="line"><span class="comment">// 可以由客端设置 OOM 时的 new_handler</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">malloc_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 一个函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> FunPtr = <span class="keyword">void</span> (*)();</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* ptr)</span> </span>&#123; <span class="built_in">free</span>(ptr); &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>, <span class="keyword">size_t</span> new_sz)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FunPtr <span class="title">set_malloc_handler</span><span class="params">(FunPtr f)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 用于处理OOM时的辅助函数</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">oom_malloc</span><span class="params">(<span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">oom_realloc</span><span class="params">(<span class="keyword">void</span>*, <span class="keyword">size_t</span>)</span></span>;</span><br><span class="line">    <span class="comment">// 函数指针类型的静态成员。也可以写成 FunPtr malloc_alloc_oom_handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>可以看到<code>allocate()</code>的返回类型是<code>void</code>指针类型，这里依然是参照 SGI 的设计，<strong>让第一级和第二级分配器所分配的空间都用<code>void</code>指针类型，最后在外层包装的模板类接口上统一转换</strong>，既简单也不会影响效率。</p>
<h3 id="3-2-allocate和deallocate的实现"><a href="#3-2-allocate和deallocate的实现" class="headerlink" title="3.2 allocate和deallocate的实现"></a>3.2 allocate和deallocate的实现</h3><p>先直接来看<code>allocate()</code>的代码实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="built_in">malloc</span>(n);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        result = malloc_alloc::oom_malloc(n);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意其仅接受一个<code>size_t</code>类型的参数<code>n</code>，先调用<code>malloc</code>来分配<strong>大小为<code>n</code>个字节（byte）的内存块</strong>。<strong>这和上篇文章中实现的<code>allocator&lt;T&gt;::allocate(size_t n)</code>不一样，其分配的是大小为<code>n * sizeof(T)</code>个字节的内存块。</strong>如果分配空间失败，则调用内部辅助函数<code>oom_malloc()</code>来继续尝试分配空间。</p>
<div class="note info"><p><code>void* malloc(size_t n_bytes)</code>分配长度为n_bytes字节的内存块。分配成功则返回类型为<code>void</code>指向被分配内存的指针，否则返回空指针<code>NULL</code>。释放<code>malloc</code>分配的内存应使用<code>free()</code>。</p></div>

<p>蓝色背景内容所述，在3.1节的代码中可以看到<code>deallocte()</code>接受一个指针，直接使用<code>free()</code>来释放内存。</p>
<h3 id="3-3-reallocate的实现"><a href="#3-3-reallocate的实现" class="headerlink" title="3.3 reallocate的实现"></a>3.3 reallocate的实现</h3><p>其实最终对外包装的模板类中并没有使用到<code>reallocate()</code>，本着学习的态度，就顺便照着 SGI 的敲了一遍。代码实现如下：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::reallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_sz, <span class="keyword">size_t</span> new_sz) &#123;</span><br><span class="line">    <span class="keyword">void</span>* result = <span class="built_in">realloc</span>(ptr, new_sz);</span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        result = malloc_alloc::oom_realloc(ptr, new_sz);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到跟<code>allocate()</code>相比，仅仅是换成了使用<code>realloc</code>实现</p>
<div class="note info"><p> <code>void* realloc (void* ptr, size_t size)</code>，ptr 为需要重新分配的内存空间指针，size 为新的内存空间的大小。realloc() 对 ptr 指向的内存重新分配 size 大小的空间，size 可比原来的大或者小，还可以不变。当 malloc()、calloc() 分配的内存空间不够用时，就可以用 realloc() 来调整已分配的内存。</p><p>如果 ptr 为 NULL，它的效果和 malloc() 相同；如果 size 的值为 0，那么 ptr 指向的内存空间就会被释放，但是由于没有开辟新的内存空间，所以会返回空指针，类似于调用 free()。 </p></div>

<div class="note warning"><p><code>realloc</code>接受的指针必须是动态内存空间分配成功的指针。比如不能使用<code>int* p</code>、<code>int arr[2]</code>这样的指针，会直接报错。可以说只有<code>malloc()</code>、<code>calloc()</code>、<code>realloc()</code>分配成功成功的指针才能用<code>realloc</code>。</p><p>使用<code>new_ptr=realloc(prt,n)</code>分配内存成功后，ptr绝不能再被使用，只能使用<code>new_ptr</code>。</p><p>扩大内存会复制原来内存到新地址，缩小内存会先被复制再被截取新长度。</p></div>

<h3 id="3-4-new-handler机制的实现"><a href="#3-4-new-handler机制的实现" class="headerlink" title="3.4 new_handler机制的实现"></a>3.4 new_handler机制的实现</h3><p><code>new_handler</code>机制就是，当使用<code>::operator new</code>分配内存不满足需求时，可以在抛出异常之前，调用一个用户实现指定的函数来进行错误处理，这个函数就是所谓的<code>new_handle</code>。而指定这个函数的方法就是使用<code>set_new_handler()</code>，这个函数接受一个函数指针类型，返回的也是函数指针类型。</p>
<p>由于在这里，我们使用<code>malloc</code>而不是<code>::operator new</code>来实现<code>allocate()</code>，所以我们不能直接使用C++现有的<code>new_handler</code>机制，需要我们手动来实现。</p>
<p>实现方法也很简单，如3.1节中的代码所示，我们先在类中声明一个函数指针类型的静态成员，用来指向用户设定的函数。然后在类中声明一个成员函数，用来设定该静态成员。如代码所示。</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">malloc_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">	<span class="comment">// 一个函数指针类型</span></span><br><span class="line">    <span class="keyword">using</span> FunPtr = <span class="keyword">void</span> (*)();</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ...</span><br><span class="line">    <span class="function"><span class="keyword">static</span> FunPtr <span class="title">set_malloc_handler</span><span class="params">(FunPtr f)</span></span>;</span><br><span class="line">	...</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="comment">// 函数指针类型的静态成员。也可以写成 FunPtr malloc_alloc_oom_handler</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="title">void</span> <span class="params">(*malloc_alloc_oom_handler)</span><span class="params">()</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这个设定静态成员的函数即是<code>set_malloc_handler</code>，实现如下</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">typename</span> malloc_alloc::FunPtr malloc_alloc::set_malloc_handler(FunPtr fptr) &#123;</span><br><span class="line">    FunPtr old = malloc_alloc_oom_handler;</span><br><span class="line">    malloc_alloc_oom_handler = fptr;</span><br><span class="line">    <span class="keyword">return</span> old;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>该函数接受一个函数指针类型的参数，返回值也是一个函数指针类型。功能就是将代表<code>handler</code>的静态成员设为用户传进来的函数，最后返回原来的<code>handler</code>函数。</p>
<p>显然上述这个代表<code>handler</code>的函数指针静态成员应该初始化为0或者<code>nullptr</code></p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> (*malloc_alloc::malloc_alloc_oom_handler)() = <span class="number">0</span>;</span><br></pre></td></tr></table></figure>

<h3 id="3-5-OOM时的处理"><a href="#3-5-OOM时的处理" class="headerlink" title="3.5 OOM时的处理"></a>3.5 OOM时的处理</h3><p>3.4节中我们已经实现了<code>new_handler</code>机制，OOM(out of memory)时就会使用到该机制，调用用户设定的函数来处理，期待可以解决内存不足的问题、或者直接输出提示信息中断程序等。</p>
<p>在<code>allocate</code>和<code>reallocate</code>的实现可以中我们看到了，在请求分配内存失败时，也就是OOM时，将会调用两个辅助函数<code>oom_malloc</code>和<code>oom_realloc</code>。这两个函数的实现大同小异，这里先看<code>oom_malloc</code>如何实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::oom_malloc(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">	<span class="comment">// 若用户并未设定 handler 函数，则输出报错信息</span></span><br><span class="line">    <span class="keyword">if</span> (malloc_alloc_oom_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则不断尝试调用 handler 函数，然后用malloc再次请求分配内存，直到分配成功</span></span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        malloc_alloc_oom_handler();</span><br><span class="line">        result = <span class="built_in">malloc</span>(n);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看到函数比较简单，看注释应该就够了。下面看<code>oom_realloc</code>的实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* malloc_alloc::oom_realloc(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> new_sz) &#123;</span><br><span class="line">	<span class="comment">// 若用户未设定 handler 函数，则输出报错信息</span></span><br><span class="line">    <span class="keyword">if</span> (malloc_alloc_oom_handler == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cerr</span> &lt;&lt; <span class="string">"out of memory"</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则不断尝试调用 handler 函数，然后用realloc请求重新分配内存，直到分配成功</span></span><br><span class="line">    <span class="keyword">void</span>* result;</span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        malloc_alloc_oom_handler();</span><br><span class="line">        result = <span class="built_in">realloc</span>(ptr, new_sz);</span><br><span class="line">        <span class="keyword">if</span> (result)</span><br><span class="line">            <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-TinySTL-第二级分配器的实现"><a href="#4-TinySTL-第二级分配器的实现" class="headerlink" title="4 TinySTL 第二级分配器的实现"></a>4 TinySTL 第二级分配器的实现</h2><p>由于在实际使用中是默认调用第二级分配器，然后第二级分配器会根据所需要的内存块大小，来决定是否调用第一级分配器，所以此处将第二级分配器命名为<code>default_alloc</code>。</p>
<p>如1.2节所述，这里使用了内存池(memory pool)机制，用16条链表来维护16种大小的内存块，这些内存块大小是从最小8 bytes，以 8 bytes 为间隔，到最大128 bytes ；当请求的内存小于128 bytes 时，就从相应的链表里，将内存分配出去，若大于128 bytes 就调用第一级分配器。</p>
<p>使用内存池机制的目的主要有两个：</p>
<ul>
<li>减少<code>malloc</code>的调用次数，因为每次调用<code>malloc</code>的时候，其实都需要时间开销去寻找可使用的内存块</li>
<li>减少实际内存开销，因为<code>malloc</code>来分配内存的开销会比实际所需要内存更大，因为需要额外的空间来管理这一块内存；如下图所示，实际需要<code>size</code>大小的内存和最终开销的内存</li>
</ul>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/malloc%E5%86%85%E5%AD%98.png" alt="内存管理"></p>
<p>而这些通过链表来管理的不同大小的内存块从何而来呢？难道需要每次<code>malloc</code>这些大小不一的内存块了吗？这就是<strong>内存池</strong>存在的意义了。</p>
<p>我们可以一次<code>malloc</code>一大块内存，作为<strong>内存池</strong>，然后每次需要特定大小的内存时，从内存池中划拨到相应的链表，然后通过链表去分配。比如我一次<code>malloc</code>了512 bytes，然后这个时候用户请求分配 8 bytes，那我就一次划拨160 个bytes 到管理8 bytes大小内存块的链表上，此时链表有160 / 8 = 20 个节点；然后从这个20 个节点里分一个节点给用户使用。</p>
<p>虽然第一次分配的时候看起来比较麻烦，但之后用户再要求分配 8 bytes时，我就可以直接从链表剩下的19个节点里分给他，没有必要再使用<code>malloc</code>；而用户释放 8 bytes 大小时，我就可以将这 8bytes 回收到管理的链表上。这样我只<code>malloc</code>了一次，却可以满足20次用户要求分配 8 bytes的需求，而释放内存的时候也无须调用<code>free</code>，更改指针指向让其回到链表即可。</p>
<span class="label danger">所以我们可以这么理解，实际上第二级分配器管理的内存也有两部分，一部分是链表维护的各种大小不一的小内存，另一部分则</span>

<span class="label danger">是由`malloc`得来的**内存池**，负责为链表“输血”。</span>

<h3 id="4-1-接口总览"><a href="#4-1-接口总览" class="headerlink" title="4.1 接口总览"></a>4.1 接口总览</h3><p>下面是内存实现的总览：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">default_alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="keyword">enum</span> &#123; ALIGN = <span class="number">8</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; MAX_BYTES = <span class="number">128</span> &#125;;</span><br><span class="line">    <span class="keyword">enum</span> &#123; NFREELISTS = MAX_BYTES / ALIGN &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">union</span> obj &#123;</span><br><span class="line">        <span class="keyword">union</span> obj* next;</span><br><span class="line">        <span class="keyword">char</span> client_data[<span class="number">1</span>];</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* start_free;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">char</span>* end_free;</span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">size_t</span> heap_size;</span><br><span class="line">    <span class="keyword">static</span> obj* <span class="keyword">volatile</span> free_list[NFREELISTS];</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">round_up</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((bytes + ALIGN - <span class="number">1</span>) &amp; ~(ALIGN - <span class="number">1</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">freelist_index</span><span class="params">(<span class="keyword">size_t</span> bytes)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> ((bytes + ALIGN - <span class="number">1</span>) / ALIGN - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">refill</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">char</span>* <span class="title">chunk_alloc</span><span class="params">(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span>&amp; nobjs)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">allocate</span><span class="params">(<span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> n)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span>* <span class="title">reallocate</span><span class="params">(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_size, <span class="keyword">size_t</span> new_size)</span></span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>首先是三个枚举类型，分别表示链表中内存块大小的间隔、最大内存块的大小、以及所需要的维护的链表数量。声明成枚举类型主要是为了方便以后对这些值进行修改。</p>
<p>接着一个是<code>union</code>类型，用来作为链表的节点，使用<code>union</code>的原因上文已有解释，主要是利用其成员共享内存的特点来节约内存的开销。</p>
<p>然后是四个静态成员。<code>start_free</code>和<code>end_free</code>就是用来管理<code>malloc</code>得到的内存池，分别表示内存池的头和尾。<code>heap_size</code>是一个和用户请求分配内存大小相关的值，用户请求的内存越多，该值就会越大，然后在每次内存池用尽，需要重新<code>malloc</code>的时候，会附加上<code>heap_size</code>的一个加权值；这样的结果就是，用户目前使用第二级分配器分配的内存块越多，下次<code>malloc</code>的时候就会分配得更多，其目的还是尽量减少<code>malloc</code>的次数。最后一个成员<code>free_list</code>就是存放16条链表的数组。</p>
<p>注意静态成员需要初始化：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">char</span>* default_alloc::start_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">char</span>* default_alloc::end_free = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">size_t</span> default_alloc::heap_size = <span class="number">0</span>;</span><br><span class="line">default_alloc::obj* <span class="keyword">volatile</span> default_alloc::free_list[NFREELISTS] = &#123;</span><br><span class="line">    <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>还需要介绍两个辅助函数<code>round_up</code>和<code>freelist_index</code>。前一个是用来将传入的参数补为8的倍数，比如请求分配30 bytes 的大小时，就将30补成32。后一个参数用来确定管理内存块的链表在数组<code>free_list</code>中的索引，如传入8，就返回索引0。</p>
<p>其余函数的作用和实现见下文。</p>
<h3 id="4-1-allocate-的实现"><a href="#4-1-allocate-的实现" class="headerlink" title="4.1 allocate 的实现"></a>4.1 allocate 的实现</h3><p><code>allocate</code>的作用我们已经说过多次，这里不同的只是，根据请求空间的大小，找到相应的链表，然后返回链表的一个节点供用户使用。如果发现相应的链表空了，就调用<code>refill</code>来填充链表。直接看实现</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* default_alloc::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 如果请求的大小超过 128 bytes就调用第一级分配器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">128</span>)</span><br><span class="line">        <span class="keyword">return</span> malloc_alloc::allocate(n);</span><br><span class="line">    <span class="comment">// 否则找到相应链表，注意这是一个指向链表头指针的指针</span></span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list = free_list + freelist_index(n);</span><br><span class="line">    obj* result = *my_free_list;</span><br><span class="line">    <span class="comment">// 如果链表为空，就调用 refill 填充链表，refill会直接返回一个相应大小的空间供用户使用</span></span><br><span class="line">    <span class="keyword">if</span> (result == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> refill(n);</span><br><span class="line">    <span class="comment">// 不为空则调整链表，使表头变更到下一个节点</span></span><br><span class="line">    *my_free_list = (*my_free_list)-&gt;next;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(result);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现比较简单，应该看上面注释就足够了，最后不进行静态转换也是可以通过编译的。</p>
<h3 id="4-2-deallocate-的实现"><a href="#4-2-deallocate-的实现" class="headerlink" title="4.2 deallocate 的实现"></a>4.2 deallocate 的实现</h3><p>这里的<code>deallocate</code>和第一级分配器中直接<code>free</code>有所不同，也考虑两种情况：如果需要释放的内存大于128 bytes 则调用第一级分配器，否则就将其回收到相应的链表。这样的设计在最优情况下，自然可以物尽其用，链表达到“收支平衡”，不需要多次调用<code>malloc</code>。下面是实现</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span> default_alloc::deallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 释放空间大于128bytes调用第一级分配器</span></span><br><span class="line">    <span class="keyword">if</span> (n &gt; <span class="number">128</span>) &#123;</span><br><span class="line">        malloc_alloc::deallocate(ptr);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 否则将其回收到相应链表</span></span><br><span class="line">    obj* p = <span class="keyword">static_cast</span>&lt;obj*&gt;(ptr);</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list = free_list + freelist_index(n);</span><br><span class="line">    p-&gt;next = *my_free_list;</span><br><span class="line">    *my_free_list = p;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现比较简单，无非是回收到链表时，将其插到链表表头。</p>
<h3 id="4-3-reallocate-的实现"><a href="#4-3-reallocate-的实现" class="headerlink" title="4.3 reallocate 的实现"></a>4.3 reallocate 的实现</h3><p>第一级分配器中的<code>reallocate</code>是直接通过<code>realloc</code>实现，关于<code>realloc</code>的介绍可以看3.3节中带颜色的字体。下面直接看实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* default_alloc::reallocate(<span class="keyword">void</span>* ptr, <span class="keyword">size_t</span> old_size, <span class="keyword">size_t</span> new_size) &#123;</span><br><span class="line">    <span class="comment">// 若新旧 size 都大于 128 bytes则使用realloc</span></span><br><span class="line">    <span class="keyword">if</span> (old_size &gt; MAX_BYTES &amp;&amp; new_size &gt; MAX_BYTES)</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">realloc</span>(ptr, new_size);</span><br><span class="line">    <span class="comment">// 若在同一个小内存区间没必要操作</span></span><br><span class="line">    <span class="keyword">if</span> (round_up(old_size) == round_up(new_size))</span><br><span class="line">        <span class="keyword">return</span> ptr;</span><br><span class="line">    <span class="comment">// 都不是的话，需要模拟一下ralloc的操作</span></span><br><span class="line">    <span class="comment">// 开辟新内存，复制原来的部分，最后释放原内存</span></span><br><span class="line">    <span class="keyword">void</span>* result = allocate(new_size);</span><br><span class="line">    <span class="keyword">size_t</span> copy_sz = new_size &gt; old_size ? new_size : old_size;</span><br><span class="line">    <span class="built_in">memcpy</span>(result, ptr, copy_sz);</span><br><span class="line">    deallocate(ptr, old_size);</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>内存管理，肯定要秉承谁分配的谁释放的原则。</p>
<p>显然大于128 bytes的话，说明该内存并不是第二级分配器分配的，让他找第一级分配器去。</p>
<p>如果确定是由第二级分配器分配的，就看看新要求的空间大小<code>new_size</code>跟原来的大小<code>old_size</code>在不在一个内存区间上，比如<code>old_size</code>是20 bytes，<code>new_size</code>是24 bytes，都在(16,24]区间里；因为分配的时候，如果要求 20 bytes，实际还是会给24 bytes，所以其实此时内存大小是满足需求的，直接用原来的就行，没必要操作。</p>
<p>排除以上情况以外，就需要新开辟一块大小为<code>new_size</code>，然后将原来的部分复制过来，复制部分肯定是不会超过原来的大小，也不会超过新长度，反正就是谁小取谁；最后还要记得释放原来的内存，调用<code>deallocate</code>即可。</p>
<h3 id="4-4-refill-的实现"><a href="#4-4-refill-的实现" class="headerlink" title="4.4 refill 的实现"></a>4.4 refill 的实现</h3><p>在<code>allocate</code>函数中，当对应所需内存大小的链表为空时，需要调用<code>refill</code>来为用户提供内存，除此以外，<code>refill</code>还会为填充对应链表，在下次请求相同大小内存时，就可以直接从链表中取了。下面是其实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">void</span>* default_alloc::refill(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="comment">// 设定请求相应小内存块节点的个数</span></span><br><span class="line">    <span class="keyword">int</span> nobjs = <span class="number">20</span>;</span><br><span class="line">    <span class="comment">// chunk_alloc会从内存池中划拨相应大小的内存供其使用</span></span><br><span class="line">    <span class="comment">// 这里nobjs是传引用，会修改nobjs的值告知实际返回多少个节点</span></span><br><span class="line">    <span class="keyword">char</span>* chunk = chunk_alloc(n, nobjs);</span><br><span class="line">    <span class="comment">// 如果只返回了1个节点大小的空间，则直接提供给用户使用</span></span><br><span class="line">    <span class="keyword">if</span> (nobjs == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(chunk);</span><br><span class="line">    <span class="comment">// 多于1个节点则将剩下节点填充到相应链表</span></span><br><span class="line">    <span class="keyword">void</span>* result = <span class="keyword">static_cast</span>&lt;<span class="keyword">void</span>*&gt;(chunk);</span><br><span class="line">    obj *next_obj, *current_obj;</span><br><span class="line">    obj* <span class="keyword">volatile</span>* my_free_list = free_list + freelist_index(n);</span><br><span class="line">    *my_free_list = next_obj = (obj*)(chunk + n);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>;; ++i) &#123;</span><br><span class="line">        current_obj = next_obj;</span><br><span class="line">        next_obj = (obj*)((<span class="keyword">char</span>*)next_obj + n);</span><br><span class="line">        <span class="keyword">if</span> (nobjs - <span class="number">1</span> == i) &#123;</span><br><span class="line">            current_obj-&gt;next = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            current_obj-&gt;next = next_obj;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实际实现并不复杂，可以看到，当对应的链表为空的时候，默认会请求20个节点的大小，比如这个链表管理的是64 bytes的大小，那么就会向内存池请求 20 * 64 bytes的空间，然后将其中的19个放到链表中，留1一个直接返回给用户使用（<code>allocate</code>中对<code>refill</code>的调用）。</p>
<p>值得说明的是，<code>chunk_alloc</code>函数会根据当前内存池的大小，来决定实际返回的个数，并通过传引用<code>objs</code>参数对其修改，达到告知的目的。接上面的例子，比如现在内存池中只有64 bytes的大小了，那么<code>chunk_alloc</code>就会只返回64 bytes，解解燃眉之急，然后修改objs的值为1，当然要是有128 bytes，那就返回2个；但是如果内存池里连64 bytes的大小都没了，就会<code>malloc</code>一次，取得足够大的空间，返回20个。具体实现见下一节。</p>
<h3 id="4-5-chunk-alloc-的实现"><a href="#4-5-chunk-alloc-的实现" class="headerlink" title="4.5 chunk_alloc 的实现"></a>4.5 chunk_alloc 的实现</h3><p>如4.4节所述，<code>chunk_alloc</code>函数作用就是在链表的内存需要补充时，从内存池中划拨一部分内存给<code>refill</code>使用，若是内存池不够用了，就<code>malloc</code>一大块内存，保证满足当前的需求之外，还能留着用。先直接看实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="keyword">char</span>* default_alloc::chunk_alloc(<span class="keyword">size_t</span> <span class="built_in">size</span>, <span class="keyword">int</span>&amp; nobjs) &#123;</span><br><span class="line">    <span class="keyword">char</span>* result;</span><br><span class="line">    <span class="keyword">size_t</span> total_bytes = <span class="built_in">size</span> * nobjs;</span><br><span class="line">    <span class="keyword">size_t</span> bytes_left = end_free - start_free;</span><br><span class="line">    <span class="comment">// 若原本的内存池剩下的空间能够满足需求，直接划拨</span></span><br><span class="line">    <span class="keyword">if</span> (bytes_left &gt;= total_bytes) &#123;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += total_bytes;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 若剩下的内存能够提供至少1个节点大小，则尽可能划拨</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (bytes_left &gt;= <span class="built_in">size</span>) &#123;</span><br><span class="line">        nobjs = bytes_left / <span class="built_in">size</span>;</span><br><span class="line">        result = start_free;</span><br><span class="line">        start_free += nobjs * <span class="built_in">size</span>;</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="comment">// 否则使用malloc请求（当前需求*2+历史需求/16）的大小</span></span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">size_t</span> bytes_to_get = <span class="number">2</span> * total_bytes + round_up(heap_size &gt;&gt; <span class="number">4</span>);</span><br><span class="line">        <span class="comment">// 检查目前剩下的空间够不够划拨给其他更小内存块的链表</span></span><br><span class="line">        <span class="keyword">if</span> (bytes_left &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list =</span><br><span class="line">                free_list + freelist_index(bytes_left);</span><br><span class="line">            ((obj*)start_free)-&gt;next = *my_free_list;</span><br><span class="line">            *my_free_list = (obj*)start_free;</span><br><span class="line">        &#125;</span><br><span class="line">        start_free = (<span class="keyword">char</span>*)<span class="built_in">malloc</span>(bytes_to_get);</span><br><span class="line">        <span class="comment">// malloc失败的话，从更内存池的链表寻求空间，并将剩下空间放到内存池中</span></span><br><span class="line">        <span class="keyword">if</span> (start_free == <span class="number">0</span>) &#123;</span><br><span class="line">            obj* <span class="keyword">volatile</span>* my_free_list;</span><br><span class="line">            obj* ptr = *my_free_list;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="built_in">size</span>; i &lt;= MAX_BYTES; i += ALIGN) &#123;</span><br><span class="line">                my_free_list = free_list + freelist_index(i);</span><br><span class="line">                ptr = *my_free_list;</span><br><span class="line">                <span class="keyword">if</span> (ptr != <span class="number">0</span>) &#123;</span><br><span class="line">                    *my_free_list = ptr-&gt;next;</span><br><span class="line">                    start_free = (<span class="keyword">char</span>*)ptr;</span><br><span class="line">                    end_free = start_free + i;</span><br><span class="line">                    <span class="keyword">return</span> chunk_alloc(<span class="built_in">size</span>, nobjs);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="comment">// 更大链表也没有空间了，试试第一级分配器的new_handler机制</span></span><br><span class="line">            end_free = <span class="number">0</span>;</span><br><span class="line">            start_free = (<span class="keyword">char</span>*)malloc_alloc::allocate(bytes_to_get);</span><br><span class="line">        &#125;</span><br><span class="line">        heap_size += bytes_to_get;</span><br><span class="line">        end_free = start_free + bytes_to_get;</span><br><span class="line">        <span class="comment">// malloc成功,递归调用自己向refill划拨空间</span></span><br><span class="line">        <span class="keyword">return</span> chunk_alloc(<span class="built_in">size</span>, nobjs);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>实现逻辑并不复杂：当内存池的空间够分配1个以上节点的时候，会尽可能地满足需求，划拨空间；当内存完全不够的时候就<code>malloc</code>一大块。</p>
<p>值得一说的是，当<code>malloc</code>失败的时候设计非常细致，可以做到对已有内存充分利用，没有丝毫浪费。首先使用<code>malloc</code>前就先检查，剩下的空间够不够分配给其他更小的链表，物尽其用；然后如果<code>malloc</code>成功了，皆大欢喜，再次递归地调用自己，向链表(实际为<code>refill</code>函数)划拨空间；如果<code>malloc</code>失败了，先检查其他管理更内存池的链表中有没有空间可以使用，可以的话，先拿一个节点来用，并且这个节点剩下还得放回内存池，如果这些链表都空了，那就调用第一级分配器，毕竟第一级分配器还实现了<code>new_handler</code>机制，也许能派上用场。</p>
<h2 id="5-TinySTL-类模板alloc的包装"><a href="#5-TinySTL-类模板alloc的包装" class="headerlink" title="5 TinySTL 类模板alloc的包装"></a>5 TinySTL 类模板alloc的包装</h2><p>在第3节和第4节实现的两级分配器，只是两个普通类，并且接口不符合STL要求。所以需要用一个类模板对其包装，过程也很简单，顺便也为其实现了<code>construct</code>、<code>destroy</code>、<code>address</code>、<code>max_size</code>、<code>rebind</code>接口，其实现与<a href="https://choubin.site/2020/01/02/STL2-AlloctorAndCtorDtor/" target="_blank" rel="noopener">上篇文章</a>中<code>allocator</code>的实现基本一致。下面是其部分实现：</p>
<figure class="highlight c++"><figcaption><span>alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// SGI STL 特色分配器，需要一个模板参数，具有 STL 标准接口</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">alloc</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类型别名定义</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer     = <span class="keyword">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference   = <span class="keyword">const</span> T&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type         = <span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类接口，使用静态函数实现可以使频繁调用下减小开销</span></span><br><span class="line">    <span class="comment">// 负责分配内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">allocate</span><span class="params">(size_type n)</span></span>;</span><br><span class="line">    <span class="comment">// 负责释放内存</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T*, size_type n)</span></span>;</span><br><span class="line">    <span class="comment">// 负责构造对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, T&amp;&amp; value)</span></span>;</span><br><span class="line">    <span class="comment">// 负责析构对象</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* first, T* last)</span></span>;</span><br><span class="line">    <span class="comment">// 获取某对象的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T* <span class="title">address</span><span class="params">(T&amp; val)</span></span>;</span><br><span class="line">    <span class="comment">// 获取可配置T类型对象的最大数目</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t <span class="title">max_size</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="comment">// 使T类型的alloctor可以为U类型的对象分配内存</span></span><br><span class="line">    <span class="keyword">template</span> &lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">        <span class="keyword">using</span> other = alloc&lt;U&gt;;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* alloc&lt;T&gt;::allocate(<span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">return</span> n == <span class="number">0</span> ? <span class="number">0</span> : <span class="keyword">static_cast</span>&lt;T*&gt;(default_alloc::allocate(n * <span class="keyword">sizeof</span>(T)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* alloc&lt;T&gt;::allocate() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(default_alloc::allocate(<span class="keyword">sizeof</span>(T)));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> alloc&lt;T&gt;::deallocate(T* ptr, <span class="keyword">size_t</span> n) &#123;</span><br><span class="line">    <span class="keyword">if</span> (n != <span class="number">0</span>)</span><br><span class="line">        default_alloc::deallocate((<span class="keyword">void</span>*)ptr, n * <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> alloc&lt;T&gt;::deallocate(T* ptr) &#123;</span><br><span class="line">    <span class="keyword">if</span> (ptr)</span><br><span class="line">        default_alloc::deallocate((<span class="keyword">void</span>*)ptr, <span class="keyword">sizeof</span>(T));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于其他接口的函数实现与<a href="https://choubin.site/2020/01/02/STL2-AlloctorAndCtorDtor/" target="_blank" rel="noopener">上篇文章</a>中的完全一致，所以就不放上来了，<strong>完整代码</strong>可以参见<a href="https://github.com/Lammmmmmm/TinySTL/blob/master/alloc.h" target="_blank" rel="noopener">我的github项目里的alloc.h</a>。</p>
<h2 id="6-简单的性能分析和测试"><a href="#6-简单的性能分析和测试" class="headerlink" title="6 简单的性能分析和测试"></a>6 简单的性能分析和测试</h2><p>包括上篇文章中的<code>allocator</code>，目前在 TinySTL 项目中我们已经实现了两种分配器，但尚未实现容器，所以我们可以先使用 STL 库中现有的容器对两种分配器做个小测试，对其性能做个对比。</p>
<p>由于<code>vector</code>容器每次使用分配器请求空间的时候，会请求现在长度的两倍，比如<code>vector&lt;int&gt;</code>，一个<code>int</code>在一般的机器上面长度是4B，即32bytes，当<code>vector&lt;int&gt;</code>原来长度等于5时，再次扩容长度就会变成10，一次就请求了<code>5*32=160bytes</code>，这之后再插入数据已经不会再调用第二级分配器了。</p>
<p>因此，如果向<code>vector&lt;int&gt;</code>中插入1000000个数，无非就是<code>operator new</code>和<code>malloc</code>的差距，然而实际上<code>operator new</code>就是用<code>malloc</code>实现的，所以性能差别不大。</p>
<p>所以，我们可以使用<code>list&lt;int&gt;</code>来对两种分配器进行测试，因为<code>list</code>内部就是个双向链表，每插一个<code>int</code>类型就会调用分配器请求一个32bytes的大小。测试代码如下</p>
<figure class="highlight c++"><figcaption><span>test_alloc.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">enum</span> &#123; NUMBERS = <span class="number">10000000</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test_alloc</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">// test of list</span></span><br><span class="line">    <span class="comment">// test of push_back</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>&gt; list1; <span class="comment">// std 默认分配器</span></span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>, mystl::allocator&lt;<span class="keyword">int</span>&gt;&gt; list2;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">list</span>&lt;<span class="keyword">int</span>, mystl::alloc&lt;<span class="keyword">int</span>&gt;&gt; list3;</span><br><span class="line">    <span class="keyword">clock_t</span> start = clock();</span><br><span class="line">    <span class="comment">// srand(time(NULL));</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUMBERS; ++i)</span><br><span class="line">        list1.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">clock_t</span> <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time to insert "</span> &lt;&lt; NUMBERS</span><br><span class="line">         &lt;&lt; <span class="string">" numbers in list with STL alloctor: "</span></span><br><span class="line">         &lt;&lt; <span class="built_in">end</span> - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUMBERS; ++i)</span><br><span class="line">        list2.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time to insert "</span> &lt;&lt; NUMBERS</span><br><span class="line">         &lt;&lt; <span class="string">" numbers in list with mystl alloctor: "</span></span><br><span class="line">         &lt;&lt; <span class="built_in">end</span> - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    start = clock();</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; NUMBERS; ++i)</span><br><span class="line">        list3.push_back(<span class="number">1</span>);</span><br><span class="line">    <span class="built_in">end</span> = clock();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="string">"Time to insert "</span> &lt;&lt; NUMBERS</span><br><span class="line">         &lt;&lt; <span class="string">" numbers in list with mystl SGI alloc: "</span></span><br><span class="line">         &lt;&lt; <span class="built_in">end</span> - start &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>本来打算插入随机数的，想了想觉得没必要，还浪费调用<code>rand()</code>的时间，万一每次<code>rand()</code>的计算时间还不一样就不够客观了。所以直接插入1。在我的环境下跑了3次的结果如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with STL alloctor: 1093750</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl alloctor: 1078125</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl SGI alloc: 921875</span><br><span class="line"></span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with STL alloctor: 1140625</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl alloctor: 1109375</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl SGI alloc: 921875</span><br><span class="line"></span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with STL alloctor: 1187500</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl alloctor: 1359375</span><br><span class="line">Time to insert 10000000 numbers <span class="keyword">in</span> list with mystl SGI alloc: 1140625</span><br></pre></td></tr></table></figure>

<p>可以看到，在以上的测试用例中，本篇文章中实现的<code>alloc</code>分配器性能不仅比上篇文章中的<code>allocator</code>强，甚至比STL默认的分配器表现得还要好。这其实也很正常，毕竟人家STL默认的分配器需要考虑各种情况下的性能，其覆盖的测试用例和测试场景海了去了，平均性能必然是没法比的，毕竟我们参照的是20年前的代码了。。。</p>
<p>关于分配器的实现，已经告一段落，接下来将开始准备重头戏容器的实现。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL实现项目（二）：空间分配器allocator与全局construct、destroy</title>
    <url>/2020/01/02/STL2-AlloctorAndCtorDtor/</url>
    <content><![CDATA[<p>本篇文章是TinySTL实现的系列文章的第二篇，介绍了<code>allocator</code>模板类的作用和实现，以及其使用到的全局<code>construct</code>、<code>destroy</code>函数的实现。相关代码依然可以在<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">我的github</a>。</p>
<h2 id="1-allocator-的作用"><a href="#1-allocator-的作用" class="headerlink" title="1 allocator 的作用"></a>1 allocator 的作用</h2><p>关于为什么要有<code>allocator</code>类知乎上有专门的讨论，这里简单总结一下<code>allocator</code>的作用。</p>
<p>在C++中常用的内存配置和释放操作一般会使用<code>new</code>和<code>delete</code>，如下</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> &#123;</span> ... &#125;;</span><br><span class="line">Foo* ptr = <span class="keyword">new</span> Foo;	<span class="comment">// 配置内存，然后构造对象</span></span><br><span class="line"><span class="keyword">delete</span> ptr;		    <span class="comment">// 调用对象的析构函数将对象析构，然后释放内存</span></span><br></pre></td></tr></table></figure>

<p>如同注释所说，<code>new</code>其实包含了两步操作：</p>
<ul>
<li>调用<code>::operator new</code>配置内存</li>
<li>调用类构造函数<code>Foo:Foo()</code>来构造对象</li>
</ul>
<p><code>delete</code>也包含了两步操作：</p>
<ul>
<li>调用类析构函数<code>Foo:~Foo()</code>将对象析构</li>
<li>调用<code>::operator delete</code>来释放对象所占的内存</li>
</ul>
<p>这里简单解释一下什么是<code>::perator new</code>和<code>::operator delete</code>：</p>
<div class="note info"><p>上文的<code>new</code>也被称为<code>new operator</code>，如上所述包含了分配内存、构造对象两步操作，不能被重载；</p><p>而<code>::operator new</code>接受一个类型为<code>size_t</code>的参数作为要求的空间大小，<strong>只分配所要求的空间</strong>，而不调用相关对象的构造函数。可以被重载。</p><p><code>::operator delete</code>类似，一般接受一个指针类型的参数，<strong>只释放指针所占的内存</strong>，可以被重载。</p></div>

<p>在STL里面<code>allocator</code>的作用就是将以上<code>new</code>和<code>delete</code>的两步操作区分开来，用<code>allocator::allocate()</code>来分配内存，用<code>::construct()</code>来构造对象，用<code>allocator::deallocate()</code>释放内存，用<code>::destroy()</code>来析构对象。主要用在为各种容器如<code>vector</code>、<code>list</code>分配空间完成构造。</p>
<p>这样的好处就是，有时已经有现成的内存空间可以用了，这时我想构造对象的时候就直接用<code>construct()</code>，而无需花费时间去寻找新的一块内存，然后再分配内存，最后才能构造对象。</p>
<div class="note danger"><p>C++中内存管理十分重要，要建立好概念，分配内存对应释放内存，构造对应析构。例如<code>malloc()</code>对应<code>free()</code>，<code>construct</code>对应<code>destroy</code>，<code>new</code>对应<code>delete</code>。</p></div>

<h2 id="2-简单的allocator类实现"><a href="#2-简单的allocator类实现" class="headerlink" title="2 简单的allocator类实现"></a>2 简单的allocator类实现</h2><p>在STL标准中，要求了<code>allocator</code>具有以下接口</p>
<figure class="highlight c++"><figcaption><span>allocator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">allocator</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类型别名定义</span></span><br><span class="line">    <span class="keyword">using</span> value_type        = T;</span><br><span class="line">    <span class="keyword">using</span> pointer           = T*;</span><br><span class="line">    <span class="keyword">using</span> const_pointer     = <span class="keyword">const</span> T*;</span><br><span class="line">    <span class="keyword">using</span> reference         = T&amp;;</span><br><span class="line">    <span class="keyword">using</span> const_reference   = <span class="keyword">const</span> T&amp;;</span><br><span class="line">    <span class="keyword">using</span> size_type         = <span class="keyword">size_t</span>;</span><br><span class="line">    <span class="keyword">using</span> difference_type   = <span class="keyword">ptrdiff_t</span>;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">// STL 要求的类接口，使用静态函数实现可以使频繁调用下减小开销</span></span><br><span class="line">    <span class="comment">// 负责分配内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> T*	<span class="title">allocate</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> T*	<span class="title">allocate</span><span class="params">(size_type n)</span></span>;</span><br><span class="line">	<span class="comment">// 负责释放内存</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">deallocate</span><span class="params">(T*, size_type n)</span></span>;</span><br><span class="line">	<span class="comment">// 负责构造对象</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, <span class="keyword">const</span> T&amp; value)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T* ptr, T&amp;&amp; value)</span></span>;</span><br><span class="line">	<span class="comment">// 负责析构对象</span></span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span></span>;</span><br><span class="line">	<span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* first, T* last)</span></span>;</span><br><span class="line">	<span class="comment">// 获取某对象的地址</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> T*       <span class="title">address</span><span class="params">(T&amp; val)</span></span>;</span><br><span class="line">    <span class="comment">// 获取可配置T类型对象的最大数目</span></span><br><span class="line">    <span class="function"><span class="keyword">static</span> size_t   <span class="title">max_size</span><span class="params">()</span></span>;</span><br><span class="line">	<span class="comment">// 使T类型的alloctor可以为U类型的对象分配内存</span></span><br><span class="line">    <span class="keyword">template</span>&lt;<span class="keyword">typename</span> U&gt;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rebind</span> &#123;</span></span><br><span class="line">        <span class="keyword">using</span> other = allocator&lt;U&gt;;</span><br><span class="line">    &#125;; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>从上述代码可以看出，<code>allocator</code>类主要分为类型别名定义的接口和“干活”接口。</p>
<p>其中类型别名定义部分在STL模板类的实现里非常常见，包括后续的各种迭代器和容器如<code>vector</code>、<code>list</code>等内部都有各种别名定义，且接口基本统一。其作用类似<a href="https://choubin.site/2020/01/01/STL1-TraitsAndType-traitsTemplate/" target="_blank" rel="noopener">本系列上篇</a>所说<code>traits</code>技巧，可以通过这些统一的内嵌别名定义，从模板类或其对象里直接取得所需类型，方便函数的实现和使用。后续在迭代器和容器设计的部分将会看到。</p>
<p>而“干活”的接口主要就是负责分配内存、释放内存、构造/析构对象，显然如第一节所说，我们可以使用<code>::operator new</code>、<code>::operator delete</code>、对象的构造/析构函数来实现这些功能。</p>
<p>注意这些干活的接口都是以类中的<strong>静态成员函数</strong>实现的，为什么要用静态函数？<strong>依然是为了效率</strong>。 </p>
<div class="note info"><p>普通的成员函数一般都隐含一个<code>this</code>指针，静态成员函数由于不与任何对象相联系，故而不具有<code>this</code>指针。</p><p>正是由于没有<code>this</code>指针的额外开销，因此静态成员函数与类的普通成员函数相比<strong>速度会有少许提升</strong>。同时调用静态成员函数时既可以通过类的对象、指向类对象的指针来调用，也<strong>可以直接使用类名来调用</strong>，这样就节省了创建对象的开销。</p><p>也正是因为以上原因，静态成员之间可以相互访问，但不能访问非静态成员函数和非静态数据成员</p></div>

<p>部分实现如下</p>
<figure class="highlight c++"><figcaption><span>allocator.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用::operator new实现，分配内存并返回空指针</span></span><br><span class="line"><span class="comment">// 使用static_cast将返回的void指针转换为目标类型的指针</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line">T* allocator&lt;T&gt;::allocate(size_type n) &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">static_cast</span>&lt;T*&gt;(::<span class="keyword">operator</span> <span class="keyword">new</span>(n * <span class="keyword">sizeof</span>(T)));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 使用::operator delete释放指针指向内存</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::deallocate(T* ptr) &#123;</span><br><span class="line">	<span class="keyword">if</span> (ptr != <span class="literal">nullptr</span>) ::<span class="function"><span class="keyword">operator</span> <span class="title">delete</span><span class="params">(ptr)</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责构造对象，对全局函数construct()的调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::construct(T* ptr) &#123;</span><br><span class="line">	mystl::construct(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::construct(T* ptr, <span class="keyword">const</span> T&amp; value) &#123;</span><br><span class="line">	mystl::construct(ptr, value);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::construct(T* ptr, T&amp;&amp; value) &#123;</span><br><span class="line">	mystl::construct(ptr, mystl::<span class="built_in">move</span>(value));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 负责析构对象，对全局函数destroy()的调用</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::destroy(T* ptr) &#123;</span><br><span class="line">	mystl::destroy(ptr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="keyword">void</span> allocator&lt;T&gt;::destroy(T* first, T* last) &#123;</span><br><span class="line">	mystl::destroy(first, last);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>allocate()</code>的实现上，用了<code>static_cast</code>静态转换，这是因为<code>::operator new</code>返回的是<code>void*</code>类型，需要做一个强制类型转换来确保类型安全。</p>
<div class="note info"><ul><li><p>编译器隐式执行的任何类型转换都可以由<code>static_cast</code>来完成，比如<code>int</code>与<code>float</code>、<code>double</code>与<code>char</code>、<code>enum</code>与<code>int</code>之间的转换等</p></li><li><p>使用<code>static_cast</code>可以找回存放在<code>void*</code>指针中的值</p></li><li><p><code>static_cast</code>可以把任何类型的表达式转换成<code>void</code>类型</p></li><li><p><code>static_cast</code>把任何类型的表达式转换成<code>void</code>类型</p></li><li><p>与<code>const_cast</code>相比，<code>static_cast</code>不能改变变量的<code>const</code>属性，也包括<code>volitale</code>或<code>__unaligned</code>属性</p></li></ul></div>

<p>以上实现都在 TinySTL 项目的头文件 <code>allocator.h</code>中。</p>
<p>那么<code>allocator&lt;T&gt;::construct()</code>和<code>allocator&lt;T&gt;::destroy()</code>分别调用的全局<code>construct()</code>和<code>destroy()</code>函数又是什么呢？见下一小节介绍。</p>
<h2 id="3-全局construct-和destroy"><a href="#3-全局construct-和destroy" class="headerlink" title="3 全局construct()和destroy()"></a>3 全局<code>construct()</code>和<code>destroy()</code></h2><p>顾名思义，全局<code>construct()</code>的作用就是构造对象。在上一节中，我们知道分配内存的操作已经由<code>allocator&lt;T&gt;::allocate()</code>完成了，而这个<code>construct()</code>，就是将一个初值设定到已经分配好的的空间上去。因此其需要两个参数，一个是指针来表示内存的位置，另一个是我们希望设定的初值。其中一个实现版本如下：</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 使用了两个模板参数，并使用类型转换</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T1, <span class="keyword">typename</span> T2&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">construct</span><span class="params">(T1* ptr, <span class="keyword">const</span> T2&amp; value)</span> </span>&#123; <span class="keyword">new</span>(ptr) T1(value); &#125; <span class="comment">// placement new</span></span><br></pre></td></tr></table></figure>

<p>这里用两个模板参数的好处是可以使得函数在使用上更具“通用性”，同时使用了强制类型转换，使得不会产生隐式转换的警告。</p>
<div class="note danger"><p>这里的<code>new</code>不同于第一节中提到的<code>new operator</code>和<code>operator new</code>，而是所谓的<code>placement new</code>。其实<code>placement new</code>只是<code>operator new</code>的一个重载版本。它并不分配内存，返回值是指向已分配好内存的指针。其作用就是在已分配的内存中创建一个对象，这是<code>new</code>做不到的。</p><p><code>placement new</code>的作用是构造对象，故而对应了析构。其对象在使用结束后要记得析构。</p></div>

<p>上文已经强调了构造对应了析构，显然<code>destroy()</code>的作用就是将对象析构了，那么其实现就可以非常简单，只需调用对象的析构函数即可。</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 单个参数的全局 destroy 函数，直接调用对象的析构函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(T* ptr)</span> </span>&#123; ptr -&gt;~T(); &#125;</span><br></pre></td></tr></table></figure>

<p>另外<code>destroy()</code>还有两个参数的重载版本，其接受两个迭代器，表示将一个范围内的对象析构。</p>
<p>而在本系列的<a href="https://choubin.site/2020/01/01/STL1-TraitsAndType-traitsTemplate/" target="_blank" rel="noopener">上篇文章</a>中已经介绍了POD类型，并提到了<code>trivial destructor</code>的概念。在对大范围的对象析构的时候，如果我们事先得知该对象的类型具有<code>trivial destructor</code>，即所谓的“平凡”或者说无意义的析构函数，那么我们就没有必要浪费开销来挨个调用这些无关痛痒的析构函数。</p>
<p>为什么说无关痛痒？因为并不涉及外部内存，对象本身的内存可以继续复用，所以<strong>不调用也不会影响之后的内存释放而造成内存泄露</strong>。只有在对象类型具有<code>non-trivial destructor</code>的时候，才有必要一次次调用其析构函数。</p>
<p>总之，如果得知对象类型具有<code>trivial destructor</code>，那么我们的<code>destroy()</code>函数可以什么也不做，无需付出复杂度为O(n)的多余开销，大大地提升了程序效率。所以我们需要针对这点对<code>destroy()</code>进行优化。代码如下</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// destroy()内部调用的函数，根据对象类型是否有trivial destructor进行重载</span></span><br><span class="line"><span class="comment">// aux 为 auxiliary 缩写，表示其是辅助的函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy_aux</span><span class="params">(ForwardIterator first, ForwardIterator last, _true_type)</span> </span>&#123; &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy_aux</span><span class="params">(ForwardIterator first, ForwardIterator last, _false_type)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(; first != last; ++first)</span><br><span class="line">        destroy(first);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 两个参数的全局 destroy 函数，根据其是否具有 trivial 析构函数进行重载</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">	<span class="comment">// value_type()函数可以取得迭代器指向对象的类型，注意此时还未实现</span></span><br><span class="line">    <span class="keyword">using</span> is_trivial_dtor =<span class="keyword">typename</span> type_traits&lt;value_type(first)&gt;::has_trivial_destructor;</span><br><span class="line">    destroy_aux(first, last, is_trivial_dtor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>destroy()</code>函数在接受到两个迭代器以后，先用<code>value_type()</code>函数取得迭代器所指向对象的类型，然后将类型放入<code>type_traits</code>模板中，调用其内嵌的类型别名定义，创建一个类型为<code>_true_type</code>或者<code>_false_true</code>的对象作为第三个参数，来调用辅助函数<code>destroy_aux</code>，以此判断迭代器指向的对象是否拥有<code>trivial destructor</code>。</p>
<p>可以看到以上函数内部并不复杂，实际上是只需要一两条语句就可以完成的“小操作”，将这些小操作写成函数的好处有很多，比如方便阅读、修改、重用、统一行为。但调用函数会比使用等价的表达式慢很多：大多数时候，调用前要先保存寄存器，并在返回时恢复，复制实参，程序还必须转向一个新位置执行。</p>
<p>为了避免调用函数带来的开销，我们可以使用<code>inline</code>关键字将函数变为内联函数，内联函数会在程序的调用点上“内联地”展开；并且函数被内联后，编译器可以通过上下文相关的优化的技术对结果代码执行更深入的优化。最终达到提升效率的目的。</p>
<p>下面对<code>inline</code>关键字做一个简单记录。</p>
<div class="note info"><ul><li><p>关键字<code>inline</code>必须<strong>与函数定义体放在一起</strong>才能内联。</p></li><li><p>内联函数<strong>最好放入头文件</strong>，否则需要在每个调用的源文件中重复地定义。</p></li><li><p>内联函数省去了函数调用的开销，包括参数压栈、跳转、退栈和返回等操作。</p></li><li><p>内联函数以代码膨胀（拷贝）为代价，在过大函数上滥用会导致总代码量增大，消耗更多内存，Google C++规范中建议<strong>函数少于10行</strong>时才定义为内联函数。</p></li><li><p>若函数内部代码的执行时间远比函数调用开销大，则<code>inline</code>的效率收益很低，如出现<strong>循环或其他复杂的控制结构</strong>，此时不宜使用。</p></li><li><p>类的构造/析构函数可能包含隐藏行为，如调用基类或成员对象的构造/析构函数，不应轻易内联。</p></li><li><p>实际的实现中，<code>inline</code>是对编译器的请求，优秀的编译器可以根据函数定义取消不值得的内联，也有可能自动内联一些简单函数。</p></li><li><p>根据上条，<strong><code>inline</code>不应出现在函数声明中</strong>（不是不能）。</p></li></ul></div>

<h2 id="4-测试"><a href="#4-测试" class="headerlink" title="4 测试"></a>4 测试</h2><p>我们这里已经写好了<code>allocator</code>类，那么如何使用它呢？</p>
<p>这里可以做一个简单的小测试，来测试我们写的<code>allocator</code>能否用于现有的<code>std::vector</code>，验证其有效性。</p>
<p>如果目前并未实现<code>iterator_traits</code>模板类和<code>value_type</code>，测试之前还需要对<code>construct.h</code>文件中的<code>destroy()</code>做一点小修改。</p>
<figure class="highlight c++"><figcaption><span>construct.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> ForwardIterator&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">destroy</span><span class="params">(ForwardIterator first, ForwardIterator last)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 由于暂未实现 mystl::iterator_traits，故而使用 std 中已有接口</span></span><br><span class="line">    <span class="keyword">using</span> value_type = <span class="keyword">typename</span> <span class="built_in">std</span>::iterator_traits&lt;ForwardIterator&gt;::value_type;</span><br><span class="line">    <span class="keyword">using</span> is_trivial_dtor = <span class="keyword">typename</span> type_traits&lt;value_type&gt;::has_trivial_destructor;</span><br><span class="line">    destroy_aux(first, last, is_trivial_dtor());</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后新建一个<code>test.cpp</code>输入以下代码：</p>
<figure class="highlight c++"><figcaption><span>test.cpp</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"allocator.h"</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">"type_traits.h"</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">vector</span>&lt;<span class="keyword">int</span>,mystl::allocator&lt;<span class="keyword">int</span>&gt;&gt; vec(<span class="number">5</span>,<span class="number">5</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">auto</span> &amp;each: vec)</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; each &lt;&lt; <span class="string">" "</span>;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在<code>g++ (Ubuntu 7.4.0-1ubuntu1~18.04.1) 7.4.0</code>环境下执行后，可以看到输出为是5个5，这说明我们写的<code>allocator</code>是可以兼容当前编译环境中实现的的<code>std::vector</code>。但在vs2017中编译未通过，应该是与其内部的内存管理尚有冲突，不过这也没关系，可以在后续使用我们自己实现的<code>vector</code>进行测试。</p>
<h2 id="5-结束语"><a href="#5-结束语" class="headerlink" title="5 结束语"></a>5 结束语</h2><p>本方案实现的<code>allocator</code>类是比较简单的，从实现上也可以看出其仅仅是对<code>operator new</code>、<code>operator delete</code>、<code>placement new</code>的封装。并不是具有SGI STL特色，使用更底层的<code>malloc</code>、<code>free</code>以及内存池机制的两级空间分配器，后续将会对此进行实现，并使用同一种容器来比较两者效率。本节代码已上传，<a href="https://github.com/Lammmmmmm/TinySTL/blob/master/allocator.h" target="_blank" rel="noopener">allocator.h</a>，<a href="https://github.com/Lammmmmmm/TinySTL/blob/master/construct.h" target="_blank" rel="noopener">construct.h</a>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>TinySTL实现项目（一）：traits 技巧与 type_traits 模板</title>
    <url>/2020/01/01/STL1-TraitsAndType-traitsTemplate/</url>
    <content><![CDATA[<p>本篇文章是 TinySTL 实现的系列文章的第一篇。撰写初衷是为了对学习《STL 源码剖析》一书所做的总结回顾，并记录一些思考，顺便也作为我参照SGI STL源码实现的一个 TinySTL 项目的介绍文档，相关代码会陆续上传到<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">我的github</a>。</p>
<h2 id="1-traits-编程技法"><a href="#1-traits-编程技法" class="headerlink" title="1 traits 编程技法"></a>1 traits 编程技法</h2><p>traits 编程技法是C++泛型编程中常用技巧，这里先简单地概括一下其作用和目的。</p>
<ul>
<li>作用：通过函数模板来对具体对象或变量进行推导以<strong>获取其类型</strong>或<strong>某种特性</strong>。</li>
<li>目的1：针对获得的类型和某种特性来对<strong>实现函数进行优化以达到更高的性能</strong>。</li>
<li>目的2：通过提取出的类型<strong>作为模板函数的返回类型</strong>，方便函数实现。</li>
</ul>
<p>关于目的1，这里可以举一个迭代器的例子。例如 STL 中的迭代器型别有五种类型</p>
<div class="note info"><ul><li>Input iterator，能读不能写，只支持自增运算。也就是只能用<code>iter++</code>或<code>++iter</code>来一步步前进而不能后退。</li><li>Output iterator ，能写不能读，只支持自增运算</li><li>Forward iterator ，能读能写，只支持自增运算</li><li>Bidirectional iterator ，能读能写，支持自增和自减运算。可以<code>iter++</code>、<code>++iter</code>，也可以<code>iter--</code>、<code>--iter</code>，但依然每次只能前进后退一步。</li><li>Random access iterator ，能读能写，能自增自减还能进行运算，如可以用<code>iter+=5</code>，<code>iter-=5</code>来前进或后退5步。</li></ul></div>

<p>比如我有个迭代器<code>iter</code>，现在有个操作要求<code>iter</code>前进<code>n</code>步来读写数据。</p>
<p>因为事先不知道迭代器的类型，我只能保守地猜测其只能自增自减，这样<span class="label danger">复杂度就是O(n)</span>，但如果我运用<code>traits</code>技巧使用模板<code>iterator_traits&lt;iter&gt;::category</code>（后续会介绍，现在只需要知道其可以获得迭代器类型即可）来获得迭代器类型知道了其是<code>Randon access iterator</code>，那么直接<code>iter += n</code>即可，<span class="label danger">此时复杂度就是O(1)</span>。</p>
<p>对于目的2，这里也简单说一下。因为在C++11之前并没有<code>decltype</code>关键字，所以在编写模板函数的时候，函数返回类型是不能通过模板参数推导的，这时就可以使用<code>traits</code>技巧来获得类型作为模板函数的返回类型。</p>
<p>比如现在有个模板函数需要接受一个函数迭代器，然后返回其指向的值，那么模板参数是迭代器，函数的返回类型却是其指向值的类型。显然没办法通过模板参数推导来得到迭代器的指向值类型，这时就可以对迭代器使用<code>traits</code>技巧来提取其指向值类型作为函数的返回类型。</p>
<p>如果对迭代器类型不太熟悉还不太懂那也没关系，后续文章还会详细介绍，先接着往下看。</p>
<h2 id="2-POD类型"><a href="#2-POD类型" class="headerlink" title="2 POD类型"></a>2 POD类型</h2><p>要说<code>type_traits</code>模板就必须先说<code>POD</code>类型。</p>
<p>POD 是 Plain Old Data 的缩写，是 C++ 定义的一类数据结构概念，比如 <code>int</code>、<code>float</code> 等都是 POD 类型的。Plain 代表它是一个普通类型，Old 代表它是旧的，与 C 语言兼容，那么就可以使用 <code>memcpy()</code> 这种最原始的函数进行操作。两个系统进行交换数据，如果没有办法对数据进行语义检查和解释，那就只能以非常底层的数据形式进行交互，而拥有 POD 特征的类或者结构体通过二进制拷贝后依然能保持数据结构不变。</p>
<p><strong>也就是说，能用 C 的 memcpy() 等函数进行操作的类型就是 POD 类型的数据</strong>。 </p>
<p>在C++的各标准中对POD类型的有详细定义，从使用中可以概括为<strong>标量类型</strong>和<strong>POD类</strong>。</p>
<ul>
<li>标量类型：整型(<code>char</code>、<code>int</code>等等)，浮点型(<code>double</code>、<code>float</code>等等)，枚举类型，指针类型，指向成员指针类型，<code>std::nullptr_t</code>类型。</li>
<li>POD类：包括满足 trivial 条件和 standard-layout 条件的<code>struct</code>、<code>class</code>、<code>union</code>。<ul>
<li><strong>只有默认</strong>的构造/析构函数、拷贝/移动函数、拷贝/移动运算符。</li>
<li>不能有<strong>虚函数</strong>和<strong>虚基类</strong>。</li>
<li><strong>普通成员有相同的访问级别</strong>，如类成员都为<code>public</code>或都为<code>private</code>或都为<code>protected</code>。</li>
<li>第一个成员为自身的数据成员，而不能是由父类定义的数据。</li>
<li>只要有父类，<strong>普通成员只能在其中一个类中</strong>，不可分散。</li>
</ul>
</li>
</ul>
<p>可以使用<code>std::is_pod&lt;classname&gt;::value</code>的值来判断一个类是否为POD类型。</p>
<figure class="highlight c++"><table><tr><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//满足POD类型条件</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// A2继承了A1但父类子类同时有成员且A2的第一个成员为A1类型，故而不是pod类型</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span>:</span><span class="keyword">public</span> A1&#123;</span><br><span class="line">    A1 num1;</span><br><span class="line">    <span class="keyword">double</span> num2;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    A1 a1;</span><br><span class="line">    A2 a2;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_pod&lt;A1&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="built_in">std</span>::is_pod&lt;A2&gt;::value &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那么知道了一个对象或变量是不是POD类型有什么用呢？答案是以此<strong>提高程序运行效率</strong>。</p>
<p>假如事先知道了某函数的操作对象是POD类型，那么我们就可以针对其特性，使用底层的<code>memcpy()</code>、<code>memove()</code>等C函数对其操作，而不需要调用类似<code>constructor</code>，<code>destructor</code>等函数。这在大规模而操作频繁的程序中有显著的效率提升。</p>
<h2 id="3-type-traits-模板"><a href="#3-type-traits-模板" class="headerlink" title="3 type_traits 模板"></a>3 type_traits 模板</h2><p><code>type_traits</code>在SGT STL 2.91版本中命名为<code>__type_traits</code>，因为当时并未加入STL标准，属于SGI的“私房菜”，故而命名前有两个下划线，这里为了方便描述就去掉了开头的下划线。</p>
<p>从前文已经得知<code>traits</code>编程技巧的作用是为了<strong>取得对象或变量的某种特性</strong>，而目的则是为了根据<strong>特性作出相应优化而提升效率</strong>。而这里的<code>type_traits</code>模板所能取得特性就是是否具有所谓“平凡”（<code>trivial</code>）的默认构造函数、拷贝构造函数、赋值运算符、析构函数，以及是否是POD类型。如果具有上述的性质，那么在进行相应的构造、拷贝、赋值、析构的时候就可以使用<code>malloc()</code>、<code>memcpy()</code>这些C函数直接对内存进行操作，以获得更高的效率。</p>
<p>那么如何表示其是否具有上述性质呢？用<code>true</code>和<code>false</code>这样的布尔值？当然可以，但这样的话，在使用的时候，就不方便根据不同特性来对实际函数进行重载了，因为都是<code>bool</code>类型嘛。</p>
<p>根据SGI STL的方案，我们可以使用两个不含有任何成员的类来区分：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">true_type</span> &#123;</span> &#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">false_type</span> &#123;</span> &#125;;</span><br></pre></td></tr></table></figure>

<p>不含有任何成员，就意味着开销最低。</p>
<p>然后使用实现基本的<code>type_traits</code>模板：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = _false_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = _false_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = _false_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>在这个模板里我们先将所有性质都设为<code>false_type</code>，也就是说给所有使用该模板的类型一个最保守的值，接着使用<strong>模板特化</strong>的方法，为已知为<code>true_type</code>的类型提供特化版本。例如：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对各种算术整型的特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span>&lt;bool&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = _true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = _true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">template</span>&lt;&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span>&lt;char&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = _true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = _true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = _true_type;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure>

<p>指针类型当然也具有上述性质，但是对于指针就没必要一个个特化了，只需要使用<strong>偏特化</strong>就可以覆盖各种类型的指针了：</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 针对指针的偏特化版本</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> type&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">type_traits</span>&lt;type*&gt; &#123;</span></span><br><span class="line">    <span class="keyword">using</span> has_trivial_default_constructor   = true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_copy_constructtor     = true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_assignment_operator   = true_type;</span><br><span class="line">    <span class="keyword">using</span> has_trivial_destructor            = true_type;</span><br><span class="line">    <span class="keyword">using</span> is_POD_type                       = true_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h2 id="4-一点小扩展–is-const的实现"><a href="#4-一点小扩展–is-const的实现" class="headerlink" title="4 一点小扩展–is_const的实现"></a>4 一点小扩展–<code>is_const</code>的实现</h2><p>C++11的标准中加入了<code>decltype</code>关键字，使得许多原本需要使用<code>traits</code>技巧来取得对象类型的地方可以直接使用<code>decltype()</code>，避免了各种弯弯绕绕。比如在第一节迭代器的例子里。</p>
<p>但<code>traits</code>技巧依然在许多地方很有用，事实上即使是最新的各版本STL实现，依然有着广泛使用。比如我们可以使用类似技巧来实现<code>is_const</code>，其作用是判断一个类型是否是<code>const</code>的。实现如下</p>
<figure class="highlight c++"><figcaption><span>typetraits.h</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">// 一个辅助实现 true_type 和 false_type 的类</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T, T v&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">intergral_constant</span> &#123;</span></span><br><span class="line">    <span class="keyword">using</span> value_type = T;</span><br><span class="line">    <span class="keyword">using</span> type       = intergral_constant&lt;T, v&gt;;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">static</span> <span class="keyword">constexpr</span> T value = v;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> true_type = intergral_constant&lt;<span class="keyword">bool</span>, <span class="literal">true</span>&gt;;</span><br><span class="line"><span class="keyword">using</span> false_type = intergral_constant&lt;<span class="keyword">bool</span>, <span class="literal">false</span>&gt;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 接受普通类型时继承 false_type ,此时其静态成员 value 为 false</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_const</span>:</span> <span class="keyword">public</span> false_type &#123; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 偏特化使得接受 const 类型时继承 true_type，此时其静态成员 value 为 true</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> T&gt;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">is_const</span>&lt;const T&gt;:</span> <span class="keyword">public</span> true_type &#123; &#125;;</span><br></pre></td></tr></table></figure>

<h2 id="5-附录"><a href="#5-附录" class="headerlink" title="5 附录"></a>5 附录</h2><p>本部分代码已上传到 github，<a href="https://github.com/Lammmmmmm/TinySTL" target="_blank" rel="noopener">代码链接在这里</a>。</p>
]]></content>
      <categories>
        <category>C++</category>
        <category>STL</category>
      </categories>
      <tags>
        <tag>C++</tag>
        <tag>STL</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo 个人博客基于 NexT 主题的基本配置和定制优化</title>
    <url>/2019/12/30/CustomBlogTheme/</url>
    <content><![CDATA[<p>本网站的主题修改主要参照<a href="http://yearito.cn/" target="_blank" rel="noopener">这位大佬的博客</a>，但其边缘波动的部分配置是无效的，下文有详细介绍。</p>
<h2 id="1-站点基本优化"><a href="#1-站点基本优化" class="headerlink" title="1 站点基本优化"></a>1 站点基本优化</h2><h3 id="1-1-基本信息配置"><a href="#1-1-基本信息配置" class="headerlink" title="1.1 基本信息配置"></a>1.1 基本信息配置</h3><p>NexT主题默认风格为<code>Muse</code>，可以在<strong>主题目录的配置文件</strong><code>_config.yml</code>，注意这不是根目录下网站的配置文件</p>
<figure class="highlight yaml"><figcaption><span>theme/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Schemes</span></span><br><span class="line"><span class="attr">scheme:</span> <span class="string">Muse</span></span><br><span class="line"><span class="comment">#scheme: Mist</span></span><br><span class="line"><span class="comment">#scheme: Pisces</span></span><br><span class="line"><span class="comment">#scheme: Gemini</span></span><br></pre></td></tr></table></figure>

<p>而根目录下的<code>_config.yml</code>文件负责站点的相关配置包括了网站标题、网站描述、网站语言等</p>
<figure class="highlight yaml"><figcaption><span>./_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Site</span></span><br><span class="line"><span class="attr">title:</span> <span class="string">Chou</span> <span class="string">Bin's</span> <span class="string">Blog</span></span><br><span class="line"><span class="attr">subtitle:</span> <span class="string">''</span></span><br><span class="line"><span class="attr">description:</span> <span class="string">'慢就是快，快就是慢'</span></span><br><span class="line"><span class="attr">keywords:</span></span><br><span class="line"><span class="attr">author:</span> <span class="string">Chou</span> <span class="string">Bin</span></span><br><span class="line"><span class="attr">language:</span> <span class="string">zh-CN</span></span><br></pre></td></tr></table></figure>

<h3 id="1-2-生成标签、分类、归档页面"><a href="#1-2-生成标签、分类、归档页面" class="headerlink" title="1.2 生成标签、分类、归档页面"></a>1.2 生成标签、分类、归档页面</h3><p>主题首页的默认页面中是没有标签、分类、归档页面的，需要手动生成一下。先在博客根目录下打开<code>git-bash</code>或终端，然后键入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo new page tags &amp;&amp; hexo new page categories &amp;&amp; hexo new page archives</span><br></pre></td></tr></table></figure>

<p>然后打开新增的<code>source/tags/index.md</code>，修改如下</p>
<figure class="highlight diff"><figcaption><span>source\tags\index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: 标签</span><br><span class="line">  date: 2018-10-19 22:57:00</span><br><span class="line"><span class="addition">+ type: tags</span></span><br></pre></td></tr></table></figure>

<p>同理再修改另外两个新增文件夹下的<code>index.md</code>。</p>
<p>最后修改主题配置文件的<code>menu</code>字段</p>
<figure class="highlight diff"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">menu:</span><br><span class="line">  home: / || home</span><br><span class="line">  about: /about/ || user</span><br><span class="line"><span class="addition">+ tags: /tags/ || tags</span></span><br><span class="line"><span class="addition">+ categories: /categories/ || th</span></span><br><span class="line"><span class="addition">+ archives: /archives/ || archive</span></span><br></pre></td></tr></table></figure>

<p>效果如下</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%A2%9E%E5%8A%A0%E6%A0%87%E7%AD%BE%E5%88%86%E7%B1%BB%E5%BD%92%E6%A1%A3.png" alt="增加标签"></p>
<h3 id="1-3-首页显示文章摘要"><a href="#1-3-首页显示文章摘要" class="headerlink" title="1.3 首页显示文章摘要"></a>1.3 首页显示文章摘要</h3><p>默认的主题配置里，首页会显示每一篇文章的全文，如果想只显示文章摘要，对主题配置文件做如下更改</p>
<figure class="highlight yaml"><figcaption><span>theme/next/_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">auto_excerpt:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 开启自动摘要提取</span></span><br><span class="line">  <span class="attr">length:</span> <span class="number">150</span></span><br></pre></td></tr></table></figure>

<p>此时文中的前150个字符将作为摘要。</p>
<p>用户可以在文章中通过<code>&lt;!-- more --&gt;</code>标记来精确划分摘要信息，标记之前的段落将作为摘要显示在首页。</p>
<p>如果在文章的 Front-Matter 中有非空的 <code>description</code> 字段，则该字段的内容会被作为摘要显示在首页。</p>
<h3 id="1-4-修改站点页脚"><a href="#1-4-修改站点页脚" class="headerlink" title="1.4 修改站点页脚"></a>1.4 修改站点页脚</h3><p>在主题配置文件中修改网站页脚信息</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">footer:</span>  <span class="comment"># 底部信息区</span></span><br><span class="line">  <span class="attr">since:</span> <span class="number">2018</span>  <span class="comment"># 建站时间</span></span><br><span class="line">  <span class="attr">icon:</span></span><br><span class="line">    <span class="attr">name:</span> <span class="string">heart</span>   <span class="comment"># 图标名称</span></span><br><span class="line">    <span class="attr">animated:</span> <span class="literal">true</span>   <span class="comment"># 开启动画</span></span><br><span class="line">    <span class="attr">color:</span> <span class="string">"#ff0000"</span>   <span class="comment"># 图标颜色</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">powered:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 隐藏由 Hexo 强力驱动</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏 Hexo 版本号</span></span><br><span class="line"></span><br><span class="line">  <span class="attr">theme:</span></span><br><span class="line">    <span class="attr">enable:</span> <span class="literal">false</span>  <span class="comment"># 隐藏所用的主题名称</span></span><br><span class="line">    <span class="attr">version:</span> <span class="literal">false</span>  <span class="comment"># 隐藏主题版本号</span></span><br></pre></td></tr></table></figure>

<p>更改后效果如本站底部，但字数统计和访问统计等在后续配置中。</p>
<h3 id="1-5-修改网站-Favicon"><a href="#1-5-修改网站-Favicon" class="headerlink" title="1.5 修改网站 Favicon"></a>1.5 修改网站 Favicon</h3><p> Favicon 即浏览器标签左侧的图标。下载自己喜欢的图标置于 <code>themes\next\source\images\</code> 目录下，命名方式参考主题配置文件中的 <code>favicon</code> 字段。 这里介绍一个<a href="https://tool.lu/favicon/" target="_blank" rel="noopener">在线制作 <code>favicon</code>的网站</a>，可以上传喜欢的图片制作成<code>favicon</code>。</p>
<figure class="highlight yaml"><figcaption><span>theme\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">favicon:</span></span><br><span class="line">  <span class="attr">small:</span> <span class="string">/images/favicon-16x16-next.png</span>  <span class="comment"># 小图标</span></span><br><span class="line">  <span class="attr">medium:</span> <span class="string">/images/favicon-32x32-next.png</span>  <span class="comment"># 大图标</span></span><br><span class="line">  <span class="attr">apple_touch_icon:</span> <span class="string">/images/apple-touch-icon-next.png</span>  <span class="comment"># 苹果图标</span></span><br><span class="line">  <span class="attr">safari_pinned_tab:</span> <span class="string">/images/logo.svg</span>  <span class="comment"># safari浏览器标签页图标</span></span><br></pre></td></tr></table></figure>

<h3 id="1-6-添加友情链接"><a href="#1-6-添加友情链接" class="headerlink" title="1.6 添加友情链接"></a>1.6 添加友情链接</h3><p>在主题配置文件中修改相应的字段，可以加入一些朋友的网站。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">links_icon:</span> <span class="string">link</span></span><br><span class="line"><span class="attr">links_title:</span> <span class="string">友情链接</span></span><br><span class="line"><span class="attr">links_layout:</span> <span class="string">inline</span></span><br><span class="line"><span class="attr">links:</span></span><br><span class="line">  <span class="attr">yearito:</span> <span class="string">http://choubin.site</span></span><br></pre></td></tr></table></figure>

<h3 id="1-7-添加社交链接"><a href="#1-7-添加社交链接" class="headerlink" title="1.7 添加社交链接"></a>1.7 添加社交链接</h3><p>默认可选选项中，国内能用的基本只有github，邮箱，微博，当然其他只要有账号就可以放上去。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">social:</span></span><br><span class="line">  <span class="attr">GitHub:</span> <span class="string">https://github.com/yourname</span> <span class="string">||</span> <span class="string">github</span></span><br><span class="line">  <span class="attr">E-Mail:</span> <span class="string">mailto:yourname@gmail.com</span> <span class="string">||</span> <span class="string">envelope</span></span><br><span class="line">  <span class="attr">Weibo:</span> <span class="string">https://weibo.com/yourname</span> <span class="string">||</span> <span class="string">weibo</span></span><br><span class="line">  <span class="attr">Google:</span> <span class="string">https://plus.google.com/yourname</span> <span class="string">||</span> <span class="string">google</span></span><br><span class="line">  <span class="attr">Twitter:</span> <span class="string">https://twitter.com/yourname</span> <span class="string">||</span> <span class="string">twitter</span></span><br><span class="line">  <span class="attr">FB Page:</span> <span class="string">https://www.facebook.com/yourname</span> <span class="string">||</span> <span class="string">facebook</span></span><br><span class="line">  <span class="attr">VK Group:</span> <span class="string">https://vk.com/yourname</span> <span class="string">||</span> <span class="string">vk</span></span><br><span class="line">  <span class="attr">StackOverflow:</span> <span class="string">https://stackoverflow.com/yourname</span> <span class="string">||</span> <span class="string">stack-overflow</span></span><br><span class="line">  <span class="attr">YouTube:</span> <span class="string">https://youtube.com/yourname</span> <span class="string">||</span> <span class="string">youtube</span></span><br><span class="line">  <span class="attr">Instagram:</span> <span class="string">https://instagram.com/yourname</span> <span class="string">||</span> <span class="string">instagram</span></span><br><span class="line">  <span class="attr">Skype:</span> <span class="string">skype:yourname?call|chat</span> <span class="string">||</span> <span class="string">skype</span></span><br><span class="line"></span><br><span class="line"><span class="attr">social_icons:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 显示社交软件图标</span></span><br><span class="line">  <span class="attr">icons_only:</span> <span class="literal">false</span>  <span class="comment"># 显示图标的同时显示文字</span></span><br></pre></td></tr></table></figure>

<h3 id="1-8-添加版权协议"><a href="#1-8-添加版权协议" class="headerlink" title="1.8 添加版权协议"></a>1.8 添加版权协议</h3><p>先在主题配置文件中开启相关字段</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">creative_commons:</span> <span class="string">by-nc-sa</span></span><br></pre></td></tr></table></figure>

<h2 id="2-网站逻辑优化"><a href="#2-网站逻辑优化" class="headerlink" title="2 网站逻辑优化"></a>2 网站逻辑优化</h2><h3 id="2-1-点击头像回到首页"><a href="#2-1-点击头像回到首页" class="headerlink" title="2.1 点击头像回到首页"></a>2.1 点击头像回到首页</h3><p>修改侧边栏模板代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.avatar.url %&#125;</span><br><span class="line"><span class="addition">+   &lt;a href="/"&gt;</span></span><br><span class="line">      &lt;img class="site-author-image" itemprop="image"</span><br><span class="line">        src="&#123;&#123; url_for( theme.avatar.url | default(theme.images + '/avatar.gif') ) &#125;&#125;"</span><br><span class="line">        alt="&#123;&#123; author &#125;&#125;" /&gt;</span><br><span class="line"><span class="addition">+   &lt;/a&gt;</span></span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<h3 id="2-2-文章页优化"><a href="#2-2-文章页优化" class="headerlink" title="2.2 文章页优化"></a>2.2 文章页优化</h3><p><strong>取消文章目录中的数字编号</strong>，因为一般我写markdown文档的时候都是自己为章节编号，所以需要取消主题中的文章目录的数字编号，否则就会有两个数字很别扭。</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">toc:</span></span><br><span class="line">  <span class="attr">number:</span> <span class="literal">false</span>  <span class="comment"># 关闭目录中的数字编号</span></span><br></pre></td></tr></table></figure>

<p>默认情况下文章的多级目录会被折叠，需要点击才能触发下级菜单的展开，并且同时只能展开一个目录分支，这会造成看文章点击目录很不方便，所以本站点<strong>设置了展开全部目录层级</strong>，这里需要<strong>新建</strong>一个自定义样式文件<code>themes\next\source\css\_custom\custom.styl</code>，然后添加以下代码。</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//TOC目录默认全部展开</span></span><br><span class="line"><span class="selector-class">.post-toc</span> <span class="selector-class">.nav</span> <span class="selector-class">.nav-child</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: block;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因为这里是第一次新建自定义样式文件，还需要做如下修改，在 themes\next\layout\_layout.swig  文件中引入刚才新建的文件</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">      ...</span><br><span class="line">      &#123;% include '_third-party/exturl.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/bookmark.swig' %&#125;</span><br><span class="line">      &#123;% include '_third-party/copy-code.swig' %&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+     &#123;% include '_custom/custom.swig' %&#125;</span></span><br><span class="line">    &lt;/body&gt;</span><br><span class="line">  &lt;/html&gt;</span><br></pre></td></tr></table></figure>

<p>另外如果文章不长，就没必要展示目录了，否则侧边文章目录栏空荡荡的也有点别扭。这里需要修改侧边栏的布局模板相关逻辑代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\sidebar.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% set display_toc = is_post and theme.toc.enable %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% set display_toc = is_post and theme.toc.enable and not page.hide_toc %&#125;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-3-修改文章-meta-信息"><a href="#2-3-修改文章-meta-信息" class="headerlink" title="2.3 修改文章 meta 信息"></a>2.3 修改文章 meta 信息</h3><p>默认主题下， 标题下方会显示文章的创建时间、文章的修改时间、文章分类信息等元数据，用户可以在主题配置文件中自定义设置需要显示的 meta 元信息： </p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_meta:</span></span><br><span class="line">  <span class="attr">item_text:</span> <span class="literal">true</span>  <span class="comment"># 显示文字说明</span></span><br><span class="line">  <span class="attr">created_at:</span> <span class="literal">true</span>  <span class="comment"># 显示文章创建时间</span></span><br><span class="line">  <span class="attr">updated_at:</span></span><br><span class="line">    <span class="attr">enabled:</span> <span class="literal">false</span>  <span class="comment"># 隐藏文章修改时间</span></span><br><span class="line">    <span class="attr">another_day:</span> <span class="literal">true</span>  <span class="comment"># 只有当修改时间和创建时间不是同一天的时候才显示</span></span><br><span class="line">  <span class="attr">categories:</span> <span class="literal">false</span>  <span class="comment"># 隐藏分类信息</span></span><br></pre></td></tr></table></figure>

<h2 id="3-主题定制优化"><a href="#3-主题定制优化" class="headerlink" title="3 主题定制优化"></a>3 主题定制优化</h2><h3 id="3-1-修改博客字体"><a href="#3-1-修改博客字体" class="headerlink" title="3.1 修改博客字体"></a>3.1 修改博客字体</h3><p> 在 <a href="https://www.google.com/fonts" target="_blank" rel="noopener">Google Fonts</a> 上找到心仪的字体，然后在主题配置文件中为不同的应用场景配置字体： </p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">font:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 外链字体库地址，例如 //fonts.googleapis.com (默认值)</span></span><br><span class="line">  <span class="attr">host:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 全局字体，应用在 body 元素上</span></span><br><span class="line">  <span class="attr">global:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Monda</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 标题字体 (h1, h2, h3, h4, h5, h6)</span></span><br><span class="line">  <span class="attr">headings:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span> <span class="string">Roboto</span> <span class="string">Slab</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 文章字体</span></span><br><span class="line">  <span class="attr">posts:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># Logo 字体</span></span><br><span class="line">  <span class="attr">logo:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br><span class="line"></span><br><span class="line">  <span class="comment"># 代码字体，应用于 code 以及代码块</span></span><br><span class="line">  <span class="attr">codes:</span></span><br><span class="line">    <span class="attr">external:</span> <span class="literal">true</span></span><br><span class="line">    <span class="attr">family:</span></span><br></pre></td></tr></table></figure>

<h3 id="3-2-为标签添加图标"><a href="#3-2-为标签添加图标" class="headerlink" title="3.2 为标签添加图标"></a>3.2 为标签添加图标</h3><p> 默认情况下标签前缀是 <code>#</code> 字符，用户可以通过修改主题源码将标签的字符前缀改为图标前缀 </p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &lt;footer class="post-footer"&gt;</span><br><span class="line">    &#123;% if post.tags and post.tags.length and not is_index %&#125;</span><br><span class="line">      &lt;div class="post-tags"&gt;</span><br><span class="line">        &#123;% for tag in post.tags %&#125;</span><br><span class="line"><span class="deletion">-          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;# &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line"><span class="addition">+          &lt;a href="&#123;&#123; url_for(tag.path) &#125;&#125;" rel="tag"&gt;&lt;i class="fa fa-tags"&gt;&lt;/i&gt; &#123;&#123; tag.name &#125;&#125;&lt;/a&gt;</span></span><br><span class="line">        &#123;% endfor %&#125;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    ...</span><br><span class="line">  &lt;/footer&gt;</span><br></pre></td></tr></table></figure>

<p> Next 中使用 <a href="https://fontawesome.com/v4.7.0/icons/" target="_blank" rel="noopener">FontAwesome</a> 作为图标库，用户可以在 FontAwesome 上找到心仪的图标来替换标签的字符前缀。 </p>
<h3 id="3-3-添加结束标记"><a href="#3-3-添加结束标记" class="headerlink" title="3.3 添加结束标记"></a>3.3 添加结束标记</h3><p>在文末添加结束标记，效果如下：</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E7%BB%93%E6%9D%9F%E6%A0%87%E8%AE%B0.png" alt="结束标记"></p>
<p> 新建布局模板文件 post-end-tag.swig，添加如下代码： </p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post-end-tag.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &lt;div style="text-align:center;color:#bfbfbf;font-size:16px;"&gt;</span><br><span class="line">      &lt;span&gt;-------- 本文结束 &lt;/span&gt;</span><br><span class="line">      &lt;i class="fa fa-&#123;&#123; config.post_end_tag.icon &#125;&#125;"&gt;&lt;/i&gt;</span><br><span class="line">      &lt;span&gt; 感谢阅读 --------&lt;/span&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure>

<p>在文章布局模板中添加如下代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_macro\post</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;#####################&#125;</span><br><span class="line">&#123;### END POST BODY ###&#125;</span><br><span class="line">&#123;#####################&#125;</span><br><span class="line"></span><br><span class="line"><span class="addition">+ &#123;% if config.post_end_tag.enabled and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;div&gt;</span></span><br><span class="line"><span class="addition">+     &#123;% include 'post-end-tag.swig' %&#125;</span></span><br><span class="line"><span class="addition">+   &lt;/div&gt;</span></span><br><span class="line"><span class="addition">+ &#123;% endif %&#125;</span></span><br><span class="line"></span><br><span class="line">&#123;% if theme.wechat_subscriber.enabled and not is_index %&#125;</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &#123;% include 'wechat-subscriber.swig' %&#125;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在站点配置文件末尾添加如下代码</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_end_tag:</span></span><br><span class="line">  <span class="attr">enabled:</span> <span class="literal">true</span>  <span class="comment"># 是否开启文末的本文结束标记</span></span><br><span class="line">  <span class="attr">icon:</span> <span class="string">paw</span> <span class="comment"># 结束标记之间的图标</span></span><br></pre></td></tr></table></figure>

<h3 id="3-4-页面加载进度条"><a href="#3-4-页面加载进度条" class="headerlink" title="3.4 页面加载进度条"></a>3.4 页面加载进度条</h3><p>当网络不好的时候可能会在打开站点或跳转文章时出现短暂的白屏，此时如果能有加载进度提示将会提高用户操作体验。</p>
<p>在根目录下执行以下命令安装相关依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-pace themes/next/<span class="built_in">source</span>/lib/pace</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中设置 <code>pace: true</code>。</p>
<p>默认提供了多种主题的进度条加载样式，有顶部提示的，有中间提示的，还有全页面遮挡提示的，默认进度条就非常合适。</p>
<h3 id="3-5-侧边栏放左边"><a href="#3-5-侧边栏放左边" class="headerlink" title="3.5 侧边栏放左边"></a>3.5 侧边栏放左边</h3><p> Next 主题的各种主题风格中只有 Pisces 和 Gemini 支持通过主题配置文件来将侧边栏置于左侧或右侧，而 Muse 和 Mist 则需要深度修改源码才能实现改变侧边栏位置。 </p>
<p>在上文新建的自定义样式文件中添加如下代码</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="selector-class">.sidebar-toggle</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">30px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>修改动效脚本代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\source\js\src\motion.js</span></figcaption><table><tr><td class="code"><pre><span class="line">$(document)</span><br><span class="line">  .on('sidebar.isShowing', function() &#123;</span><br><span class="line">    NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(</span><br><span class="line"><span class="deletion">-     &#123;paddingRight: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line"><span class="addition">+     &#123;paddingLeft: SIDEBAR_WIDTH&#125;,</span></span><br><span class="line">      SIDEBAR_DISPLAY_DURATION</span><br><span class="line">    );</span><br><span class="line">  &#125;)</span><br><span class="line">  .on('sidebar.isHiding', function() &#123;</span><br><span class="line">  &#125;);</span><br><span class="line">  ...</span><br><span class="line">  hideSidebar: function() &#123;</span><br><span class="line"><span class="deletion">-   NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingRight: 0&#125;);</span></span><br><span class="line"><span class="addition">+   NexT.utils.isDesktop() &amp;&amp; $('body').velocity('stop').velocity(&#123;paddingLeft: 0&#125;);</span></span><br><span class="line">    this.sidebarEl.find('.motion-element').velocity('stop').css('display', 'none');</span><br><span class="line">    this.sidebarEl.velocity('stop').velocity(&#123;width: 0&#125;, &#123;display: 'none'&#125;);</span><br><span class="line"></span><br><span class="line">    sidebarToggleLines.init();</span><br><span class="line">    ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p> 如此以来就可以将侧边栏放置在左边了，但当窗口宽度缩小到 991px 之后会出现样式错误：侧边栏收缩消失但是页面左侧仍留有空白间距，此时修改如下代码即可： </p>
<figure class="highlight diff"><figcaption><span>themes\next\source\css\_common\scaffolding\base.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">body &#123;</span><br><span class="line">  position: relative; // Required by scrollspy</span><br><span class="line">  font-family: $font-family-base;</span><br><span class="line">  font-size: $font-size-base;</span><br><span class="line">  line-height: $line-height-base;</span><br><span class="line">  color: $text-color;</span><br><span class="line">  background: $body-bg-color;</span><br><span class="line"></span><br><span class="line"><span class="deletion">- +mobile() &#123; padding-left: 0 !important; &#125;</span></span><br><span class="line"><span class="deletion">- +tablet() &#123; padding-left: 0 !important; &#125;  </span></span><br><span class="line"><span class="addition">+ +mobile() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line"><span class="addition">+ +tablet() &#123; padding-right: 0 !important; &#125;</span></span><br><span class="line">  +desktop-large() &#123; font-size: $font-size-large; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="4-添加个性特效"><a href="#4-添加个性特效" class="headerlink" title="4 添加个性特效"></a>4 添加个性特效</h2><h3 id="4-1-边缘摆动效果"><a href="#4-1-边缘摆动效果" class="headerlink" title="4.1 边缘摆动效果"></a>4.1 边缘摆动效果</h3><p>个人一直认为，博客是给人阅读的，而添加一些花里胡哨的动态背景，实在有违博客初衷。可是过于朴素又失去了趣味性，故而加入了一个边缘摆动效果，个人觉得还有点小俏皮，效果如下。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/wobblewindow.gif" alt="边缘摆动效果"></p>
<p>但<a href="http://yearito.cn/posts/hexo-theme-beautify.html" target="_blank" rel="noopener">上文提到的博客</a>中的教程有点小问题，添加的代码路径出错了，导致无法成功显示特效。个人亲测有用，修正如下。</p>
<p>首先<a href="https://script-1256884783.file.myqcloud.com/wobblewindow.js" target="_blank" rel="noopener">下载脚本</a>，置于  themes\next\source\js\ 目录下 ，然后将以下代码<strong>添加到  themes\next\layout\_layout.swig</strong>，原教程中是添加到 themes\next\layout_custom\custom.swig ，亲测无效。</p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# wobble窗口摆动特效 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.wobble %&#125;</span><br><span class="line">  &lt;script src=<span class="string">"/js/wobblewindow.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    <span class="comment">//只在桌面版网页启用特效</span></span><br><span class="line">    <span class="keyword">if</span>( <span class="built_in">window</span>.innerWidth &gt; <span class="number">768</span>  )&#123;</span><br><span class="line">      $(<span class="built_in">document</span>).ready(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        &#123;% <span class="keyword">if</span> theme.wobble.header %&#125;</span><br><span class="line">          $(<span class="string">'#header'</span>).wobbleWindow(&#123;</span><br><span class="line">            radius: &#123;&#123; theme.wobble.radius &#125;&#125;,</span><br><span class="line">            movementTop: <span class="literal">false</span>,</span><br><span class="line">            movementLeft: <span class="literal">false</span>,</span><br><span class="line">            movementRight: <span class="literal">false</span>,</span><br><span class="line">            debug: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">        &#123;% <span class="keyword">if</span> theme.wobble.sidebar %&#125;</span><br><span class="line">          $(<span class="string">'#sidebar'</span>).wobbleWindow(&#123;</span><br><span class="line">            radius: &#123;&#123; theme.wobble.radius &#125;&#125;,</span><br><span class="line">            movementLeft: <span class="literal">false</span>,</span><br><span class="line">            movementTop: <span class="literal">false</span>,</span><br><span class="line">            movementBottom: <span class="literal">false</span>,</span><br><span class="line">            position: <span class="string">'fixed'</span>,</span><br><span class="line">            debug: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">        &#123;% <span class="keyword">if</span> theme.wobble.footer %&#125;</span><br><span class="line">          $(<span class="string">'#footer'</span>).wobbleWindow(&#123;</span><br><span class="line">            radius: &#123;&#123; theme.wobble.radius &#125;&#125;,</span><br><span class="line">            movementBottom: <span class="literal">false</span>,</span><br><span class="line">            movementLeft: <span class="literal">false</span>,</span><br><span class="line">            movementRight: <span class="literal">false</span>,</span><br><span class="line">            offsetX: &#123;&#123; theme.wobble.offset &#125;&#125;,</span><br><span class="line">            position: <span class="string">'absolute'</span>,</span><br><span class="line">            debug: <span class="literal">false</span>,</span><br><span class="line">          &#125;);</span><br><span class="line">        &#123;% endif %&#125;</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>然后在自定义样式文件中添加一下样式，注意是在<code>themes\next\source\css\_custom\custom.styl</code>文件中添加，这里的代码也与原教程中稍有不同。</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//窗口波动效果相关样式</span></span><br><span class="line"><span class="keyword">if</span> hexo-config(<span class="string">'wobble'</span>)  &#123;</span><br><span class="line">  <span class="selector-class">.sidebar</span> &#123;</span><br><span class="line">    <span class="attribute">box-shadow</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .wobbleTransparentBK&#123;</span><br><span class="line">    <span class="attribute">background-color</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  .wobbleTransparentLine&#123;</span><br><span class="line">    <span class="attribute">border-color</span>: rgba(<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>,<span class="number">0</span>) !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//Next.Muse中为Header和Footer添加背景色</span></span><br><span class="line">  <span class="selector-class">.header</span>, <span class="selector-class">.footer</span> &#123;</span><br><span class="line">    <span class="attribute">background-color</span>: rgb(<span class="number">245</span>, <span class="number">245</span>, <span class="number">245</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//防止sidebar和footer同时开启动效时堆叠异常</span></span><br><span class="line">  <span class="selector-class">.sidebar</span>, <span class="selector-class">.header</span> &#123;</span><br><span class="line">    <span class="attribute">z-index</span>: <span class="number">1</span> !important;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//防止挡住页末文章的阅读全文按钮</span></span><br><span class="line">  <span class="selector-class">.main</span> &#123;</span><br><span class="line">    <span class="attribute">padding-bottom</span>: <span class="number">200px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>主要是因为 Next.Muse 主题方案中 Header 和 Footer 是没有背景色的，所以需要添加背景色后才能看出边缘摆动效果。另外，实现边缘摆动效果所需的 <code>z-index</code> 属性可能会导致元素堆叠异常，需要添加以上样式来矫正。 </p>
<p>最后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># window woblle</span></span><br><span class="line"><span class="attr">wobble:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span>  <span class="comment"># 是否开启边缘波动效果</span></span><br><span class="line">  <span class="attr">radius:</span> <span class="number">65</span>  <span class="comment"># 波动半径</span></span><br><span class="line">  <span class="attr">sidebar:</span> <span class="literal">false</span>  <span class="comment"># 不开启侧边栏边缘摆动，设为true的话则目录的侧边栏也会摆动</span></span><br><span class="line">  <span class="attr">header:</span> <span class="literal">true</span>  <span class="comment"># 开启头部边缘摆动</span></span><br><span class="line">  <span class="attr">footer:</span> <span class="literal">true</span>  <span class="comment"># 开启脚部边缘摆动</span></span><br></pre></td></tr></table></figure>

<h3 id="4-2-使用小猫咪回到顶部"><a href="#4-2-使用小猫咪回到顶部" class="headerlink" title="4.2 使用小猫咪回到顶部"></a>4.2 使用小猫咪回到顶部</h3><p>就像本站一样，使用右侧的小猫咪来回到顶部，还蛮可爱的，建议添加。</p>
<p>原理就是将 <code>back-to-top</code>按钮添加图片背景，然后添加<code>CSS3</code>动效。这里用的图片素材就是一个小猫上吊的图片，<a href="http://yearito.cn/images/scroll.png" target="_blank" rel="noopener">点这里下载</a>，然后放置到 source\images\ 目录下 。</p>
<p>然后在自定义样式文件中添加如下代码</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css\_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//自定义回到顶部样式</span></span><br><span class="line"><span class="selector-class">.back-to-top</span> &#123;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">60px</span>;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">70px</span>;  <span class="comment">//图片素材宽度</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">900px</span>;  <span class="comment">//图片素材高度</span></span><br><span class="line">  <span class="attribute">top</span>: -<span class="number">900px</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: unset;</span><br><span class="line">  transition: all .5s ease-in-out;</span><br><span class="line">  <span class="attribute">background</span>: url(<span class="string">"/images/scroll.png"</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//隐藏箭头图标</span></span><br><span class="line">  &gt; <span class="selector-tag">i</span> &#123;</span><br><span class="line">    <span class="attribute">display</span>: none;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  &amp;<span class="selector-class">.back-to-top-on</span> &#123;</span><br><span class="line">    <span class="attribute">bottom</span>: unset;</span><br><span class="line">    <span class="attribute">top</span>: <span class="number">100vh</span> &lt; (<span class="number">900px</span> + <span class="number">200px</span>) ? calc( <span class="number">100vh</span> - <span class="number">900px</span> - <span class="number">200px</span> ) : <span class="number">0px</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="4-3-鼠标点击特效"><a href="#4-3-鼠标点击特效" class="headerlink" title="4.3 鼠标点击特效"></a>4.3 鼠标点击特效</h3><p>鼠标点击特效常用的有礼花特效、爆照特效、浮出特效、浮出文字，礼花特效如下图所示，个人比较中意礼花特效，可以点击下方按钮下载相应脚本 并置于 themes\next\source\js\cursor\ 目录下 </p>
<a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/fireworks.js" target="_blank" rel="noopener">礼花特效</a> <a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/explosion.min.js" target="_blank" rel="noopener">爆炸特效</a> <a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/love.min.js" target="_blank" rel="noopener">浮出爱心</a> <a class="btn" href="https://script-1256884783.file.myqcloud.com/cursor/text.js" target="_blank" rel="noopener">浮出文字</a>

<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/cursor-fireworks.gif" alt="礼花特效"></p>
<p>然后在主题自定义布局文件照片那个添加如下代码</p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout\_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 鼠标点击特效 #&#125;</span><br><span class="line">&#123;% <span class="keyword">if</span> theme.cursor_effect == <span class="string">"fireworks"</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/fireworks.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">"explosion"</span> %&#125;</span><br><span class="line">  &lt;canvas <span class="class"><span class="keyword">class</span></span>=<span class="string">"fireworks"</span> style=<span class="string">"position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;"</span> &gt;<span class="xml"><span class="tag">&lt;/<span class="name">canvas</span>&gt;</span></span></span><br><span class="line">  &lt;script src=<span class="string">"//cdn.bootcss.com/animejs/2.2.0/anime.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/explosion.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">"love"</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/love.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% elseif theme.cursor_effect == <span class="string">"text"</span> %&#125;</span><br><span class="line">  &lt;script <span class="keyword">async</span> src=<span class="string">"/js/cursor/text.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p><strong>若该文件不存在则新建后见步骤2.2。</strong></p>
<p>然后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># mouse click effect: fireworks | explosion | love | text</span></span><br><span class="line"><span class="attr">cursor_effect:</span> <span class="string">fireworks</span></span><br></pre></td></tr></table></figure>

<h3 id="4-4-打字特效"><a href="#4-4-打字特效" class="headerlink" title="4.4 打字特效"></a>4.4 打字特效</h3><p>这里的特效是为评论输入文字时添加的特效，关于如何添加评论功能见步骤6.4。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/typing-effect.gif" alt="打字特效"></p>
<p><a href="https://script-1256884783.file.myqcloud.com/activate-power-mode.min.js" target="_blank" rel="noopener">点击这里</a> 下载相应脚本，并置于 themes\next\source\js\ 目录下。</p>
<p>然后在主题自定义布局文件中添加以下代码</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout\_layout.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 打字特效 #&#125;</span><br><span class="line">&#123;% if theme.typing_effect %&#125;</span><br><span class="line">  &lt;script src="/js/activate-power-mode.min.js"&gt;&lt;/script&gt;</span><br><span class="line">  &lt;script&gt;</span><br><span class="line">    POWERMODE.colorful = &#123;&#123; theme.typing_effect.colorful &#125;&#125;;</span><br><span class="line">    POWERMODE.shake = &#123;&#123; theme.typing_effect.shake &#125;&#125;;</span><br><span class="line">    document.body.addEventListener('input', POWERMODE);</span><br><span class="line">  &lt;/script&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>如果 custom.swig 文件不存在则需要新建，然后见步骤2.2。最后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># typing effect</span></span><br><span class="line"><span class="attr">typing_effect:</span></span><br><span class="line">  <span class="attr">colorful:</span> <span class="literal">true</span>  <span class="comment"># 礼花特效</span></span><br><span class="line">  <span class="attr">shake:</span> <span class="literal">false</span>  <span class="comment"># 震动特效</span></span><br></pre></td></tr></table></figure>

<h2 id="5-站点数据统计"><a href="#5-站点数据统计" class="headerlink" title="5 站点数据统计"></a>5 站点数据统计</h2><h3 id="5-1-站点访问量统计"><a href="#5-1-站点访问量统计" class="headerlink" title="5.1 站点访问量统计"></a>5.1 站点访问量统计</h3><p>使用<a href="http://ibruce.info/2015/04/04/busuanzi/" target="_blank" rel="noopener">不蒜子</a>来实现， 由于不蒜子是基于域名来进行统计计算的，所以通过 localhost:4000 端口访问的时候统计数据 PV 和 UV 都会异常的大，属于正常现象。 </p>
<p> 在页脚布局模板文件首行添加如下代码： </p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout_partial\footer.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;script</span><br><span class="line">  <span class="keyword">async</span></span><br><span class="line">  src=<span class="string">"https://dn-lbstatics.qbox.me/busuanzi/2.3/busuanzi.pure.mini.js"</span></span><br><span class="line">&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<p>在主题配置文件中做如下修改</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">busuanzi_count:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="literal">true</span> <span class="comment"># 访客数</span></span><br><span class="line">  <span class="attr">total_visitors_icon:</span> <span class="string">user</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="literal">true</span> <span class="comment"># 访问量</span></span><br><span class="line">  <span class="attr">total_views_icon:</span> <span class="string">eye</span></span><br><span class="line">  <span class="attr">post_views:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">post_views_icon:</span> <span class="string">eye</span></span><br></pre></td></tr></table></figure>

<p>可选：自定义统计文案，如本站所示，需要做如下修改</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout_third-party\analytics\busuanzi-counter.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;% if theme.busuanzi_count.total_visitors %&#125;</span><br><span class="line"><span class="deletion">-   &lt;span class="site-uv" title="&#123;&#123; __('footer.total_visitors') &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+   &lt;span class="site-uv"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;&#123; __('footer.total_visitors', '&lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;') &#125;&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_visitors_icon &#125;&#125;"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class="busuanzi-value" id="busuanzi_value_site_uv"&gt;&lt;/span&gt;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line"></span><br><span class="line">  &#123;% if theme.busuanzi_count.total_views %&#125;</span><br><span class="line"><span class="deletion">-   &lt;span class="site-pv" title="&#123;&#123; __('footer.total_views') &#125;&#125;"&gt;</span></span><br><span class="line"><span class="addition">+   &lt;span class="site-pv"&gt;</span></span><br><span class="line"><span class="addition">+     &#123;&#123; __('footer.total_views', '&lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;') &#125;&#125;</span></span><br><span class="line"><span class="deletion">-     &lt;i class="fa fa-&#123;&#123; theme.busuanzi_count.total_views_icon &#125;&#125;"&gt;&lt;/i&gt;</span></span><br><span class="line"><span class="deletion">-     &lt;span class="busuanzi-value" id="busuanzi_value_site_pv"&gt;&lt;/span&gt;</span></span><br><span class="line">    &lt;/span&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式</p>
<figure class="highlight stylus"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//修改不蒜子数据颜色</span></span><br><span class="line"><span class="selector-class">.busuanzi-value</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#1890ff</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后修改表述文案</p>
<figure class="highlight yaml"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line"><span class="attr">footer:</span></span><br><span class="line">  <span class="attr">total_views:</span> <span class="string">"历经 %s 次回眸才与你相遇"</span></span><br><span class="line">  <span class="attr">total_visitors:</span> <span class="string">"我的第 %s 位朋友，"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-2-站点运行时间统计"><a href="#5-2-站点运行时间统计" class="headerlink" title="5.2 站点运行时间统计"></a>5.2 站点运行时间统计</h3><p>效果如下：</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E7%AB%99%E7%82%B9%E7%BB%9F%E8%AE%A1%E6%97%B6%E9%97%B4.jpg" alt="站点统计时间"></p>
<p>在自定义布局文件中添加以下代码：</p>
<figure class="highlight javascript"><figcaption><span>thems\next\layout_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&#123;# 页脚站点运行时间统计 #&#125; &#123;% if theme.footer.ages.enable %&#125;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/moment@2.22.2/moment.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script src=<span class="string">"https://cdn.jsdelivr.net/npm/moment-precise-range-plugin@1.3.0/moment-precise-range.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> ages = moment.preciseDiff(moment(),moment(&#123;&#123; theme.footer.ages.birthday &#125;&#125;,<span class="string">"YYYYMMDD"</span>));</span><br><span class="line">    ages = ages.replace(<span class="regexp">/years?/</span>, <span class="string">"年"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/months?/</span>, <span class="string">"月"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/days?/</span>, <span class="string">"天"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/hours?/</span>, <span class="string">"小时"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/minutes?/</span>, <span class="string">"分"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/seconds?/</span>, <span class="string">"秒"</span>);</span><br><span class="line">    ages = ages.replace(<span class="regexp">/\d+/g</span>, <span class="string">'&lt;span style="color:&#123;&#123; theme.footer.ages.color &#125;&#125;"&gt;$&amp;&lt;/span&gt;'</span>);</span><br><span class="line">    div.innerHTML = <span class="string">`&#123;&#123; __('footer.age')&#125;&#125; <span class="subst">$&#123;ages&#125;</span>`</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">var</span> div = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">  <span class="comment">//插入到copyright之后</span></span><br><span class="line">  <span class="keyword">var</span> copyright = <span class="built_in">document</span>.querySelector(<span class="string">".copyright"</span>);</span><br><span class="line">  <span class="built_in">document</span>.querySelector(<span class="string">".footer-inner"</span>).insertBefore(div, copyright.nextSibling);</span><br><span class="line">  timer();</span><br><span class="line">  setInterval(<span class="string">"timer()"</span>,<span class="number">1000</span>)</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br><span class="line"><span class="regexp">&#123;% endif %&#125;</span></span><br></pre></td></tr></table></figure>

<p>如果该文件不存在，则手动新建，见步骤2.2。</p>
<p>然后修改主题配置文件</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="attr">footer:</span></span><br><span class="line">    <span class="string">...</span></span><br><span class="line"><span class="string">+</span>   <span class="attr">ages:</span></span><br><span class="line"><span class="string">+</span>     <span class="comment"># site running time</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">+</span>     <span class="comment"># birthday of your site</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">birthday:</span> <span class="number">20181001</span></span><br><span class="line"><span class="string">+</span>     <span class="comment"># color of number</span></span><br><span class="line"><span class="string">+</span>     <span class="attr">color:</span> <span class="string">"#1890ff"</span></span><br></pre></td></tr></table></figure>

<p>然后补全对应文案</p>
<figure class="highlight yaml"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="attr">footer:</span></span><br><span class="line">    <span class="attr">powered:</span> <span class="string">"由 %s 强力驱动"</span></span><br><span class="line">    <span class="attr">theme:</span> <span class="string">主题</span></span><br><span class="line"><span class="string">+</span>   <span class="attr">age:</span> <span class="string">我已在此等候你</span></span><br><span class="line">    <span class="attr">total_views:</span> <span class="string">"历经 %s 次回眸才与你相遇"</span></span><br><span class="line">    <span class="attr">total_visitors:</span> <span class="string">"我的第 %s 位朋友，"</span></span><br></pre></td></tr></table></figure>

<h3 id="5-3-文章访问量统计"><a href="#5-3-文章访问量统计" class="headerlink" title="5.3 文章访问量统计"></a>5.3 文章访问量统计</h3><p>这里需要借助<a href="https://leancloud.cn/" target="_blank" rel="noopener">LeanCloud</a>来提供后端数据服务。</p>
<p> 在 LeanCloud 上注册账号并创建应用，应用名称可以为<code>ForBlog</code>，然后在该应用中，新建一个名为 Counter 的 Class，ACL 权限设置为 <strong>无限制</strong>： </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/LeanCloud-Counter-class.png" alt="LeanCloud"></p>
<div class="note [info]"><p>在 LeanCloud 中的 Class 可以理解为数据库中的数据表。Counter 用于存储记录文章访问量，记录是以 url 作为唯一依据的，所以根据默认的 permalink 组成结构，如果你更改了文章的发布日期和标题中的任意一个，都会造成文章阅读数值的清零重计。 </p></div>

<p> 在控制台的 <strong>设置</strong> -&gt; <strong>应用 Key</strong> 中获取 App ID 和 App Key 填入到主题配置文件中： </p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">leancloud_visitors:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">app_id:</span> <span class="string">***&lt;app_id***</span></span><br><span class="line">  <span class="attr">app_key:</span> <span class="string">***&lt;app_key&gt;***</span></span><br><span class="line">  <span class="attr">security:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">betterPerformance:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>站点上线后可以在 <strong>设置</strong> -&gt; <strong>安全中心</strong> 中添加博客域名到 Web 安全域名中，设置后仅可在该域名下通过 JavaScript SDK 调用服务器资源，借以保护 LeanCloud 应用的数据安全。</p>
<p>如果想要自定义 PV 表述文案，可以修改文章布局模板中的相关代码：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout_macro\post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  &#123;# LeanCould PageView #&#125;</span><br><span class="line">    ...</span><br><span class="line">    &#123;% if theme.post_meta.item_text %&#125;</span><br><span class="line"><span class="deletion">-     &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.views') + __('symbol.colon') &#125;&#125;&lt;/span&gt;</span></span><br><span class="line"><span class="addition">+     &lt;span class="post-meta-item-text"&gt;&#123;&#123;__('post.views')&#125;&#125; &lt;/span&gt;</span></span><br><span class="line">    &#123;% endif %&#125;</span><br><span class="line">    &lt;span class="leancloud-visitors-count"&gt;&lt;/span&gt;</span><br><span class="line"><span class="addition">+   &lt;span&gt;℃&lt;/span&gt;</span></span><br><span class="line">    ...</span><br></pre></td></tr></table></figure>

<p>修改统计表述文案</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">views:</span> <span class="string">热度</span></span><br></pre></td></tr></table></figure>

<p><strong>如遇到报错，在主题配置中设置<code>security: false</code>。</strong></p>
<h3 id="5-4-站点及文章字数统计"><a href="#5-4-站点及文章字数统计" class="headerlink" title="5.4 站点及文章字数统计"></a>5.4 站点及文章字数统计</h3><p>目前由 <a href="https://github.com/theme-next/hexo-symbols-count-time" target="_blank" rel="noopener">hexo-symbols-count-time</a> 提供的字数统计功能需要NexT主题的版本在v7.5或更高才能有效，否则会出现站点总字数比文章总字数更少的bug，留待有空的时候再解决吧。</p>
<h2 id="6-部分功能扩展"><a href="#6-部分功能扩展" class="headerlink" title="6 部分功能扩展"></a>6 部分功能扩展</h2><h3 id="6-1-搞怪网页标题"><a href="#6-1-搞怪网页标题" class="headerlink" title="6.1 搞怪网页标题"></a>6.1 搞怪网页标题</h3><p> 离开和进入页面时动态修改 Tab 标签中的标题。 效果如下</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E6%90%9E%E6%80%AA%E7%BD%91%E9%A1%B5%E8%BF%9B%E5%85%A5.jpg" alt="搞怪网页标题"></p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E6%90%9E%E6%80%AA%E7%BD%91%E9%A1%B5%E8%BF%9B%E5%85%A52.jpg" alt="搞怪网页标题2"></p>
<p>在主题自定义布局文件中添加以下代码</p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout_custom\custom.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">&#123;# 搞怪网页标题 #&#125; &#123;% if theme.title_trick.enable %&#125;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> OriginTitile = <span class="built_in">document</span>.title;</span><br><span class="line">  <span class="keyword">var</span> titleTime;</span><br><span class="line">  <span class="built_in">document</span>.addEventListener(<span class="string">"visibilitychange"</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">document</span>.hidden) &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"&#123;&#123; theme.title_trick.leave &#125;&#125;"</span> + OriginTitile;</span><br><span class="line">      clearTimeout(titleTime);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      <span class="built_in">document</span>.title = <span class="string">"&#123;&#123; theme.title_trick.enter &#125;&#125;"</span> + OriginTitile;</span><br><span class="line">      titleTime = setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="built_in">document</span>.title = OriginTitile;</span><br><span class="line">      &#125;, <span class="number">2000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p>如果首次新建该文件的话，见步骤2.2。</p>
<p>然后在主题配置文件中添加以下代码</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># a trick on website title</span></span><br><span class="line"><span class="attr">title_trick:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">leave:</span> <span class="string">"(つェ⊂)看不见我看不见我"</span></span><br><span class="line">  <span class="attr">enter:</span> <span class="string">"(*´∇｀*) 咦，竟然被你发现了~"</span></span><br></pre></td></tr></table></figure>

<h3 id="6-2-添加站内搜索"><a href="#6-2-添加站内搜索" class="headerlink" title="6.2 添加站内搜索"></a>6.2 添加站内搜索</h3><p>该功能由  <a href="https://github.com/theme-next/hexo-generator-searchdb" target="_blank" rel="noopener">hexo-generator-searchdb</a> 提供 ，在根目录下执行以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-generator-searchdb --save</span><br></pre></td></tr></table></figure>

<p>在<strong>主题配置</strong>文件中修改相关字段：</p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">local_search:</span> </span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">trigger:</span> <span class="string">auto</span> <span class="comment"># 每次输入改变都执行搜索</span></span><br><span class="line">  <span class="attr">top_n_per_article:</span> <span class="number">3</span> <span class="comment"># 每篇文章显示的搜索结果数量</span></span><br><span class="line">  <span class="attr">unescape:</span> <span class="literal">false</span></span><br></pre></td></tr></table></figure>

<p>在<strong>站点配置</strong>文件中添加以下字段：</p>
<figure class="highlight yaml"><figcaption><span>_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">search:</span></span><br><span class="line">  <span class="attr">path:</span> <span class="string">search.xml</span></span><br><span class="line">  <span class="attr">field:</span> <span class="string">post</span> <span class="comment"># 指定搜索范围，可选 post | page | all</span></span><br><span class="line">  <span class="attr">format:</span> <span class="string">html</span> <span class="comment"># 指定页面内容形式，可选 html | raw (Markdown) | excerpt | more</span></span><br><span class="line">  <span class="attr">limit:</span> <span class="number">10000</span></span><br></pre></td></tr></table></figure>

<p>在自定义样式文件中添加如下样式规则来增加搜索弹窗的页边距：</p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css_custom\custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//增加搜索弹窗的页边距</span></span><br><span class="line"><span class="selector-class">.local-search-popup</span> <span class="selector-id">#local-search-result</span> &#123;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">25px</span> <span class="number">40px</span></span><br><span class="line">  <span class="attribute">height</span>: calc(<span class="number">100%</span> - <span class="number">95px</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果你同时在站点内启用了 wobblewindow 边缘摆动效果，则有可能会出现背景蒙版叠加在弹窗之前的问题，这种层级叠加异常的问题主要是因为 wobblewindow 中修改了弹窗父元素的 <code>position</code> 定位和 <code>z-index</code> 优先级，目前只能通过修改 localsearch 源码来修复该 Bug：</p>
<figure class="highlight diff"><figcaption><span>themes\next\layout_third-party\search\localsearch.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: path,</span><br><span class="line">    dataType: isXml ? "xml" : "json",</span><br><span class="line">    async: true,</span><br><span class="line">    success: function(res) &#123;</span><br><span class="line">      // get the contents from search data</span><br><span class="line">      isfetched = true;</span><br><span class="line"><span class="deletion">-     $('.popup').detach().appendTo('.header-inner');</span></span><br><span class="line"><span class="addition">+     $('.popup').detach().appendTo('body');</span></span><br><span class="line">      var datas = isXml ? $("entry", res).map(function() &#123;</span><br><span class="line">        return &#123;</span><br><span class="line">          title: $("title", this).text(),</span><br><span class="line">          content: $("content",this).text(),</span><br><span class="line">          url: $("url" , this).text()</span><br><span class="line">        &#125;;</span><br><span class="line">      &#125;).get() : res;</span><br><span class="line">      ...</span><br></pre></td></tr></table></figure>

<h3 id="6-3-热门文章排行"><a href="#6-3-热门文章排行" class="headerlink" title="6.3 热门文章排行"></a>6.3 热门文章排行</h3><p>该功能是基于 LeanCloud 提供的后端服务支持，原博客教程中的脚本在我这里有点问题没有效果，参考了别的博客的代码。</p>
<p>具体实现方案如下：</p>
<p>在站点目录下执行以下命令新建页面</p>
<figure class="highlight routeros"><table><tr><td class="code"><pre><span class="line">$ hexo new<span class="built_in"> page </span>top</span><br></pre></td></tr></table></figure>

<p>在主题配置文件中新增一项菜单入口：</p>
<figure class="highlight diff"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: / || home</span><br><span class="line"><span class="addition">+   top: /top/ || signal</span></span><br><span class="line">    tags: /tags/ || tags</span><br><span class="line">    categories: /categories/ || th</span><br><span class="line">    archives: /archives/ || archive</span><br><span class="line">    about: /about/ || user</span><br></pre></td></tr></table></figure>

<p> 在语言包中新增菜单中文： </p>
<figure class="highlight diff"><figcaption><span>themes\next\languages\zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line">  menu:</span><br><span class="line">    home: 首页</span><br><span class="line">    archives: 归档</span><br><span class="line">    categories: 分类</span><br><span class="line">    tags: 标签</span><br><span class="line">    about: 关于</span><br><span class="line"><span class="addition">+   top: 排行榜</span></span><br></pre></td></tr></table></figure>

<p> 然后在新增的排行榜页面内添加以下内容，注意要替换掉LeanCloud的appId、appKey和你的博客地址： </p>
<figure class="highlight markdown"><figcaption><span>source\top\index.md</span></figcaption><table><tr><td class="code"><pre><span class="line">---</span><br><span class="line">title: 热门文章Top 10</span><br><span class="line">comments: false</span><br><span class="line">date: 2019-12-28 23:48:26</span><br><span class="line">---</span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">id</span>=<span class="string">"top"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"//cdn1.lncld.net/static/js/3.0.4/av-min.js"</span>&gt;</span></span><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span>&gt;</span></span>AV.initialize("需要替换appID", "需要替换appKEY");<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/javascript"</span>&gt;</span></span></span><br><span class="line"><span class="code">    var time=0</span></span><br><span class="line"><span class="code">    var title=""</span></span><br><span class="line"><span class="code">    var url=""</span></span><br><span class="line"><span class="code">    var query = new AV.Query('Counter');</span></span><br><span class="line"><span class="code">    query.notEqualTo('id',0);</span></span><br><span class="line"><span class="code">    query.descending('time');</span></span><br><span class="line"><span class="code">    query.limit(1000);</span></span><br><span class="line"><span class="code">    query.find().then(function (todo) &#123;</span></span><br><span class="line"><span class="code">        for (var i=0;i&lt;1000;i++)&#123;</span></span><br><span class="line"><span class="code">            var result=todo[i].attributes;</span></span><br><span class="line"><span class="code">            time=result.time;</span></span><br><span class="line"><span class="code">            title=result.title;</span></span><br><span class="line"><span class="code">            url=result.url;</span></span><br><span class="line"><span class="code">            var content="&lt;center&gt;"+"&lt;a href='"+"需要替换https://choubin.site"+url+"'&gt;"+title+"&lt;/a&gt;"+"&lt;br /&gt;"+"&lt;font color='#ff0000'&gt;"+"热度："+time+"℃"+"&lt;/font&gt;"+"&lt;br /&gt;&lt;br /&gt;"+"&lt;/center&gt;";</span></span><br><span class="line"><span class="code">            document.getElementById("top").innerHTML+=content</span></span><br><span class="line"><span class="code">        &#125;</span></span><br><span class="line"><span class="code">    &#125;, function (error) &#123;</span></span><br><span class="line"><span class="code">        console.log("error");</span></span><br><span class="line"><span class="code">    &#125;);</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">style</span>&gt;</span></span>.post-description &#123; display: none; &#125;<span class="xml"><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span></span><br></pre></td></tr></table></figure>

<h3 id="6-4-添加评论功能"><a href="#6-4-添加评论功能" class="headerlink" title="6.4 添加评论功能"></a>6.4 添加评论功能</h3><p>在此使用<code>valine</code>，简洁美观，支持<code>Markdown</code>语法。同样需要 LeanCloud 的 App ID 和 App Key。在主题的配置文件中修改如下。 </p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">valine:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">appid:</span>  <span class="string">***&lt;app_id***</span></span><br><span class="line">  <span class="attr">appkey:</span> <span class="string">***&lt;app_key&gt;***</span></span><br><span class="line">  <span class="attr">notify:</span> <span class="literal">false</span>  <span class="comment"># 收到新评论是否邮件通知</span></span><br><span class="line">  <span class="attr">verify:</span> <span class="literal">false</span>  <span class="comment"># 是否开启验证码</span></span><br><span class="line">  <span class="attr">placeholder:</span>  <span class="comment"># 默认填充文字</span></span><br><span class="line">  <span class="attr">avatar:</span> <span class="string">mm</span>  <span class="comment"># 设置默认评论列表</span></span><br><span class="line">  <span class="attr">guest_info:</span> <span class="string">nick,mail</span>  <span class="comment"># 评论区头部表单</span></span><br><span class="line">  <span class="attr">pageSize:</span> <span class="number">10</span>  <span class="comment"># 每页评论数</span></span><br><span class="line">  <span class="attr">visitor:</span> <span class="literal">true</span>  <span class="comment"># 同时开启文章阅读次数统计</span></span><br></pre></td></tr></table></figure>

<h3 id="6-5-文末版权声明"><a href="#6-5-文末版权声明" class="headerlink" title="6.5 文末版权声明"></a>6.5 文末版权声明</h3><p>效果如图</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E7%89%88%E6%9D%83%E5%A3%B0%E6%98%8E.jpg" alt="版权声明"></p>
<p> 在主题配置文件中开启文章底部的版权声明，版权声明默认使用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank" rel="noopener">CC BY-NC-SA 4.0</a> 许可协议，用户可以根据自身需要修改 <code>licence</code> 字段变更协议。 </p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post_copyright:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">license:</span> <span class="string">&lt;a</span> <span class="string">href="https://creativecommons.org/licenses/by-nc-sa/4.0/"</span> <span class="string">rel="external</span> <span class="string">nofollow"</span> <span class="string">target="_blank"&gt;CC</span> <span class="string">BY-NC-SA</span> <span class="number">4.0</span><span class="string">&lt;/a&gt;</span></span><br></pre></td></tr></table></figure>

<p> 默认版权声明中只有 <strong>本文作者</strong>、<strong>本文链接</strong>、<strong>版权声明</strong> 三项，如果你想添加更多内容，如 <strong>创建时间</strong>、<strong>修改时间</strong>、<strong>引用链接</strong> 等，需要修改版权声明的相关代码： </p>
<figure class="highlight javascript"><figcaption><span>themes\next\layout\_macro\post-copyright.swig</span></figcaption><table><tr><td class="code"><pre><span class="line">&lt;!-- JS库 clipboard 拷贝内容到粘贴板--&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://cdn.bootcss.com/clipboard.js/2.0.1/clipboard.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;!-- JS库 sweetalert 显示提示信息--&gt;</span><br><span class="line">&lt;script src=<span class="string">"https://unpkg.com/sweetalert/dist/sweetalert.min.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line"></span><br><span class="line">&lt;ul <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-copyright"</span>&gt;</span><br><span class="line">  &lt;!-- 本文标题 --&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.copyright.title'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.title &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 本文作者 --&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-copyright-author"</span>&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.copyright.author'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.author | default(author) &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 创建时间 --&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.created'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.date.format("YYYY年MM月DD日 - HH时MM分") &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 修改时间 --&gt;</span><br><span class="line">  &lt;li&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.modified'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125; &lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &#123;&#123; post.updated.format("YYYY年MM月DD日 - HH时MM分") &#125;&#125;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>li&gt;</span><br><span class="line"></span><br><span class="line">  &lt;!-- 引用链接 --&gt;</span><br><span class="line">  &lt;li <span class="class"><span class="keyword">class</span></span>=<span class="string">"post-copyright-link"</span>&gt;</span><br><span class="line">    &lt;strong&gt;&#123;&#123; __(<span class="string">'post.copyright.link'</span>) + __(<span class="string">'symbol.colon'</span>) &#125;&#125;&lt;<span class="regexp">/strong&gt;</span></span><br><span class="line"><span class="regexp">    &lt;a href="&#123;&#123; post.url | default(post.permalink) &#125;&#125;" title="&#123;&#123; post.title &#125;&#125;"</span></span><br><span class="line"><span class="regexp">      &gt;&#123;&#123; post.url | default(post.permalink) &#125;&#125;&lt;/</span>a</span><br><span class="line">    &gt;</span><br><span class="line">    &lt;span <span class="class"><span class="keyword">class</span></span>=<span class="string">"copy-path"</span> title=<span class="string">"点击复制引用链接"</span></span><br><span class="line">      &gt;<span class="xml"><span class="tag">&lt;<span class="name">i</span></span></span></span><br><span class="line"><span class="xml">        style="cursor: pointer"</span></span><br><span class="line"><span class="xml">        class="fa fa-clipboard"</span></span><br><span class="line"><span class="xml">        data-clipboard-text="[&#123;&#123; post.author | default(author) &#125;&#125;'s Blog | &#123;&#123; post.title &#125;&#125;](&#123;&#123; post.permalink &#125;&#125;)"</span></span><br><span class="line"><span class="xml">        aria-label="&#123;&#123; __('post.copy_success') &#125;&#125;"</span></span><br><span class="line"><span class="xml">      &gt;<span class="tag">&lt;/<span class="name">i</span></span></span></span><br><span class="line"><span class="xml">    &gt;<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span></span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  &lt;!-- 版权声明 --&gt;</span></span><br><span class="line"><span class="regexp">  &lt;li class="post-copyright-license"&gt;</span></span><br><span class="line"><span class="regexp">    &lt;strong</span></span><br><span class="line"><span class="regexp">      &gt;&#123;&#123; __('post.copyright.license_title') + __('symbol.colon') &#125;&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>strong&gt;</span><br><span class="line">    &#123;&#123; __(<span class="string">'post.copyright.license_content'</span>, theme.post_copyright.license) &#125;&#125;</span><br><span class="line">  &lt;<span class="regexp">/li&gt;</span></span><br><span class="line"><span class="regexp">&lt;/u</span>l&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">  <span class="keyword">var</span> clipboard = <span class="keyword">new</span> ClipboardJS(<span class="string">".fa-clipboard"</span>);</span><br><span class="line">  clipboard.on(<span class="string">"success"</span>, <span class="function"><span class="keyword">function</span>(<span class="params">target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> message = <span class="built_in">document</span>.createElement(<span class="string">"div"</span>);</span><br><span class="line">    message.innerHTML =</span><br><span class="line">      <span class="string">'&lt;i class="fa fa-check-circle message-icon"&gt;&lt;/i&gt;&lt;span class="message-content"&gt;'</span> +</span><br><span class="line">      target.trigger.getAttribute(<span class="string">"aria-label"</span>) +</span><br><span class="line">      <span class="string">"&lt;/span&gt;"</span>;</span><br><span class="line">    swal(&#123;</span><br><span class="line">      content: message,</span><br><span class="line">      className: <span class="string">"copy-success-message"</span>,</span><br><span class="line">      timer: <span class="number">1000</span>,</span><br><span class="line">      button: <span class="literal">false</span></span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;);</span><br><span class="line">&lt;<span class="regexp">/script&gt;</span></span><br></pre></td></tr></table></figure>

<p> 在版权样式文件中添加如下样式： </p>
<figure class="highlight stylus"><figcaption><span>themes\next\source\css_common\components\post\post-copyright.styl</span></figcaption><table><tr><td class="code"><pre><span class="line">  <span class="attribute">background-color</span>: transparent;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> &#123;</span><br><span class="line">  <span class="attribute">box-shadow</span>: <span class="number">0px</span> <span class="number">4px</span> <span class="number">12px</span> rgba(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">0.15</span>);</span><br><span class="line">  <span class="attribute">border-radius</span>: <span class="number">4px</span>;</span><br><span class="line">  <span class="attribute">width</span>: auto;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">16</span>x <span class="number">0px</span>;</span><br><span class="line">  <span class="attribute">vertical-align</span>: top;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.swal-content</span> &#123;</span><br><span class="line">  <span class="attribute">margin</span>: <span class="number">0px</span> <span class="number">0px</span> !important;</span><br><span class="line">  <span class="attribute">padding</span>: <span class="number">10px</span> <span class="number">16px</span>;</span><br><span class="line">  <span class="attribute">line-height</span>: <span class="number">1em</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.message-icon</span> &#123;</span><br><span class="line">  <span class="attribute">color</span>: <span class="number">#52c41a</span>;</span><br><span class="line">  <span class="attribute">margin-right</span>: <span class="number">8px</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.copy-success-message</span> <span class="selector-class">.message-content</span> &#123;</span><br><span class="line">  <span class="attribute">font-size</span>: <span class="number">14px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>补全版权信息文案</p>
<figure class="highlight yaml"><figcaption><span>themes/next/languages/zh-CN.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">post:</span></span><br><span class="line">  <span class="attr">created:</span> <span class="string">创建时间</span></span><br><span class="line">  <span class="attr">modified:</span> <span class="string">修改时间</span></span><br><span class="line">  <span class="attr">copy_success:</span> <span class="string">复制成功</span></span><br><span class="line">  <span class="attr">copyright:</span></span><br><span class="line">    <span class="attr">title:</span> <span class="string">本文标题</span></span><br><span class="line">    <span class="attr">author:</span> <span class="string">本文作者</span></span><br><span class="line">    <span class="attr">link:</span> <span class="string">引用链接</span></span><br><span class="line">    <span class="attr">license_title:</span> <span class="string">版权声明</span></span><br><span class="line">    <span class="attr">license_content:</span> <span class="string">"本博客所有文章除特别声明外，均采用 %s 许可协议。转载请注明出处！"</span></span><br></pre></td></tr></table></figure>

<p> 在实际使用过程中，并非每篇文章都需要版权声明，如果转载了别人的文章，文末再出现个人版权声明就不太合适。此时可在 Front-Matter 中设定变量 <code>copyright</code> 用于控制是否显示版权信息。修改文章布局模板中相关代码，使得只有当主题配置文件中 <code>post_copyright.enable</code> 字段和 <code>page.copyright</code> 字段同时为 <code>true</code> 时才会插入版权声明： </p>
<figure class="highlight diff"><figcaption><span>themes/next/layout/_macro/post.swig</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="deletion">- &#123;% if theme.post_copyright.enable and not is_index %&#125;</span></span><br><span class="line"><span class="addition">+ &#123;% if theme.post_copyright.enable and page.copyright and not is_index %&#125;</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &#123;% include 'post-copyright.swig' with &#123; post: post &#125; %&#125;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#123;% endif %&#125;</span><br></pre></td></tr></table></figure>

<p> 为了批量为每篇新文章设定该变量并赋默认值，可以修改草稿模板内容，这样以来每篇草稿发布为正文后都会默认显示底部版权信息： </p>
<figure class="highlight diff"><figcaption><span>scaffolds\draft.md</span></figcaption><table><tr><td class="code"><pre><span class="line">  title: &#123;&#123; title &#125;&#125;</span><br><span class="line">  tags:</span><br><span class="line">  categories:</span><br><span class="line"><span class="addition">+ copyright: true</span></span><br></pre></td></tr></table></figure>

<p>或者在每次发布文章时，设定该变量。</p>
<h3 id="6-6-添加打赏功能"><a href="#6-6-添加打赏功能" class="headerlink" title="6.6 添加打赏功能"></a>6.6 添加打赏功能</h3><p> 启用主题配置文件中的打赏相关字段，并将个人收款码图片置于 themes\next\source\images\ 目录下，注意保持图片命名与配置文件中一致： </p>
<figure class="highlight yaml"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">reward_comment:</span></span><br><span class="line"><span class="attr">wechatpay:</span> <span class="string">/images/wechatpay.png</span></span><br><span class="line"><span class="attr">alipay:</span> <span class="string">/images/alipay.jpg</span></span><br></pre></td></tr></table></figure>

<p>关闭悬停收款码上的文字抖动效果，可以在自定义样式文件中添加以下代码： </p>
<figure class="highlight stylus"><figcaption><span>themes/next/source/css/_custom/custom.styl</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment">//关闭打赏收款码的文字抖动效果</span></span><br><span class="line"><span class="selector-id">#QR</span> &gt; <span class="selector-tag">div</span>:hover <span class="selector-tag">p</span> &#123;</span><br><span class="line">  <span class="attribute">animation</span>: none;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>注意原博客中，添加<code>reward</code>字段来控制 是否在本文章中添加打赏信息，然后修改文章布局模板中相关的判定条件将会导致网站首页变成归档，生成静态文件也会报错，故而在此没有采用。</p>
<h3 id="6-7-添加图片灯箱"><a href="#6-7-添加图片灯箱" class="headerlink" title="6.7 添加图片灯箱"></a>6.7 添加图片灯箱</h3><p> 添加灯箱功能，实现点击图片后放大聚焦图片，并支持幻灯片播放、全屏播放、缩略图、快速分享到社交媒体等，该功能由 <a href="https://github.com/fancyapps/fancybox" target="_blank" rel="noopener">fancyBox</a> 提供，效果如下 </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%9B%BE%E7%89%87%E7%81%AF%E7%AE%B1.jpg" alt="图片灯箱"></p>
<p> 在根目录下执行以下命令安装相关依赖： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git <span class="built_in">clone</span> https://github.com/theme-next/theme-next-fancybox3 themes/next/<span class="built_in">source</span>/lib/fancybox</span><br></pre></td></tr></table></figure>

<p> 在主题配置文件中设置 <code>fancybox: true</code> 即可。</p>
<h3 id="6-8-相关文章推荐"><a href="#6-8-相关文章推荐" class="headerlink" title="6.8 相关文章推荐"></a>6.8 相关文章推荐</h3><p> 该功能由 <a href="https://github.com/tea3/hexo-related-popular-posts" target="_blank" rel="noopener">hexo-related-popular-posts</a> 插件提供，会在文末出现本站相关的博客。</p>
<p> 在站点根目录中执行以下命令安装依赖： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-related-popular-posts --save</span><br></pre></td></tr></table></figure>

<p> 在主题配置文件中开启相关文章推荐功能： </p>
<figure class="highlight yaml"><figcaption><span>themes\next_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="attr">related_posts:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">title:</span> <span class="comment"># custom header, leave empty to use the default one</span></span><br><span class="line">  <span class="attr">display_in_home:</span> <span class="literal">false</span></span><br><span class="line">  <span class="attr">params:</span></span><br><span class="line">    <span class="attr">maxCount:</span> <span class="number">5</span></span><br></pre></td></tr></table></figure>

<p> 此时会在每篇文章结尾根据标签相关性和内容相关性来推荐相关文章。 </p>
<h3 id="6-9-文章评分功能"><a href="#6-9-文章评分功能" class="headerlink" title="6.9 文章评分功能"></a>6.9 文章评分功能</h3><p> Next 主题中已经集成了 widgetpack 的星级评分系统，用户无须再安装或引入插件脚本，只需在 widgetpack 中注册账号并修改主题配置即可，应用效果如下： </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E8%AF%84%E5%88%86%E7%B3%BB%E7%BB%9F.jpg" alt="评分效果"></p>
<p>（刚刚还给自己打了个2分。。。。。。）</p>
<p>在 <a href="https://widgetpack.com/" target="_blank" rel="noopener">widgetpack</a> 中注册账号(这个网站经常注册没反应，应该是网络差或者墙的问题，过段时间多试几次就好了），根据引导填写应用名称和域名创建应用，创建后可在页面左上角看到应用 id。</p>
<p>在主题配置文件中开启评分功能，填写应用 id，并设置评分颜色：</p>
<figure class="highlight yaml"><figcaption><span>themes\next\_config.yml</span></figcaption><table><tr><td class="code"><pre><span class="line"><span class="comment"># Star rating support to each article.</span></span><br><span class="line"><span class="comment"># To get your ID visit https://widgetpack.com</span></span><br><span class="line"><span class="attr">rating:</span></span><br><span class="line">  <span class="attr">enable:</span> <span class="literal">true</span></span><br><span class="line">  <span class="attr">id:</span> <span class="comment">#&lt;app_id&gt;</span></span><br><span class="line">  <span class="attr">color:</span> <span class="string">fadb14</span></span><br></pre></td></tr></table></figure>

<p> 在控制台中点击左上角展开菜单，在 <strong>Rating</strong> -&gt; <strong>Setting</strong> 中将 Vote via 选项改为 Device(cookie) 以开启匿名评分，该选项将基于设备认证访问者身份，如果不开启这个选项，那么就需要登录 facebook、twitter 等墙外的社交软件 才能评分，在国内就没啥用了。 </p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%BC%80%E5%90%AF%E5%8C%BF%E5%90%8D%E8%AF%84%E5%88%86.png" alt="匿名评分"></p>
<h2 id="7-提交网址-amp-amp-购买域名"><a href="#7-提交网址-amp-amp-购买域名" class="headerlink" title="7 提交网址&amp;&amp;购买域名"></a>7 提交网址&amp;&amp;购买域名</h2><h3 id="7-1-向搜索引擎提交网址"><a href="#7-1-向搜索引擎提交网址" class="headerlink" title="7.1 向搜索引擎提交网址"></a>7.1 向搜索引擎提交网址</h3><p>这里主要是向谷歌、百度提交网址，以使得可以在搜索引擎中搜到本博客网站的内容。</p>
<p> 在站点根目录下执行以下命令安装相关依赖并重新生成静态文件： </p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save-dev</span><br><span class="line">$ npm install hexo-generator-baidu-sitemap --save-dev</span><br><span class="line">$ hexo g</span><br></pre></td></tr></table></figure>

<p>此时即可在 public 目录下找到 sitemap.xml 和 baidusitemap.xml 两个文件，将该文件提交到搜索引擎站长后台即可帮助搜索引擎分析收录站点内容，各个搜索引擎收录效率不同，可能需要耐心等上几天。 </p>
<p> 在 <a href="https://search.google.com/search-console" target="_blank" rel="noopener">Google Search Console</a> 中提交站点域名，此时会提供几种验证网站所有权的方法，建议使用<strong>HTML文件</strong>验证方法，非常简单，把给的HTML文件下载下来保存到<strong>根目录下source文件夹</strong>下，然后<code>hexo g &amp;&amp; hexo d</code>返回终端点击验证即可。</p>
<p><a href="https://ziyuan.baidu.com/site" target="_blank" rel="noopener">百度同理点这里</a>。</p>
<p><strong>注意这个HTML文件之后也不能删除</strong>。然后等一天左右就可以了。</p>
<h3 id="7-2-购买域名"><a href="#7-2-购买域名" class="headerlink" title="7.2 购买域名"></a>7.2 购买域名</h3><p>购买域名建议去阿里云或者腾讯云，貌似一些域名腾讯云会比阿里云便宜1块钱。至于后缀是选择<code>.com</code>还是别的看个人喜好就行，理论上不影响站点网速。价格上当然<code>.com</code>最贵啦，然后一般网址越短越贵，也越容易已经被人注册过了，已经被人注册了的域名需要回购，而阿里云的代理回购价格是2000起步。。。所以尽量选没人注册的域名吧。</p>
<p>根据网站提示，购买完以后根据相应的网站的提示进行操作和配置就可以了，绑定域名的方法选择<code>CNAME</code>，然后在根目录下的source文件夹中新建一个名为<code>CNAME</code>的文件，文件内容为你购买的域名。然后</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo g &amp;&amp; hexo d</span><br></pre></td></tr></table></figure>

<p>基本过一小会就可以通过你购买的域名来访问自己的博客了。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
  <entry>
    <title>Windows/Linux 下使用 hexo+github+NexT 主题建立个人博客网站</title>
    <url>/2019/12/30/HowToBuildABlog/</url>
    <content><![CDATA[<p>&emsp;&emsp;按照建站惯例（误），本网站的第一篇博客为建站过程，作为记录，以备之后查阅。</p>
<h2 id="1-注册Github"><a href="#1-注册Github" class="headerlink" title="1 注册Github"></a>1 注册Github</h2><p>&emsp;&emsp;本博客没有租用个人服务器，所以需要借助github，注意如果后续没有购买域名的话，最终个人博客的网址将是“xxxx.github.io”，<strong>其中“xxxx”即是你的github账号名</strong>，所以尽量取个喜欢的名字吧。点击<a href="https://github.com/" target="_blank" rel="noopener">Github</a>注册。</p>
<h2 id="2-安装Git"><a href="#2-安装Git" class="headerlink" title="2 安装Git"></a>2 安装Git</h2><p>&emsp;&emsp;Windows：需要下载<a href="https://git-scm.com/download/win" target="_blank" rel="noopener">Git客户端</a>，安装完成以后再安装目录下<code>git-bash.exe</code>、<code>git-cmd.exe</code>和<code>git-gui.exe</code>。在此建议使用<code>git-bash</code>，模拟了<code>bash</code>环境，可以使用大部分<code>unix</code>的标准命令。建议更改<code>git-bash.exe</code>的管理员权限，避免莫名其妙的权限问题。右键点击<code>git-bash.exe</code>，依次选择属性→兼容性→以管理员身份运行此程序→确定。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%8F%B3%E9%94%AE%E5%B1%9E%E6%80%A7.png" alt="图1"></p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E4%BB%A5%E7%AE%A1%E7%90%86%E5%91%98%E8%BA%AB%E4%BB%BD%E8%BF%90%E8%A1%8C%E6%AD%A4%E7%A8%8B%E5%BA%8F.png" alt="图2"></p>
<p>&emsp;&emsp;Linux：直接在终端中安装git，如<code>ubuntu</code>中</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo apt-get install git</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在<code>git-bash</code>或打开中终端中配置</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">"自定义名字"</span></span><br><span class="line">git config --global user.email <span class="string">"邮箱"</span></span><br></pre></td></tr></table></figure>

<h2 id="3-创建Github-Pages"><a href="#3-创建Github-Pages" class="headerlink" title="3 创建Github Pages"></a>3 创建Github Pages</h2><p>&emsp;&emsp;<a href="https://pages.github.com/" target="_blank" rel="noopener">Github Pages</a> 是面向用户、组织和项目开放的<strong>公共静态页面搭建托管服务</strong>，站点被<strong>免费托管在<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>上</strong>，可以使用Github Pages默认提供的域名github.io 或者另外购买域名来发布站点。 </p>
<h3 id="3-1-创建repository"><a href="#3-1-创建repository" class="headerlink" title="3.1 创建repository"></a>3.1 创建repository</h3><p>&emsp;&emsp;首先在Github新建一个repository，即点击右上角的加号，选择<code>New repository</code></p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E6%96%B0%E5%BB%BA%E4%BB%93%E5%BA%93.png" alt="新建仓库"></p>
<p>&emsp;&emsp;这里的repository name必须是 <code>xxxx.github.io</code>，<strong>其中<code>xxxx</code>为你的github账号用户名</strong>。其他的默认就可以了。</p>
<h3 id="3-2-克隆repository到本地"><a href="#3-2-克隆repository到本地" class="headerlink" title="3.2 克隆repository到本地"></a>3.2 克隆repository到本地</h3><p>&emsp;&emsp;如果之前没有<code>SSH KEY</code>的话需要先创建<code>SSH KEY</code>，<a href="[https://github.com/Hunter1023/learn_Git/wiki/%E8%BF%9C%E7%A8%8B%E4%BB%93%E5%BA%93#ssh](https://github.com/Hunter1023/learn_Git/wiki/远程仓库#ssh)">可以参考这里</a>。</p>
<p>&emsp;&emsp;在上一步建好的repository的右上角点击<code>Clone or download</code>，使用<code>clone with SSH</code>，点击出现连接的右边按钮，复制SSH地址。</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/%E5%85%8B%E9%9A%86%E4%BB%93%E5%BA%93.jpg" alt="克隆仓库"></p>
<p>&emsp;&emsp;然后在本地电脑的合适位置新建一个文件夹用于存放本地repository，进入建好的文件夹，Windows用户右键选择打开<code>git-bash.exe</code>，Linux用户就右键打开终端，然后在终端中粘贴刚才复制的SSH地址，回车执行。</p>
<h3 id="3-3-推送本地改动到github上"><a href="#3-3-推送本地改动到github上" class="headerlink" title="3.3 推送本地改动到github上"></a>3.3 推送本地改动到github上</h3><p>&emsp;&emsp;在刚才文件夹的写一个简单的<code>html</code>文件</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">“hello world！”</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;然后在终端中执行</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git add .</span><br><span class="line">git commit -m</span><br><span class="line">git push</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时访问<code>xxxx.github.io</code>即可看到刚才的<code>hello world</code>网页。</p>
<h2 id="4-安装环境-amp-amp-创建本地博客"><a href="#4-安装环境-amp-amp-创建本地博客" class="headerlink" title="4 安装环境&amp;&amp;创建本地博客"></a>4 安装环境&amp;&amp;创建本地博客</h2><p>&emsp;&emsp;环境安装主要是<code>Nodejs</code>和<code>hexo</code>，Windows下具体可参考<a href="https://blog.csdn.net/weixin_39345384/article/details/80097858#t1" target="_blank" rel="noopener">安装Node.js</a>和<a href="https://blog.csdn.net/weixin_39345384/article/details/80098228#t2" target="_blank" rel="noopener">安装hexo</a>。Linux下和安装其他软件没有区别。</p>
<p>&emsp;&emsp;安装完环境以后，新建一个文件夹作为本地博客的目录，然后在该文件夹下右键打开<code>git-bash</code>或终端，依次输入以下指令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo init &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;其中<code>hexo g</code> 即为<code>hexo generate</code>别名，同理<code>hexo s</code>为<code>hexo server</code>别名。</p>
<p>&emsp;&emsp;此时可以打开浏览器输入网站<code>localhost:4000</code>查看默认的博客。</p>
<h2 id="5-部署到Github-Pages"><a href="#5-部署到Github-Pages" class="headerlink" title="5 部署到Github Pages"></a>5 部署到Github Pages</h2><p>&emsp;&emsp;首先安装<code>hexo-deployer-git</code>，注意还是在本地博客文件夹下打开的<code>git-bash</code>键入以下命令</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;修改博客文件夹根目录下的网站配置文件<code>_config.yml</code>中的<code>deploy</code>配置，<strong>注意冒号后有一个空格</strong></p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">deploy:</span></span><br><span class="line">  <span class="attr">type:</span> <span class="string">git</span></span><br><span class="line">  <span class="attr">repo:</span> <span class="string">git@github.com:xxxx/xxxx.github.io.git</span>  <span class="comment">#3.2步骤中克隆仓库的SSH地址</span></span><br><span class="line">  <span class="attr">branch:</span> <span class="string">master</span>  <span class="comment">#分支，一般用 master 即可</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;保存修改后在<code>git-bash</code>或终端中键入</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;这里<code>hexo d</code>为<code>hexo deploy</code>别名。</p>
<h2 id="6-使用NexT主题"><a href="#6-使用NexT主题" class="headerlink" title="6 使用NexT主题"></a>6 使用NexT主题</h2><p>&emsp;&emsp;可选的主题有很多，在这里<a href="https://hexo.io/themes/" target="_blank" rel="noopener">下载到各种官方主题</a>。</p>
<p>&emsp;&emsp;本站主题是基于<code>NexT主题 v6.4.2</code>版本，<a href="https://github.com/theme-next/hexo-theme-next/releases/tag/v6.4.2" target="_blank" rel="noopener">下载链接在这里</a>，后续文章将详细记录对主题如何配置和修改来达到和本站一样的效果。</p>
<p>&emsp;&emsp;下载主题的压缩包以后，将其解压到博客根目录下的<code>theme</code>文件夹下，并命名为<code>next</code>。</p>
<p>&emsp;&emsp;然后在网站的配置文件<code>_config.yml</code>中将<code>theme</code>字段的值修改为<code>next</code>，同样<strong>注意冒号后有一个空格</strong>，下文不再赘述。</p>
<figure class="highlight yaml"><table><tr><td class="code"><pre><span class="line"><span class="attr">theme:</span> <span class="string">next</span></span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;此时重新生成静态文件，重启服务器</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo c &amp;&amp; hexo g &amp;&amp; hexo s</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;即可在本地端口<code>localhost:4000</code>中查看新主题下的网站</p>
<p><img src="https://choubin-1300968093.cos.ap-beijing.myqcloud.com/blogImg/next%E4%B8%BB%E9%A2%98.png" alt="next主题"></p>
<p>&emsp;&emsp;如果对主题没有定制化需求的话，那么此时直接进行部署就可以了。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">hexo d</span><br></pre></td></tr></table></figure>

<p>&emsp;&emsp;如果想定制得和本网站类似的话，可以参考关于主题配置修改的后续博客。</p>
]]></content>
      <categories>
        <category>技术</category>
        <category>博客</category>
      </categories>
      <tags>
        <tag>Blog</tag>
        <tag>hexo</tag>
      </tags>
  </entry>
</search>
